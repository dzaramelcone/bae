---
phase: 28-input-gates
plan: 03
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - bae/repl/toolbar.py
  - bae/repl/shell.py
  - tests/repl/test_toolbar.py
  - tests/repl/test_graph_commands.py
autonomous: true

must_haves:
  truths:
    - "Pending gate count shows as a toolbar badge visible in all modes"
    - "Badge is hidden when no gates are pending"
    - "`@g<digits> <value>` from non-NL modes resolves a pending gate"
    - "Shush mode (badge only) vs inline notification is toggleable"
    - "NL mode `@g` prefix routes to NL session (existing behavior preserved)"
  artifacts:
    - path: "bae/repl/toolbar.py"
      provides: "make_gates_widget factory"
      contains: "make_gates_widget"
    - path: "bae/repl/shell.py"
      provides: "shush_gates attribute, @g routing, widget registration"
      contains: "shush_gates"
  key_links:
    - from: "bae/repl/toolbar.py"
      to: "bae/repl/engine.py"
      via: "shell.engine.pending_gate_count()"
    - from: "bae/repl/shell.py"
      to: "bae/repl/engine.py"
      via: "shell.engine.get_pending_gate + resolve_gate for @g routing"
---

<objective>
Add toolbar badge for pending gates, cross-mode `@g` input routing, and shush mode toggle.

Purpose: Dzara needs to know when gates are pending regardless of which mode she's in (toolbar badge). She needs to respond from any non-NL mode without switching to GRAPH mode (`@g1.0 yes`). Shush mode lets her control notification verbosity.

Output: Toolbar shows pending gate count, @g prefix resolves gates from PY/BASH modes, shush_gates toggles inline notifications.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/28-input-gates/28-RESEARCH.md
@.planning/phases/28-input-gates/28-01-SUMMARY.md

@bae/repl/toolbar.py
@bae/repl/shell.py
@bae/repl/engine.py
@tests/repl/test_toolbar.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Toolbar gates badge widget</name>
  <files>bae/repl/toolbar.py, bae/repl/shell.py, tests/repl/test_toolbar.py</files>
  <action>
1. In `bae/repl/toolbar.py`, add `make_gates_widget(shell) -> ToolbarWidget`:
   ```python
   def make_gates_widget(shell) -> ToolbarWidget:
       """Built-in widget: pending input gate count (hidden when zero)."""
       def widget():
           n = shell.engine.pending_gate_count()
           if n == 0:
               return []
           label = f" {n} gate{'s' if n != 1 else ''} "
           return [("class:toolbar.gates", label)]
       return widget
   ```

2. In `bae/repl/shell.py`:
   a. Import `make_gates_widget` from toolbar.
   b. In `CortexShell.__init__`, register the gates widget. Insert it after "tasks" and before "mem":
      ```python
      self.toolbar.add("gates", make_gates_widget(self))
      ```
   c. Add `"toolbar.gates"` style to the Style.from_dict: `"toolbar.gates": "fg:ansimagenta bold"` (magenta for visual distinction from yellow tasks).
   d. Add `self.shush_gates: bool = False` to `CortexShell.__init__`.

3. In `tests/repl/test_toolbar.py`, add tests:
   - `test_gates_widget_hidden_when_zero`: Create widget with a mock shell whose engine.pending_gate_count() returns 0. Widget returns [].
   - `test_gates_widget_shows_count`: Mock engine.pending_gate_count() returns 3. Widget returns styled tuple with "3 gates".
   - `test_gates_widget_singular`: Mock returns 1. Widget shows "1 gate" (no trailing s).
  </action>
  <verify>
`uv run pytest tests/repl/test_toolbar.py -x -q` passes.
  </verify>
  <done>Toolbar displays pending gate count badge (hidden when zero, singular/plural). Widget registered in CortexShell between tasks and mem. Style applied.</done>
</task>

<task type="auto">
  <name>Task 2: Cross-mode @g routing and shush toggle</name>
  <files>bae/repl/shell.py, tests/repl/test_graph_commands.py</files>
  <action>
1. In `bae/repl/shell.py`, in `_dispatch()`, add cross-mode gate routing BEFORE the mode-specific dispatch block. Insert right after `if not text.strip(): continue` equivalent (but _dispatch already receives stripped text). Add at the top of _dispatch:

   ```python
   # Cross-mode gate input: @g<digits> <value>
   # Only from non-NL modes. NL mode preserves @label session routing.
   if self.mode != Mode.NL and text.startswith("@g") and len(text) > 2:
       rest = text[2:]
       space = rest.find(" ")
       if space > 0 and rest[:space].replace(".", "").isdigit():
           gate_id = "g" + rest[:space]
           raw_value = rest[space + 1:]
           await self._resolve_gate_input(gate_id, raw_value)
           return
   ```

   Note: gate_id format is "g1.0" so we need to allow dots in the digits check. Use `rest[:space].replace(".", "").isdigit()` to allow "1.0" format.

2. Add `_resolve_gate_input` method to CortexShell:
   ```python
   async def _resolve_gate_input(self, gate_id: str, raw_value: str) -> None:
       """Resolve a pending gate from any mode via @g prefix."""
       gate = self.engine.get_pending_gate(gate_id)
       if gate is None:
           self.router.write("graph", f"no pending gate {gate_id}", mode="GRAPH")
           return

       from pydantic import TypeAdapter
       try:
           adapter = TypeAdapter(gate.field_type)
           value = adapter.validate_python(raw_value)
       except Exception as e:
           type_name = getattr(gate.field_type, '__name__', str(gate.field_type))
           self.router.write(
               "graph",
               f"invalid value for {gate.field_name} ({type_name}): {e}",
               mode="GRAPH",
           )
           return

       self.engine.resolve_gate(gate_id, value)
       self.router.write(
           "graph", f"resolved {gate_id}: {gate.field_name} = {value!r}",
           mode="GRAPH",
           metadata={"type": "lifecycle", "run_id": gate.run_id},
       )
   ```

3. Add shush mode mechanism. The `shush_gates` boolean is already on CortexShell (from task 1). The notification callback created in graph_commands.py (plan 02) should check `shell.shush_gates` before emitting inline notifications. Since plan 02 may or may not be complete when this runs, make the shush check defensive:

   In `_resolve_gate_input`, the resolution message always shows (it's a response to explicit user action). The shush toggle only affects unsolicited gate notifications (emitted when a graph creates a gate). The notify callback in plan 02's `_cmd_run` should check `shell.shush_gates`. If plan 02 is not yet integrated, add a comment noting where shush should be checked.

   Add a `shush` command to GRAPH mode dispatch: either add it in graph_commands.py or keep it simple by checking in _dispatch. Since plan 02 owns graph_commands.py, add the `shush` toggle in shell.py as a pre-dispatch check:

   Actually, cleaner to just add it via graph_commands. But graph_commands.py is in plan 02's file list. To avoid file conflicts, implement shush as a property on CortexShell that plan 02's notify callback can check, and add the `shush` command handler here since this plan also modifies shell.py.

   Add to `_dispatch`, in the GRAPH mode branch, before calling dispatch_graph:
   ```python
   elif self.mode == Mode.GRAPH:
       if text.strip().lower() == "shush":
           self.shush_gates = not self.shush_gates
           state = "on" if self.shush_gates else "off"
           self.router.write("graph", f"shush mode {state}", mode="GRAPH")
           return
       await dispatch_graph(text, self)
   ```

4. **Tests** -- add to `tests/repl/test_graph_commands.py` (since these test GRAPH mode behaviors):
   - `test_cross_mode_gate_resolve`: Set up FakeShell with engine and a pending gate. Simulate `_resolve_gate_input("g1.0", "true")` on a bool gate, verify resolution.
   - `test_cross_mode_gate_not_found`: Call `_resolve_gate_input` with non-existent gate_id, verify error message.
   - `test_cross_mode_nl_mode_preserves_session_routing`: Verify that in NL mode, "@g1 hello" does NOT route to gates (it routes to NL session "g1").

   For the NL mode test, this is about verifying the condition `self.mode != Mode.NL` in _dispatch. Since we can't easily test _dispatch directly (it requires a full CortexShell), assert the logic by testing the condition check: create a test that verifies the @g routing only triggers when mode is not NL. This can be a unit test of the condition logic itself, or test via FakeShell.
  </action>
  <verify>
`uv run pytest tests/repl/test_graph_commands.py tests/repl/test_toolbar.py -x -q` passes. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` passes.
  </verify>
  <done>Toolbar shows pending gate count. @g prefix resolves gates from PY/BASH/GRAPH modes. NL mode preserves session routing. Shush mode toggleable via `shush` command in GRAPH mode. All tests pass.</done>
</task>

</tasks>

<verification>
1. Toolbar shows "N gate(s)" when gates are pending, hidden when zero
2. `@g1.0 yes` from PY mode resolves a pending gate
3. `@g1 hello` from NL mode routes to NL session (not gates)
4. `shush` in GRAPH mode toggles shush_gates
5. Full test suite passes: `uv run pytest tests/ -x -q --ignore=tests/test_integration.py`
</verification>

<success_criteria>
Toolbar badge visible in all modes showing pending gate count. Cross-mode @g routing works from non-NL modes. Shush mode toggleable. NL mode @g prefix preserved for session routing.
</success_criteria>

<output>
After completion, create `.planning/phases/28-input-gates/28-03-SUMMARY.md`
</output>
