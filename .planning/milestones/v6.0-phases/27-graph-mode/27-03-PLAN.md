---
phase: 27-graph-mode
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/graph.py
  - bae/repl/graph_commands.py
  - tests/repl/test_graph_commands.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "run <expr> can reference parameter types (e.g. UserInfo) without the user manually importing them"
    - "ls is not a recognized GRAPH mode command"
  artifacts:
    - path: "bae/graph.py"
      provides: "_param_types dict on graph() wrapper"
      contains: "_param_types"
    - path: "bae/repl/graph_commands.py"
      provides: "Type injection in _cmd_run, no ls alias"
      contains: "_param_types"
    - path: "tests/repl/test_graph_commands.py"
      provides: "Tests for type injection and ls removal"
  key_links:
    - from: "bae/graph.py"
      to: "bae/repl/graph_commands.py"
      via: "wrapper._param_types consumed by _cmd_run"
      pattern: "_param_types"
---

<objective>
Close two UAT gaps from Phase 27: (1) graph() wrappers must expose their parameter types so `run <expr>` can evaluate expressions like `ootd(user_info=UserInfo(), user_message="hi")` without requiring the user to manually import `UserInfo` into the namespace, and (2) remove the `ls` alias from the GRAPH mode dispatch table.

Purpose: Make `run <expr>` non-leaky -- Dzara should never need to know or import the internal types that a graph callable expects.
Output: Updated graph.py, graph_commands.py, and tests.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-graph-mode/27-02-SUMMARY.md
@bae/graph.py
@bae/repl/graph_commands.py
@tests/repl/test_graph_commands.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store parameter types on graph() wrapper and inject in _cmd_run</name>
  <files>bae/graph.py, bae/repl/graph_commands.py</files>
  <action>
  In `bae/graph.py`, in the `graph()` function, after building the signature and setting `wrapper._name`, add:

  ```python
  wrapper._param_types = {
      name: fi.annotation for name, fi in g._input_fields.items()
      if isinstance(fi.annotation, type)
  }
  ```

  This stores a dict mapping parameter name to its type class (e.g. `{"user_info": UserInfo, "user_message": str}`). Only stores actual type objects, not strings or complex annotations.

  In `bae/repl/graph_commands.py`, in `_cmd_run`, before the `async_exec` call, scan `shell.namespace` for all values that have a `_param_types` attribute and inject those types into the namespace. This ensures any graph callable's parameter types are available for expression evaluation:

  ```python
  # Inject graph callable parameter types into eval namespace
  for obj in shell.namespace.values():
      param_types = getattr(obj, "_param_types", None)
      if param_types:
          for type_name, type_cls in param_types.items():
              cls_name = type_cls.__name__
              if cls_name not in shell.namespace:
                  shell.namespace[cls_name] = type_cls
  ```

  Place this block right before the `async_exec` call (after the `if not arg` guard). This is permanent injection -- once a graph callable is in the namespace, its types stay available. This is intentional: the types belong in the user's namespace since they represent domain concepts the user works with.

  Also in `dispatch_graph`, remove the `"ls": _cmd_list` entry from the `handlers` dict. Update the unknown-command help string to remove the `(ls = list)` suffix -- just show the command names.
  </action>
  <verify>
  `uv run pytest tests/repl/test_graph_commands.py -x -q` -- existing tests pass (except the ls alias test, which should now fail).
  `uv run python -c "from bae.graph import graph; from bae.node import Node; exec('class T(Node):\\n    x: int\\n    async def __call__(self) -> None: ...'); w = graph(start=T); print(w._param_types)"` -- shows `{'x': <class 'int'>}`.
  </verify>
  <done>graph() wrapper has _param_types dict. _cmd_run injects types before eval. ls alias removed from dispatch.</done>
</task>

<task type="auto">
  <name>Task 2: Update tests for type injection and ls removal</name>
  <files>tests/repl/test_graph_commands.py</files>
  <action>
  In `tests/repl/test_graph_commands.py`:

  1. **Remove `test_ls_alias`** from `TestCmdList` -- ls is no longer a valid command.

  2. **Add `test_ls_unknown`** to `TestDispatch` -- verify that `ls` now returns "unknown command":
     ```python
     async def test_ls_is_unknown(self, shell):
         """ls is not a recognized command."""
         await dispatch_graph("ls", shell)
         out = _output(shell.router)
         assert "unknown command" in out.lower()
     ```

  3. **Add test for type injection** to `TestCmdRun`. The key test: a graph callable's parameter types should be auto-injected so the user doesn't need to import them.

     In the test fixture, note that `TStart` requires `message: str` -- `str` is a builtin so not useful for testing injection. Instead, create a new test node pair at module level that uses a custom type as a parameter:

     ```python
     class TInput(BaseModel):
         value: str

     class TTypedStart(Node):
         inp: TInput
         async def __call__(self) -> TEnd: ...
     ```

     Add `BaseModel` to imports (from pydantic).

     Then create a graph callable from it and add it to the shell fixture namespace:
     ```python
     typed_graph = graph(start=TTypedStart)
     s.namespace["typed_graph"] = typed_graph
     ```

     The test:
     ```python
     async def test_run_injects_param_types(self, shell):
         """run auto-injects graph callable parameter types into namespace."""
         # TInput is NOT in shell.namespace initially
         assert "TInput" not in shell.namespace
         # Running a command that references typed_graph triggers injection
         await dispatch_graph("run typed_graph(inp=TInput(value='hi'), lm=MockLM())", shell)
         out = _output(shell.router)
         assert "submitted" in out
         # TInput was injected
         assert "TInput" in shell.namespace
         await _drain(shell.tm)
     ```

  4. **Update `test_unknown_command`** if needed -- verify it doesn't check for "ls" in the help output (the help string no longer mentions ls).
  </action>
  <verify>`uv run pytest tests/repl/test_graph_commands.py -x -q` -- all tests pass including new ones.</verify>
  <done>Tests confirm: type injection works for graph callable params, ls is rejected as unknown, existing command tests still pass.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/repl/test_graph_commands.py -x -q` -- all pass
- `uv run pytest tests/test_graph.py -x -q` -- graph factory tests still pass
- `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite passes
</verification>

<success_criteria>
- `run ootd(user_info=UserInfo(), user_message="hi")` resolves UserInfo from the wrapper's _param_types without manual import
- `ls` in GRAPH mode shows "unknown command"
- All existing tests pass, new tests cover both gaps
</success_criteria>

<output>
After completion, create `.planning/phases/27-graph-mode/27-03-SUMMARY.md`
</output>
