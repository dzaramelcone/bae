# Milestone v5.0: Stream Views

**Status:** SHIPPED 2026-02-14
**Phases:** 21-25
**Total Plans:** 9

## Overview

Multi-view stream framework with tool call translation and execution display overhaul. AI responses use `<run>` convention for executable code, tool call tags are intercepted and executed natively, and three pluggable view formatters render channel output with runtime cycling.

## Phases

### Phase 21: Execution Convention
**Goal**: Eval loop only executes code the AI explicitly marks as executable
**Depends on**: Nothing (first v5.0 phase)
**Plans**: 2 plans

Plans:
- [x] 21-01: Eval harness — test 6 convention candidates across Opus/Sonnet/Haiku, select winner
- [x] 21-02: Implement winning convention — replace extract_code, update prompt and eval loop

**Details:**
- xml_tag convention (`<run>code</run>`) selected with 100% compliance
- extract_executable() replaces extract_code() with `<run>` regex
- Single-block policy: first `<run>` block executes, extras produce feedback
- System prompt teaches convention with 5 fewshot examples
- Requirements: EXEC-01, EXEC-02

### Phase 22: Tool Call Translation
**Goal**: AI tool call attempts are caught, translated to Python, and executed transparently
**Depends on**: Phase 21 (convention for marking translated code)
**Plans**: 2 plans

Plans:
- [x] 22-01: TDD — translate_tool_calls() pure function with all 5 tool types and fence exclusion
- [x] 22-02: Eval loop integration, system prompt tool tag vocabulary, visible indicator

**Details:**
- run_tool_calls() detects and executes tool tags (R, W, E, G, Grep) in AI responses
- Tags inside `<run>` blocks and markdown fences excluded
- Tool calls take precedence over `<run>` blocks
- _tool_summary() generates concise display summaries
- System prompt teaches all 5 tag formats with reference table
- Requirements: AIHR-02 through AIHR-08

### Phase 23: View Framework
**Goal**: Channel display is pluggable via formatter strategy, with zero change to existing behavior
**Depends on**: Nothing (independent infrastructure)
**Plans**: 1 plan

Plans:
- [x] 23-01: ViewFormatter protocol, Channel._formatter field, _display() delegation + tests

**Details:**
- ViewFormatter protocol with @runtime_checkable in channels.py
- Channel._formatter field with conditional delegation in _display()
- Zero regression: all 39 existing tests pass unchanged
- Requirements: VIEW-01, VIEW-02

### Phase 24: Execution Display
**Goal**: AI code execution renders as polished framed panels with deduplication
**Depends on**: Phase 23 (formatter infrastructure)
**Plans**: 1 plan

Plans:
- [x] 24-01: UserView formatter with buffered exec grouping, panel rendering, shell wiring

**Details:**
- UserView buffers ai_exec, flushes grouped Rich Panel on ai_exec_result
- Syntax highlighting (monokai), dim borders, cyan title, code+output grouping
- Stale buffer auto-flush on interrupt
- Fallback prefix display for non-AI py channel writes
- Requirements: VIEW-03, DISP-01 through DISP-04

### Phase 25: Views Completion
**Goal**: User can cycle between debug, AI-self, and user views at runtime
**Depends on**: Phase 23 (framework), Phase 24 (UserView as reference)
**Plans**: 3 plans

Plans:
- [x] 25-01: DebugView + AISelfView formatters, ViewMode enum, VIEW_FORMATTERS dict
- [x] 25-02: Shell wiring — _set_view, Ctrl+V keybinding, toolbar view widget
- [x] 25-03: Gap closure — summarize tool call display in UserView

**Details:**
- DebugView: raw [channel] key=value metadata headers + indented content
- AISelfView: AI-perspective tag mapping (ai-output, exec-code, tool-call, etc.)
- ViewMode enum with VIEW_CYCLE and VIEW_FORMATTERS routing
- Ctrl+V cycles USER -> DEBUG -> AI_SELF -> USER
- _set_view swaps all channel formatters atomically
- Toolbar indicator hidden in USER mode, shows mode name otherwise
- _tool_summary() for concise tool call display
- _strip_executable() for clean response rendering
- Requirements: VIEW-04, VIEW-05, VIEW-06

---

## Milestone Summary

**Key Decisions:**
- xml_tag convention over fence_annotation: 100% compliance, clean separation
- Tool tags take precedence over `<run>` blocks when both present
- ViewFormatter as Protocol in channels.py (not separate file) to avoid circular imports
- UserView only on py channel — ai channel keeps existing path
- Fresh formatter instance per view switch to avoid stale buffer state
- Removed tool_result channel write — summary in tool_translated metadata replaces it

**Issues Resolved:**
- AI tool call hallucination handled via interception + native execution
- Code execution display deduplication (no redundant [py] lines)
- Response display stripping of `<run>` blocks and tool tags
- Coroutine stdout capture during await

**Issues Deferred:**
- AIHR-01: Explicit no-tools constraint fewshot (prompt engineering iteration)
- AI streaming/progressive display for NL responses
- tests/traces/json_structured_fill_reference.py drift

**Technical Debt Incurred:**
- Phase 24 visual appearance requires human verification in live REPL

---

_For current project status, see .planning/ROADMAP.md_
