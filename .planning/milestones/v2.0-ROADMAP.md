# Milestone v2.0: Context Frames

**Status:** SHIPPED 2026-02-08
**Phases:** 5-10
**Total Plans:** 21

## Overview

Redesigned the node API around the "nodes as context frames" paradigm — Dep/Recall field annotations, implicit LM, clean start/terminal semantics, JSON structured fill with constrained decoding, and explicit Field(description=...) hints replacing docstrings.

## Phases

### Phase 5: Markers & Resolver
**Goal**: Field-level dependency resolution and trace recall work correctly in isolation
**Depends on**: Phase 4 (v1.0 complete)
**Requirements**: DEP2-01, DEP2-02, DEP2-03, DEP2-04, DEP2-05, RCL-01, RCL-02, RCL-03
**Plans**: 4 plans

Plans:
- [x] 05-01-PLAN.md — TDD: v2 Dep/Recall markers, RecallError, classify_fields
- [x] 05-02-PLAN.md — TDD: Dep DAG construction and build-time validation
- [x] 05-03-PLAN.md — TDD: Recall from trace
- [x] 05-04-PLAN.md — TDD: Resolver (dep resolution, caching, resolve_fields)

**Success Criteria:**
1. `Annotated[T, Dep(fn)]` field causes the resolver to call `fn` and return the result for injection
2. Dep functions whose parameters are themselves dep-typed resolve bottom-up via topological sort (chaining works)
3. Circular dep chains raise a clear error naming the cycle at graph build time
4. Recall() searches a trace list backward and returns the most recent node field matching the target type
5. Recall on a start node raises an error at graph build time (no trace exists yet)

### Phase 6: Node & LM Protocol
**Goal**: Nodes declare field sources through annotations; LM fills only what it should, configured at graph level
**Depends on**: Phase 5
**Requirements**: NODE-01, NODE-02, NODE-03, NODE-04, LM-01, LM-02, LM-03, LM-04
**Plans**: 5 plans

Plans:
- [x] 06-01-PLAN.md — TDD: NodeConfig standalone TypedDict + node_config ClassVar + _wants_lm
- [x] 06-02-PLAN.md — TDD: node_to_signature() v2 with classify_fields integration
- [x] 06-03-PLAN.md — TDD: GraphResult.result property + Graph[T] optional generic
- [x] 06-04-PLAN.md — TDD: LM Protocol choose_type/fill methods + backend implementations
- [x] 06-05-PLAN.md — Package exports + full regression verification

**Success Criteria:**
1. Node fields without Dep/Recall annotations are identified as LLM-filled; fields with Dep/Recall are identified as context
2. Start node fields (without Dep) are identifiable as caller-provided input via `is_start` parameter in signature generation
3. Terminal node (returns None) fields are accessible as the graph's response schema via `GraphResult.result`
4. NodeConfig provides per-node LM override infrastructure; `_wants_lm` detects opt-in `lm` injection in `__call__`; graph-level LM integration wired in Phase 7
5. LM protocol exposes `choose_type()` (pick successor from union) and `fill()` (populate plain fields given resolved context) on all backends

### Phase 7: Integration
**Goal**: Graph.run() assembles context frames from all sources and executes the full node lifecycle
**Depends on**: Phase 5, Phase 6
**Requirements**: DEP2-06, CLN-03
**Plans**: 4 plans

Plans:
- [x] 07-01-PLAN.md — TDD: Error hierarchy (DepError/FillError) + _wants_lm type-hint detection
- [x] 07-02-PLAN.md — TDD: Graph.run() v2 rewrite with resolve_fields and choose_type/fill
- [x] 07-03-PLAN.md — Test migration + incant removal from pyproject.toml
- [x] 07-04-PLAN.md — Phase gate: regression + success criteria verification

**Success Criteria:**
1. Dep fields on the start node are auto-resolved in the first loop iteration
2. Each execution loop iteration resolves deps, resolves recalls, then has LM fill remaining fields — in that order
3. The incant dependency is removed; dep resolution uses bae's own resolver
4. A multi-node graph with deps, recalls, and LLM-filled fields runs end-to-end producing correct results

### Phase 8: Cleanup & Migration
**Goal**: v1 markers are gone, all tests use v2 patterns, reference example works end-to-end
**Depends on**: Phase 7
**Requirements**: CLN-01, CLN-02, CLN-04, CLN-05
**Plans**: 4 plans

Plans:
- [x] 08-01-PLAN.md — Source-side v1 marker removal (Context, Bind, Dep.description)
- [x] 08-02-PLAN.md — Test migration batch 1 (compiler, dspy_backend, signature_v2)
- [x] 08-03-PLAN.md — Test migration batch 2 (auto_routing, optimized_lm, optimizer, integration_dspy, resolver)
- [x] 08-04-PLAN.md — Phase gate: CompiledGraph fix, full suite, ootd.py E2E

**Success Criteria:**
1. Context marker is removed from codebase and package exports — importing it raises ImportError
2. Bind marker is removed from codebase and package exports — importing it raises ImportError
3. All tests use v2 patterns (Dep(callable) on fields, Recall(), implicit LM) — no v1 marker usage remains
4. `examples/ootd.py` runs end-to-end with the v2 runtime and produces a valid outfit recommendation

### Phase 9: JSON Structured Fill
**Goal**: fill() uses JSON structured output with constrained decoding
**Depends on**: Phase 8
**Plans**: 1 plan (spike)

Plans:
- [x] spike/e2e-cli — JSON structured fill implementation (102 commits)

**Success Criteria:**
1. fill() prompt includes input schema + source data + resolved deps + instruction
2. Output JSON schema via `_build_plain_model()` + `transform_schema()` + constrained decoding
3. Two-stage validation: DepError for deps, FillError for plain fields
4. ClaudeCLIBackend uses JSON mode for fill and choose_type
5. All `format_as_xml` removed — JSON everywhere
6. ootd.py E2E works (~17s haiku, 3-node trace)

### Phase 10: Field Descriptions & Docstring Removal
**Goal**: Make docstrings inert and use Field(description=...) for explicit per-field LLM context
**Depends on**: Phase 9
**Plans**: 3 plans

Plans:
- [x] 10-01-PLAN.md — TDD: Drop docstrings from all instruction/prompt builders
- [x] 10-02-PLAN.md — TDD: Fix _build_plain_model to preserve Field descriptions + ootd.py update
- [x] 10-03-PLAN.md — Gap closure: Remove __doc__ from DSPyBackend (compiler.py + dspy_backend.py)

**Success Criteria:**
1. `_build_instruction()` returns class name only — `__doc__` is NOT read
2. `_node_to_prompt()` on both backends does NOT read `__doc__`
3. `_build_plain_model()` preserves `Field(description=...)` in the dynamic model
4. Docstrings on Node subclasses are NOT automatically included in LLM prompts
5. `examples/ootd.py` fields use `Field(description=...)` where helpful

---

## Milestone Summary

**Key Decisions:**
- Nodes are context frames — fields ARE prompt context, class name IS instruction, return type IS output schema
- Three field sources: Dep(callable), Recall(), plain (LLM-filled)
- model_construct() for internal node creation (bypass Pydantic validation for deferred field population)
- graphlib.TopologicalSorter for dep chain resolution and cycle detection
- JSON structured output via Claude CLI --json-schema (replaced XML)
- transform_schema() from Anthropic SDK for both input and output schemas
- Field(description=...) for explicit LLM hints — docstrings are inert
- v1 make/decide kept as escape hatch for custom __call__ nodes

**Issues Resolved:**
- XML in CLI prompts causing agent mode / hangs — replaced with JSON
- CompiledGraph.run() latent **deps bug — removed in Phase 8
- incant dependency removed — replaced with bae's own resolver

**Issues Deferred:**
- No system prompt in any LLM backend
- PydanticAIBackend.choose_type uses free-text string + fuzzy matching
- Reference trace (json_structured_fill_reference.py) drifted from real backend
- --setting-sources "" correlation with broken structured output (root cause unknown)

**Technical Debt:**
- 5 E2E tests gated behind --run-e2e (requires live LLM)
- 15 litellm deprecation warnings (external dependency)

---
*Archived: 2026-02-08*
*For current project status, see .planning/PROJECT.md*
