# Phase 32.1.1: Subresource Packages + Shim Removal - Research

**Researched:** 2026-02-16
**Domain:** Python package restructuring, protocol relocation, shim cleanup
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Package convention (view/service/models)**
- Each package follows: view.py (protocol surface), service.py (implementation), models.py (entities -- only when needed), schemas.py (DTOs -- only when needed)
- view.py implements the protocol and calls service layer functions
- service.py has the underlying implementations
- Minimal per subresource: view.py + service.py minimum, add models.py/schemas.py only when actually needed
- Remove empty placeholder files (schemas.py, view.py with no real content) -- add back when needed

**Package layout**
- Subresource packages live flat under source/: spaces/source/deps/, spaces/source/config/, spaces/source/tests/, spaces/source/meta/
- No nested subresources/ directory
- source/service.py contains only SourceResourcespace class and its protocol methods -- subresource class definitions move to their own packages
- Subresource classes replaced by module-level functions in their packages -- view.py wraps them for protocol conformance

**Resourcespace protocol relocation**
- Resourcespace protocol (Resourcespace, ResourceRegistry, ResourceHandle, ResourceError, NavResult, etc.) moves from bae/repl/resource.py into spaces/view.py
- spaces/__init__.py re-exports protocol types from spaces/view.py
- resource.py is DELETED (not kept as shim)

**Shim removal -- complete**
- Remove ALL backward-compat shims in one pass
- Delete bae/repl/resource.py (protocol moves to spaces/view.py)
- Delete bae/repl/source.py (re-export shim)
- Audit ALL of bae/repl/ for any other re-export patterns and clean them up
- Update every callsite to use canonical paths

**Home resourcespace convention**
- home/ follows the same view.py/service.py convention as source/ and subresources
- Currently service.py-only -- split into view.py (protocol surface) + service.py (implementations)

**Structure enforcement via source operations**
- Source resourcespace operations (glob, grep, read) understand and enforce the view/service/models convention
- read() on a package groups files by role (protocol / implementation / data) rather than alphabetical listing
- write("my_new_subresource") creates a new subresource package from a tstring template with view.py + service.py scaffolded, plus auto-registers into parent
- Creation + registration + template expansion is in the service layer, abstracted by the view
- Meta subresource orientation message instructs the AI about the convention: "view must implement protocol and call service layer functions, service has underlying implementations"

**Import conventions**
- Canonical protocol import: `from bae.repl.spaces import Resourcespace, ResourceRegistry, ...`
- spaces/__init__.py exports protocol types only (not concrete implementations)
- Concrete implementations imported from their packages: `from bae.repl.spaces.source import SourceResourcespace`
- Subresource imports at package level: `from bae.repl.spaces.source.deps import X`
- Each __init__.py is selective (__all__) -- primarily exports the view (public API surface)
- Service layer is an implementation detail accessed only by the view within the same package
- Tests use public API only -- no importing from .service directly

### Claude's Discretion
- Meta subresource scope: whether it covers all of spaces/source/ or stays focused on service.py
- Exact tstring template content for new subresource creation
- How to handle the registration wrapper for module-level subresource functions

### Deferred Ideas (OUT OF SCOPE)
- Dynamic import/unimport when entering/leaving resourcespaces to prevent namespace growth -- future phase

</user_constraints>

## Summary

This phase restructures four subresource classes (DepsSubresource, ConfigSubresource, TestsSubresource, MetaSubresource) from a single 567-line service.py into their own packages under `spaces/source/`, relocates the Resourcespace protocol from `bae/repl/resource.py` into `spaces/view.py`, removes all backward-compat shims, and adds structure-aware behavior to source operations (role-grouped read, template-based write for new subresources).

The codebase is Python 3.14 (tstrings available via `string.templatelib.Template`). All 787 tests pass. The current import graph is clean: tests already import from `bae.repl.spaces`, while production code (`shell.py`, `tools.py`, `ai.py`, `source/service.py`, `source/models.py`) still imports from `bae.repl.resource`. The shims (`resource.py` re-exports nothing new, `source.py` re-exports from `spaces.source`) are pure indirection with no additional logic.

**Primary recommendation:** Execute in three phases: (1) protocol relocation + shim removal + callsite update, (2) subresource class extraction into own packages with view/service split, (3) structure enforcement in source operations (role-grouped read, template write).

## Architecture Patterns

### Current File Layout
```
bae/repl/
  resource.py              # 308 lines -- protocol DEFINITION site (to be moved + deleted)
  source.py                # 24 lines -- pure re-export shim (to be deleted)
  shell.py                 # imports ResourceRegistry, ResourceHandle from resource
  tools.py                 # imports ResourceError, ResourceRegistry, format_unsupported_error from resource
  ai.py                    # TYPE_CHECKING import of ResourceRegistry from resource; runtime import of ResourceHandle from spaces
  spaces/
    __init__.py            # re-exports from resource.py (to become re-exports from spaces/view.py)
    home/
      __init__.py          # re-exports from home/service.py
      service.py           # 93 lines -- filesystem tool implementations
      view.py              # 1 line -- placeholder "reserved for future use"
    source/
      __init__.py          # re-exports from service.py and models.py
      service.py           # 567 lines -- SourceResourcespace + 4 subresource classes
      models.py            # 242 lines -- path resolution, AST helpers
      view.py              # 1 line -- placeholder "reserved for future use"
      schemas.py           # 1 line -- placeholder "reserved for future use"
```

### Target File Layout
```
bae/repl/
  shell.py                 # imports from bae.repl.spaces (canonical)
  tools.py                 # imports from bae.repl.spaces (canonical)
  ai.py                    # imports from bae.repl.spaces (canonical)
  spaces/
    __init__.py            # re-exports protocol types from spaces/view.py (__all__)
    view.py                # Resourcespace, ResourceRegistry, ResourceHandle, ResourceError, NavResult, etc.
    home/
      __init__.py          # re-exports from home/view.py (__all__)
      view.py              # protocol surface for home tools
      service.py           # filesystem implementations (_exec_read, _exec_write, etc.)
    source/
      __init__.py          # re-exports SourceResourcespace from view.py (__all__)
      view.py              # SourceResourcespace class (protocol surface, calls service functions)
      service.py           # source-level service functions (glob, grep, read, write, edit, undo)
      models.py            # path resolution, AST helpers (unchanged)
      deps/
        __init__.py         # re-exports from view.py (__all__)
        view.py             # DepsSubresource view (protocol conformance wrapper)
        service.py          # deps implementation functions
      config/
        __init__.py
        view.py
        service.py
      tests/
        __init__.py
        view.py
        service.py
      meta/
        __init__.py
        view.py
        service.py
```

### Pattern: Subresource Class to Package Conversion

Each subresource class (e.g. DepsSubresource, 54 lines) becomes a package with view.py (protocol wrapper) + service.py (implementation functions).

**Before (class in service.py):**
```python
class DepsSubresource:
    name = "deps"
    description = "Project dependencies"
    def __init__(self, project_root: Path) -> None:
        self._root = project_root
    def read(self, target: str = "") -> str:
        data = self._read_pyproject()
        deps = data.get("project", {}).get("dependencies", [])
        ...
    def supported_tools(self) -> set[str]:
        return {"read", "write"}
    def tools(self) -> dict[str, Callable]:
        return {"read": self.read, "write": self.write}
    def children(self) -> dict[str, Resourcespace]:
        return {}
```

**After (package with module-level functions):**

`source/deps/service.py`:
```python
def read_pyproject(project_root: Path) -> dict:
    ...
def read(project_root: Path, target: str = "") -> str:
    ...
def write(project_root: Path, target: str, content: str = "") -> str:
    ...
```

`source/deps/view.py`:
```python
class DepsSubresource:
    name = "deps"
    description = "Project dependencies"
    def __init__(self, project_root: Path) -> None:
        self._root = project_root
    def read(self, target: str = "") -> str:
        return read_deps(self._root, target)
    # ... delegates to service functions
```

### Pattern: Registration Wrapper

The SourceResourcespace currently instantiates subresource classes directly:
```python
self._children = {
    "meta": MetaSubresource(project_root),
    "deps": DepsSubresource(project_root),
    "config": ConfigSubresource(project_root),
    "tests": TestsSubresource(project_root),
}
```

After the split, imports come from subresource packages:
```python
from bae.repl.spaces.source.deps import DepsSubresource
from bae.repl.spaces.source.config import ConfigSubresource
# etc.
```

**Recommendation for registration:** Keep the same pattern -- SourceResourcespace imports the view classes and instantiates them. The view classes wrap module-level service functions. No dynamic registration needed since the children are static.

### Pattern: Protocol Relocation

`bae/repl/resource.py` (308 lines) moves wholesale into `bae/repl/spaces/view.py`. The only internal import it has is `from bae.repl.views import _rich_to_ansi` -- this stays unchanged. Then `spaces/__init__.py` changes from importing `resource` to importing `spaces.view`.

### Anti-Patterns to Avoid
- **Circular imports:** `spaces/view.py` imports `_rich_to_ansi` from `bae.repl.views`. Subresource views import `ResourceError` and `Resourcespace` from `spaces/view.py`. The chain is one-directional: `views.py` -> `spaces/view.py` -> subresource views. No cycles.
- **Leaking service imports:** Tests must import from the package `__init__.py` or view, never directly from `.service`. Current tests access subresources via `src.children()["deps"]` which is correct and unaffected.
- **Oversized view.py:** The view should only delegate -- business logic belongs in service.py.

## Callsite Audit

### Production files importing from `bae.repl.resource` (to be updated)

| File | Current Import | New Import |
|------|---------------|------------|
| `bae/repl/shell.py:27` | `from bae.repl.resource import ResourceRegistry, ResourceHandle` | `from bae.repl.spaces import ResourceRegistry, ResourceHandle` |
| `bae/repl/tools.py:12` | `from bae.repl.resource import ResourceError, ResourceRegistry, format_unsupported_error` | `from bae.repl.spaces import ResourceError, ResourceRegistry, format_unsupported_error` |
| `bae/repl/ai.py:29` | `from bae.repl.resource import ResourceRegistry` (TYPE_CHECKING) | `from bae.repl.spaces import ResourceRegistry` |
| `bae/repl/spaces/source/service.py:19` | `from bae.repl.resource import ResourceError, Resourcespace` | `from bae.repl.spaces import ResourceError, Resourcespace` (or `from bae.repl.spaces.view import ...`) |
| `bae/repl/spaces/source/models.py:15` | `from bae.repl.resource import ResourceError` | `from bae.repl.spaces import ResourceError` (or `from bae.repl.spaces.view import ResourceError`) |
| `bae/repl/spaces/__init__.py:7` | `from bae.repl.resource import (...)` | `from bae.repl.spaces.view import (...)` |

### Files importing from `bae.repl.source` (shim to be deleted)
- **No production code** imports from `bae.repl.source` (confirmed by grep). The shim exists but has zero consumers.

### Test files (already canonical, no changes needed)
| File | Import |
|------|--------|
| `tests/test_resource.py` | `from bae.repl.spaces import ...` |
| `tests/test_source.py` | `from bae.repl.spaces import ResourceError, Resourcespace` |
| `tests/test_source.py` | `from bae.repl.spaces.source import SourceResourcespace` |
| `tests/test_tools_router.py` | `from bae.repl.spaces import ...` |

### Other imports to verify
| File | Import | Status |
|------|--------|--------|
| `bae/repl/ai.py:451` | `from bae.repl.spaces import ResourceHandle` | Already canonical |
| `bae/repl/shell.py:28` | `from bae.repl.spaces.source import SourceResourcespace` | Already canonical |
| `bae/repl/shell.py:233` | `from bae.repl.spaces.home import ...` | Already canonical |
| `bae/repl/tools.py:48` | `from bae.repl.spaces.home import ...` | Already canonical |
| `bae/repl/ai.py:38` | `from bae.repl.spaces.home.service import ...` | Update to `from bae.repl.spaces.home import ...` after home view.py is created |

## Subresource Size Analysis

Each subresource class needs splitting into view + service:

| Subresource | Lines | Methods | Complexity | Notes |
|-------------|-------|---------|------------|-------|
| DepsSubresource | 54 | 8 (enter, nav, read, write, supported_tools, tools, children, _read_pyproject) | LOW | subprocess call for write |
| ConfigSubresource | 52 | 6 (enter, nav, read, supported_tools, tools, children) | LOW | json import for read |
| TestsSubresource | 109 | 8 (enter, nav, read, grep, supported_tools, tools, children, _discover_test_modules) | MEDIUM | AST parsing, regex grep |
| MetaSubresource | 55 | 8 (enter, nav, read, edit, supported_tools, tools, children, _source_file) | MEDIUM | AST nav, calls models.py helpers |

Total: ~270 lines of subresource code to extract from service.py's 567 lines. After extraction, source/service.py drops to ~297 lines (SourceResourcespace only).

## Files to Delete

| File | Why |
|------|-----|
| `bae/repl/resource.py` (308 lines) | Protocol moves to `spaces/view.py` |
| `bae/repl/source.py` (24 lines) | Re-export shim with zero consumers |
| `bae/repl/spaces/source/view.py` (1 line) | Placeholder -- content replaces it |
| `bae/repl/spaces/source/schemas.py` (1 line) | Placeholder -- not needed |
| `bae/repl/spaces/home/view.py` (1 line) | Placeholder -- content replaces it |

## Files to Create

| File | Purpose | Size Estimate |
|------|---------|---------------|
| `bae/repl/spaces/view.py` | Protocol types (moved from resource.py) | ~308 lines |
| `bae/repl/spaces/source/deps/__init__.py` | Re-export DepsSubresource | ~5 lines |
| `bae/repl/spaces/source/deps/view.py` | DepsSubresource view class | ~30 lines |
| `bae/repl/spaces/source/deps/service.py` | Deps implementation functions | ~40 lines |
| `bae/repl/spaces/source/config/__init__.py` | Re-export | ~5 lines |
| `bae/repl/spaces/source/config/view.py` | ConfigSubresource view class | ~25 lines |
| `bae/repl/spaces/source/config/service.py` | Config implementation functions | ~35 lines |
| `bae/repl/spaces/source/tests/__init__.py` | Re-export | ~5 lines |
| `bae/repl/spaces/source/tests/view.py` | TestsSubresource view class | ~35 lines |
| `bae/repl/spaces/source/tests/service.py` | Tests implementation functions | ~80 lines |
| `bae/repl/spaces/source/meta/__init__.py` | Re-export | ~5 lines |
| `bae/repl/spaces/source/meta/view.py` | MetaSubresource view class | ~30 lines |
| `bae/repl/spaces/source/meta/service.py` | Meta implementation functions | ~35 lines |

## Discretion Recommendations

### Meta subresource scope
**Recommendation:** Expand meta to cover all of `spaces/source/` (the full source resourcespace package) rather than just service.py. After the refactor, the interesting code is spread across view.py, service.py, models.py, and the subresource packages. Meta's `_module_path` should point to `bae.repl.spaces.source` (the package), and `read()/edit()` should work across the entire package using existing module path resolution. This is a natural fit since the models.py helpers already support package-level operations.

### Tstring template for new subresource creation
**Recommendation:** Use `string.templatelib.Template` (confirmed available on Python 3.14.3). Template creates a package directory with `__init__.py`, `view.py`, and `service.py`. The template should be minimal:

```python
from string.templatelib import Template

def _subresource_template(name: str, description: str) -> dict[str, Template]:
    return {
        "__init__.py": t'"""Subresource: {description}."""\n\nfrom bae.repl.spaces.source.{name}.view import {name.title()}Subresource\n\n__all__ = ["{name.title()}Subresource"]\n',
        "view.py": t'"""View: {description}."""\n\nfrom bae.repl.spaces.source.{name} import service\n\n\nclass {name.title()}Subresource:\n    name = "{name}"\n    description = "{description}"\n    ...\n',
        "service.py": t'"""{description} service implementations."""\n',
    }
```

Note: tstring interpolation uses `{expr}` syntax. The template returns a dict of filename -> Template. The service layer processes Templates into strings via `str()` or a custom renderer.

### Registration wrapper for module-level subresource functions
**Recommendation:** Keep the view class pattern (view.py has a class that implements the Resourcespace protocol). The class constructor takes `project_root` and delegates method calls to module-level service functions, passing `project_root` as the first argument. This is the simplest approach -- no metaclass, no decorator, no dynamic registration. The SourceResourcespace imports view classes from subresource packages and instantiates them, same as today but from different import paths.

## Common Pitfalls

### Pitfall 1: Circular Import from spaces/view.py
**What goes wrong:** `spaces/view.py` imports `_rich_to_ansi` from `bae.repl.views`. If `bae.repl.views` ever imports from `bae.repl.spaces`, you get a circular import.
**How to avoid:** Verify `bae.repl.views` has no imports from `bae.repl.spaces` or `bae.repl.resource`. Currently it does not -- keep it that way.

### Pitfall 2: Subresource models.py imports
**What goes wrong:** `source/models.py` currently imports `ResourceError` from `bae.repl.resource`. After the move, it must import from `bae.repl.spaces.view` (or `bae.repl.spaces`). But `spaces/__init__.py` imports from `spaces/view.py`, and `spaces/view.py` has no dependency on `models.py`, so no cycle.
**How to avoid:** models.py can safely import from either `bae.repl.spaces` or `bae.repl.spaces.view`. Use `bae.repl.spaces.view` to avoid going through __init__.py re-export.

### Pitfall 3: Test assertions referencing old module paths
**What goes wrong:** Tests like `test_meta_read_shows_summary` assert `"bae.repl.spaces.source.service"` appears in meta's output. After refactoring, if meta's scope expands, this assertion may break.
**How to avoid:** Update meta's `_module_path` and corresponding test assertions together.

### Pitfall 4: `__all__` missing from __init__.py
**What goes wrong:** Without `__all__`, `from package import *` grabs everything. With selective `__all__`, only the public API is exported.
**How to avoid:** Every new `__init__.py` must define `__all__`.

### Pitfall 5: Home view.py needs to wrap service functions
**What goes wrong:** Currently `home/__init__.py` re-exports raw service functions (`_exec_read`, etc.) with underscore prefixes. The convention says view.py should provide the public API.
**How to avoid:** Create `home/view.py` that exposes a proper `HomeResourcespace` class or public-facing functions. Update `home/__init__.py` to export from view.py.

### Pitfall 6: Tests subresource name collision with pytest
**What goes wrong:** A package named `tests/` under `source/` won't collide with the project's `tests/` directory because it's at `bae/repl/spaces/source/tests/`, not at the project root. No issue expected.
**How to avoid:** No action needed, but be aware the naming could cause momentary confusion during code review.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Template expansion | Custom string formatting | `string.templatelib.Template` (tstrings) | Native Python 3.14 feature, type-safe interpolation |
| Module path resolution | New path utilities | Existing `_module_to_path`, `_path_to_module` in models.py | Already battle-tested, handles packages and modules |
| AST operations | New AST helpers | Existing `_read_symbol`, `_replace_symbol`, `_find_symbol` in models.py | Already handles nested symbols, indentation, validation |

## Open Questions

1. **Home resourcespace as a full Resourcespace?**
   - What we know: Home currently has no Resourcespace class -- just service functions. The convention says split into view.py + service.py.
   - What's unclear: Should home/view.py define a `HomeResourcespace` class implementing the Resourcespace protocol, or just export public function wrappers?
   - Recommendation: Create a minimal `HomeResourcespace` class for consistency, even if the registry doesn't use it yet (home tools are injected via `_home_tools` dict, not via a Resourcespace). This prepares for Phase 36 where home becomes a proper resource.

2. **Role-grouped read() implementation scope**
   - What we know: read() on a package should group files by role (protocol / implementation / data).
   - What's unclear: Should this modify `_module_summary` in models.py or be a new function? Does it apply only to packages following the view/service convention, or all packages?
   - Recommendation: Add a role-detection function in models.py (check filename against known roles: view.py=protocol, service.py=implementation, models.py=data, schemas.py=data). Apply it in `_module_summary` when the package follows the convention (has view.py). Fall back to current alphabetical listing for packages that don't follow the convention.

## Sources

### Primary (HIGH confidence)
- Direct codebase analysis of all files in `bae/repl/` and `bae/repl/spaces/`
- `uv run pytest` -- 787 passed, 5 skipped
- `uv run python --version` -- Python 3.14.3
- `uv run python -c "t = t'hello {1+1}'; print(type(t))"` -- confirmed `string.templatelib.Template`
- Complete grep audit of all import paths across production and test code

## Metadata

**Confidence breakdown:**
- Callsite audit: HIGH -- exhaustive grep of all imports, every file read
- Architecture patterns: HIGH -- direct analysis of existing code structure
- Subresource extraction: HIGH -- classes are self-contained, clean boundaries
- Protocol relocation: HIGH -- single file move, no circular dependency risk
- Tstring templates: MEDIUM -- syntax confirmed but template design is greenfield
- Structure enforcement (role-grouped read): MEDIUM -- concept clear, implementation details TBD

**Research date:** 2026-02-16
**Valid until:** 2026-03-16 (internal refactoring, no external dependencies)
