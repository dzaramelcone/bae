# Phase 32.1.1: Subresource Packages + Shim Removal - Context

**Gathered:** 2026-02-16
**Status:** Ready for planning

<domain>
## Phase Boundary

Break subresources (deps, config, tests, meta) into their own packages under spaces/source/, remove ALL backward-compat shims from Phase 32.1, move the Resourcespace protocol into spaces/, update all callsites, and enforce package structure in source resourcespace operations. Also restructure home/ to follow the same convention.

</domain>

<decisions>
## Implementation Decisions

### Package convention (view/service/models)
- Each package follows: view.py (protocol surface), service.py (implementation), models.py (entities — only when needed), schemas.py (DTOs — only when needed)
- view.py implements the protocol and calls service layer functions
- service.py has the underlying implementations
- Minimal per subresource: view.py + service.py minimum, add models.py/schemas.py only when actually needed
- Remove empty placeholder files (schemas.py, view.py with no real content) — add back when needed

### Package layout
- Subresource packages live flat under source/: spaces/source/deps/, spaces/source/config/, spaces/source/tests/, spaces/source/meta/
- No nested subresources/ directory
- source/service.py contains only SourceResourcespace class and its protocol methods — subresource class definitions move to their own packages
- Subresource classes replaced by module-level functions in their packages — view.py wraps them for protocol conformance

### Resourcespace protocol relocation
- Resourcespace protocol (Resourcespace, ResourceRegistry, ResourceHandle, ResourceError, NavResult, etc.) moves from bae/repl/resource.py into spaces/view.py
- spaces/__init__.py re-exports protocol types from spaces/view.py
- resource.py is DELETED (not kept as shim)

### Shim removal — complete
- Remove ALL backward-compat shims in one pass
- Delete bae/repl/resource.py (protocol moves to spaces/view.py)
- Delete bae/repl/source.py (re-export shim)
- Audit ALL of bae/repl/ for any other re-export patterns and clean them up
- Update every callsite to use canonical paths

### Home resourcespace convention
- home/ follows the same view.py/service.py convention as source/ and subresources
- Currently service.py-only — split into view.py (protocol surface) + service.py (implementations)

### Structure enforcement via source operations
- Source resourcespace operations (glob, grep, read) understand and enforce the view/service/models convention
- read() on a package groups files by role (protocol / implementation / data) rather than alphabetical listing
- write("my_new_subresource") creates a new subresource package from a tstring template with view.py + service.py scaffolded, plus auto-registers into parent
- Creation + registration + template expansion is in the service layer, abstracted by the view
- Meta subresource orientation message instructs the AI about the convention: "view must implement protocol and call service layer functions, service has underlying implementations"

### Import conventions
- Canonical protocol import: `from bae.repl.spaces import Resourcespace, ResourceRegistry, ...`
- spaces/__init__.py exports protocol types only (not concrete implementations)
- Concrete implementations imported from their packages: `from bae.repl.spaces.source import SourceResourcespace`
- Subresource imports at package level: `from bae.repl.spaces.source.deps import X`
- Each __init__.py is selective (__all__) — primarily exports the view (public API surface)
- Service layer is an implementation detail accessed only by the view within the same package
- Tests use public API only — no importing from .service directly

### Claude's Discretion
- Meta subresource scope: whether it covers all of spaces/source/ or stays focused on service.py
- Exact tstring template content for new subresource creation
- How to handle the registration wrapper for module-level subresource functions

</decisions>

<specifics>
## Specific Ideas

- "view must implement protocol and call service layer functions, service has underlying implementations" — this is the guidance message for the AI when creating subresources
- Template-based creation: write("my_new_subresource") uses a tstring to scaffold the package, advanced API layers can edit the tstring but shouldn't need to
- Role-grouped output: read() on packages groups by role for easy pattern matching

</specifics>

<deferred>
## Deferred Ideas

- Dynamic import/unimport when entering/leaving resourcespaces to prevent namespace growth — future phase

</deferred>

---

*Phase: 32.1.1-subresource-packages-shim-removal*
*Context gathered: 2026-02-16*
