---
phase: 32.2-userview-tool-call-stripping
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/spaces/view.py
  - tests/test_resource.py
autonomous: true

must_haves:
  truths:
    - "Resource entry functions table shows XML tag syntax with full typed signatures"
    - "Signatures include all parameters with type hints"
    - "Docstring first line pulled directly from the callable"
    - "Body-content tools show opening and closing tag format"
  artifacts:
    - path: "bae/repl/spaces/view.py"
      provides: "Functions table with typed XML tool signatures"
      contains: "_tool_signature"
  key_links:
    - from: "bae/repl/spaces/view.py"
      to: "bae/repl/spaces/source/service.py"
      via: "space.tools() returning bound methods with type annotations"
      pattern: "inspect.signature"
---

<objective>
Replace the generic functions table on resource entry with XML tag syntax showing typed signatures and docstrings.

Purpose: Show the AI exactly what tool call syntax to use when entering a resource, with parameter names and types visible inline.

Output: Updated `_entry_display` in `ResourceRegistry` with `inspect.signature`-based signature extraction.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32.2-userview-tool-call-stripping/32.2-RESEARCH.md
@bae/repl/spaces/view.py
@bae/repl/spaces/source/service.py
@tests/test_resource.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add typed XML signatures to resource entry functions table</name>
  <files>bae/repl/spaces/view.py, tests/test_resource.py</files>
  <action>
Add `import inspect` at the top of `bae/repl/spaces/view.py`.

**1. Add `_tool_signature` helper function.**
This builds the XML tag format from a tool name and its bound method:

```python
def _tool_signature(name: str, method: Callable) -> str:
    """Build XML tag signature like <Read:target:str> from method."""
    tag = name.title()  # read -> Read, glob -> Glob, grep -> Grep
    try:
        sig = inspect.signature(method)
    except (ValueError, TypeError):
        return f"<{tag}>"

    params = []
    for pname, param in sig.parameters.items():
        if pname == "self":
            continue
        ptype = param.annotation
        if ptype is inspect.Parameter.empty:
            params.append(pname)
        elif isinstance(ptype, type):
            params.append(f"{pname}:{ptype.__name__}")
        else:
            params.append(f"{pname}:{ptype}")

    if not params:
        return f"<{tag}>"
    return f"<{tag}:{', '.join(params)}>"
```

Special handling for `write` and `edit` — if the method has a `content` or `new_source` parameter, show closing tag format for body content:
- For `write`: if has `content` param, render as `<Write:target:str>content</Write>`
- For `edit`: render all params inline (edit uses named params, not body content in source resourcespace)

Determine this by checking the parameter names. If `name == "write"` and `"content"` is in the parameter names, format the last param as body content between open/close tags. Otherwise show all inline.

**2. Add `_tool_docstring` helper function.**
```python
def _tool_docstring(method: Callable) -> str:
    """First line of method docstring, or empty string."""
    doc = getattr(method, "__doc__", None) or ""
    return doc.split("\n")[0].strip()
```

**3. Replace the functions table in `_entry_display`.**
Replace lines 244-250 (the current table generation):

```python
# Functions table
tools_map = space.tools()
tool_names = sorted(space.supported_tools())
if tool_names:
    lines.append("")
    lines.append("| Tool | Signature | Description |")
    lines.append("|------|-----------|-------------|")
    for tool in tool_names:
        method = tools_map.get(tool)
        if method:
            sig = _tool_signature(tool, method)
            doc = _tool_docstring(method)
            lines.append(f"| {tool} | {sig} | {doc} |")
        else:
            lines.append(f"| {tool} | <{tool.title()}> | |")
```

**4. Update tests in `tests/test_resource.py`.**
Update any assertions checking the functions table format. The current tests check for `| read | read() | read result |` style — update to match the new `| read | <Read:...> | docstring |` format. Look for tests in the entry display section and the `TestToolInjection` class.

Note: The functions table is generated from `space.tools()` which returns bound methods. For the SourceResourcespace, these are `self.read`, `self.write`, etc. with proper type annotations. For `_StubSubresource` or test fixtures, methods may lack annotations — `_tool_signature` handles this gracefully by omitting type hints when annotation is `Parameter.empty`.
  </action>
  <verify>`uv run pytest tests/test_resource.py -x -q`</verify>
  <done>Functions table shows `| read | <Read:target:str> | Read package listing... |` format with typed params and docstrings</done>
</task>

</tasks>

<verification>
```bash
uv run pytest tests/test_resource.py -x -q
uv run pytest tests/ -x -q --ignore=tests/test_integration.py
```
</verification>

<success_criteria>
- Functions table header is `| Tool | Signature | Description |`
- Each row shows XML tag syntax with typed parameters (e.g., `<Read:target:str>`)
- Write tool shows body-content format when applicable
- Docstring first line populates Description column
- Missing annotations handled gracefully (no crash)
- All resource-related tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/32.2-userview-tool-call-stripping/32.2-02-SUMMARY.md`
</output>
