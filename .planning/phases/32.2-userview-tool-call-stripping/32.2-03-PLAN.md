---
phase: 32.2-userview-tool-call-stripping
plan: 03
type: execute
wave: 2
depends_on: ["32.2-01"]
files_modified:
  - bae/repl/tools.py
  - tests/test_tools_router.py
autonomous: true

must_haves:
  truths:
    - "Tool parameters are validated via pydantic before execution"
    - "Validation errors return clear messages guiding the AI to correct its call"
    - "Valid calls proceed to execution normally"
    - "Home dispatch (no current resource) still works without validation"
  artifacts:
    - path: "bae/repl/tools.py"
      provides: "Pydantic parameter validation on tool dispatch"
      contains: "_validate_tool_params"
  key_links:
    - from: "bae/repl/tools.py"
      to: "bae/repl/spaces/source/service.py"
      via: "dispatch calls method with validated params"
      pattern: "validate.*param|ValidationError"
---

<objective>
Add pydantic parameter validation to ToolRouter dispatch before calling resource methods.

Purpose: When the AI sends malformed tool call parameters, return clear error messages guiding it to correct the call, rather than cryptic Python TypeErrors.

Output: Validation layer in `ToolRouter.dispatch()` using pydantic `TypeAdapter` or `create_model`.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32.2-userview-tool-call-stripping/32.2-RESEARCH.md
@.planning/phases/32.2-userview-tool-call-stripping/32.2-01-SUMMARY.md
@bae/repl/tools.py
@bae/repl/spaces/view.py
@tests/test_tools_router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pydantic validation to ToolRouter.dispatch</name>
  <files>bae/repl/tools.py, tests/test_tools_router.py</files>
  <action>
Add `import inspect` and `from pydantic import create_model, ValidationError` at the top of `bae/repl/tools.py`. Follow the existing `create_model` pattern in `bae/lm.py`.

**1. Add `_build_validator` function.**
Build a pydantic model from a method's `inspect.signature`, then use it to validate kwargs before calling the method. Cache validators per method to avoid repeated introspection.

```python
_validator_cache: dict[int, type] = {}

def _build_validator(method) -> type | None:
    """Build a pydantic model from method signature for parameter validation."""
    mid = id(method)
    if mid in _validator_cache:
        return _validator_cache[mid]

    try:
        sig = inspect.signature(method)
    except (ValueError, TypeError):
        _validator_cache[mid] = None
        return None

    fields = {}
    for pname, param in sig.parameters.items():
        if pname == "self":
            continue
        ann = param.annotation if param.annotation is not inspect.Parameter.empty else str
        if param.default is not inspect.Parameter.empty:
            fields[pname] = (ann, param.default)
        else:
            fields[pname] = (ann, ...)

    if not fields:
        _validator_cache[mid] = None
        return None

    model = create_model(f"{method.__name__}_Params", **fields)
    _validator_cache[mid] = model
    return model
```

This builds a real pydantic model with typed fields matching the method's parameter annotations and defaults. For example, `read(target: str)` becomes `create_model("read_Params", target=(str, ...))`.

**2. Add `_validate_tool_params` function.**
Validate parameters against the pydantic model before execution:

```python
def _validate_tool_params(tool: str, method, arg: str, **kwargs) -> dict | str:
    """Validate tool params via pydantic. Returns validated dict or error string."""
    validator = _build_validator(method)
    if validator is None:
        return {"arg": arg, **kwargs}  # No validation possible, pass through

    # Build the param dict from positional arg + kwargs
    sig = inspect.signature(method)
    param_names = [p for p in sig.parameters if p != "self"]
    params = {}
    if param_names:
        params[param_names[0]] = arg
    params.update(kwargs)

    try:
        validated = validator(**params)
        return validated.model_dump()
    except ValidationError as e:
        return _format_validation_error(tool, method, e)
```

**3. Add `_format_validation_error` function.**
Format pydantic ValidationError into a helpful message with signature hint:

```python
def _format_validation_error(tool: str, method, error: ValidationError) -> str:
    """Format pydantic ValidationError into helpful error with method signature."""
    try:
        sig = inspect.signature(method)
        params = []
        for pname, param in sig.parameters.items():
            if pname == "self":
                continue
            ann = param.annotation
            if ann is not inspect.Parameter.empty:
                tname = ann.__name__ if isinstance(ann, type) else str(ann)
                params.append(f"{pname}: {tname}")
            else:
                params.append(pname)
        sig_str = f"{tool}({', '.join(params)})"
    except Exception:
        sig_str = f"{tool}(...)"

    doc = (getattr(method, "__doc__", None) or "").split("\n")[0].strip()

    # Extract clean error messages from pydantic ValidationError
    error_msgs = "; ".join(e["msg"] for e in error.errors())

    lines = [f"Tool '{tool}' parameter error: {error_msgs}"]
    lines.append(f"Usage: {sig_str}")
    if doc:
        lines.append(f"  {doc}")
    return "\n".join(lines)
```

**4. Update `ToolRouter.dispatch()` to validate before calling.**
Insert pydantic validation before the method call:

```python
def dispatch(self, tool: str, arg: str, **kwargs) -> str:
    current = self._registry.current
    if current is None:
        return self._home_dispatch(tool, arg, **kwargs)

    if tool not in current.supported_tools():
        return format_unsupported_error(current, tool)

    method = getattr(current, tool)

    # Pydantic validation before execution
    validated = _validate_tool_params(tool, method, arg, **kwargs)
    if isinstance(validated, str):
        return validated  # Validation error message

    try:
        # Call with validated params
        param_names = [p for p in inspect.signature(method).parameters if p != "self"]
        if param_names:
            first_key = param_names[0]
            first_val = validated.pop(first_key)
            result = method(first_val, **validated)
        else:
            result = method()
    except ResourceError as e:
        return str(e)

    return _prune(result)
```

**5. Update tests in `tests/test_tools_router.py`.**
Add tests:
- Test that calling a tool with wrong param types triggers pydantic ValidationError and returns formatted error with signature hint
- Test that calling a tool with missing required params returns pydantic error mentioning "required"
- Test that calling a tool with correct params still works normally (pydantic validates and passes through)
- Test that the error message includes the tool's docstring
- Test that home dispatch is unaffected (no pydantic validation layer)
- Test `_build_validator` creates a pydantic model with correct field types from method signature
  </action>
  <verify>`uv run pytest tests/test_tools_router.py -x -q`</verify>
  <done>ToolRouter.dispatch() validates params via pydantic create_model before execution; ValidationError returns helpful error with method signature and docstring; valid calls pass through normally</done>
</task>

</tasks>

<verification>
```bash
uv run pytest tests/test_tools_router.py -x -q
uv run pytest tests/ -x -q --ignore=tests/test_integration.py
```
</verification>

<success_criteria>
- Bad tool parameters trigger pydantic ValidationError and return clear error with signature hint and docstring
- Pydantic model built from method signature via create_model (matching existing pattern in bae/lm.py)
- Correct tool calls validated by pydantic then execute normally
- ResourceError still caught and returned as-is
- Home dispatch unaffected (no pydantic validation)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/32.2-userview-tool-call-stripping/32.2-03-SUMMARY.md`
</output>
