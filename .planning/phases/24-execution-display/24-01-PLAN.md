---
phase: 24-execution-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/views.py
  - tests/repl/test_views.py
  - bae/repl/shell.py
autonomous: true

must_haves:
  truths:
    - "AI-executed code renders in a Rich Panel with syntax highlighting and a descriptive title"
    - "Execution output renders in a separate section below the code within a grouped panel"
    - "Code and output appear as a single visual unit with no interleaved channel lines"
    - "AI-initiated code execution does NOT echo as a redundant [py] prefix line"
    - "User-typed Python code continues to render as standard [py] prefix lines"
  artifacts:
    - path: "bae/repl/views.py"
      provides: "UserView concrete formatter with buffered exec grouping"
      exports: ["UserView"]
    - path: "tests/repl/test_views.py"
      provides: "Tests for UserView buffering, panel rendering, fallback, edge cases"
      min_lines: 60
    - path: "bae/repl/shell.py"
      provides: "UserView wired to py channel _formatter"
      contains: "UserView"
  key_links:
    - from: "bae/repl/views.py"
      to: "bae/repl/channels.py"
      via: "UserView satisfies ViewFormatter protocol"
      pattern: "def render.*channel_name.*color.*content.*metadata"
    - from: "bae/repl/shell.py"
      to: "bae/repl/views.py"
      via: "import and assign to py channel"
      pattern: "router\\.py\\._formatter.*=.*UserView"
    - from: "bae/repl/views.py"
      to: "prompt_toolkit"
      via: "print_formatted_text(ANSI(...)) for terminal output"
      pattern: "print_formatted_text.*ANSI"
---

<objective>
UserView formatter that renders AI code execution as framed Rich Panels with syntax highlighting, buffered code+output grouping, and deduplication -- wired to the py channel.

Purpose: Transform AI-executed code from flat [py] prefix lines into visually distinct, grouped panels that clearly separate AI execution from user-typed code.
Output: `bae/repl/views.py` (UserView class), `tests/repl/test_views.py`, updated `bae/repl/shell.py`
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-execution-display/24-RESEARCH.md
@.planning/phases/23-view-framework/23-01-SUMMARY.md
@bae/repl/channels.py
@bae/repl/ai.py
@bae/repl/shell.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: UserView formatter with buffered exec grouping and tests</name>
  <files>bae/repl/views.py, tests/repl/test_views.py</files>
  <action>
Create `bae/repl/views.py` with:

1. **`_rich_to_ansi(renderable, width=None)` helper** -- Render any Rich renderable to ANSI string. Generalized from the existing `render_markdown()` pattern in `channels.py:30-40`. Call `os.get_terminal_size().columns` per-render (not cached). Fallback width 80 on OSError. Use `Console(file=StringIO(), width=width, force_terminal=True)`.

2. **`UserView` class** satisfying the `ViewFormatter` protocol (structural typing, no inheritance needed). Fields: `_pending_code: str | None = None`, `_pending_meta: dict | None = None`.

   `render(self, channel_name, color, content, *, metadata=None)`:
   - Dispatch on `metadata.get("type", "")`:
     - `"ai_exec"` -> buffer the code. If `_pending_code is not None` (stale from interrupted exec), flush the stale code as a standalone code panel first, then buffer the new code. Return without printing.
     - `"ai_exec_result"` AND `_pending_code is not None` -> call `_render_grouped_panel` with buffered code + output. Clear buffer. Return.
     - Everything else (including `"ai_exec_result"` with no pending code) -> `_render_prefixed` fallback.

   `_render_grouped_panel(self, code, output, meta)`:
   - Build Rich renderable tree: `Panel(Group(Syntax(code, "python", theme="monokai"), Rule(style="dim"), Text(output)))`.
   - If output is empty or `"(no output)"`, omit the Rule and Text -- render code-only panel.
   - Panel title: `f"[bold cyan]{title}[/]"` where title is `f"ai:{meta.get('label', '')}"` if label exists, else `"exec"`.
   - Panel border: `border_style="dim"`, `box=box.ROUNDED`, `padding=(0, 1)`.
   - Render via `_rich_to_ansi(panel)` then `print_formatted_text(ANSI(ansi_str))`.

   `_render_code_panel(self, code, meta)`:
   - Same as grouped panel but code only (no Rule, no output Text). Used for flushing stale buffer.

   `_render_prefixed(self, channel_name, color, content, meta)`:
   - Reproduce the exact fallback behavior from `channels.py:118-125` (the non-markdown branch of `Channel._display`).
   - Compose label: `f"[{channel_name}]"` or `f"[{channel_name}:{meta['label']}]"` if metadata has "label".
   - For each line in `content.splitlines()`: `print_formatted_text(FormattedText([(f"{color} bold", label), ("", " "), ("", line)]))`.

Imports: `os`, `StringIO` from `io`, `Console` from `rich.console`, `Group` from `rich.console`, `Panel` from `rich.panel`, `Syntax` from `rich.syntax`, `Text` from `rich.text`, `Rule` from `rich.rule`, `box` from `rich`, `print_formatted_text` from `prompt_toolkit`, `ANSI` and `FormattedText` from `prompt_toolkit.formatted_text`.

Create `tests/repl/test_views.py` with tests (all patching `bae.repl.views.print_formatted_text`):

1. `test_user_view_buffers_ai_exec` -- render with `metadata={"type": "ai_exec"}` does NOT call print_formatted_text. Verify `view._pending_code` is set.
2. `test_user_view_flushes_grouped_panel` -- render ai_exec then ai_exec_result. First call: no print. Second call: exactly one print_formatted_text call with an ANSI instance.
3. `test_user_view_fallback_for_stdout` -- render with `metadata={"type": "stdout"}` calls print_formatted_text with FormattedText containing `[py]` prefix and content.
4. `test_user_view_fallback_no_metadata` -- render with `metadata=None` calls print_formatted_text with standard prefix.
5. `test_user_view_stale_buffer_flushed` -- render ai_exec twice without ai_exec_result between. First ai_exec buffered, second ai_exec flushes the first as a standalone panel and buffers the second. Verify print_formatted_text called once (for the stale flush).
6. `test_user_view_no_output_skips_output_section` -- render ai_exec then ai_exec_result with `"(no output)"`. The ANSI output should NOT contain "no output" text (output section omitted).
7. `test_user_view_label_in_panel_title` -- render ai_exec with `metadata={"type": "ai_exec", "label": "2"}` then ai_exec_result. The rendered ANSI should contain "ai:2" in the output.
8. `test_user_view_satisfies_protocol` -- `isinstance(UserView(), ViewFormatter)` is True.
9. `test_rich_to_ansi_returns_string` -- `_rich_to_ansi(Text("hello"))` returns a string containing "hello".
10. `test_rich_to_ansi_uses_terminal_width` -- Patch `os.get_terminal_size` to return 40 columns. Verify the Console is created with width=40 (check output width behavior).

All tests must produce pristine output. If any test intentionally triggers an error path, capture and validate the error output.
  </action>
  <verify>
Run `python -m pytest tests/repl/test_views.py -v` -- all tests pass with zero warnings.
Run `python -c "from bae.repl.views import UserView; from bae.repl.channels import ViewFormatter; assert isinstance(UserView(), ViewFormatter)"` -- exits 0.
  </verify>
  <done>
UserView class exists in bae/repl/views.py, satisfies ViewFormatter protocol, buffers ai_exec, flushes grouped panels on ai_exec_result, falls back to prefix display for all other types. 10 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire UserView to py channel in CortexShell</name>
  <files>bae/repl/shell.py</files>
  <action>
In `bae/repl/shell.py`:

1. Add import at top of file (with other bae.repl imports, after line 31): `from bae.repl.views import UserView`

2. In `CortexShell.__init__`, after the channel registration loop (after line 222 where `self.namespace["channels"] = self.router`), add:
   ```
   self.router.py._formatter = UserView()
   ```

That is the entire change. Only the `py` channel gets UserView. The `ai` channel continues with its markdown rendering path. All other channels continue with default display.

Do NOT set formatter on any other channel. Do NOT modify ai.py or channels.py. The eval loop already writes the correct metadata types -- this wiring is all that's needed.
  </action>
  <verify>
Run `python -m pytest tests/ -v --tb=short` -- full test suite passes. No regressions.
Run `python -c "from bae.repl.shell import CortexShell; s = CortexShell(); assert s.router.py._formatter is not None; print('wired')"` -- prints "wired".
  </verify>
  <done>
CortexShell creates a UserView instance and assigns it to py channel's _formatter. Full test suite passes. AI code execution flows through UserView for panel rendering; user-typed code flows through UserView's fallback prefix display.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/repl/test_views.py -v` -- all UserView tests pass
2. `python -m pytest tests/ -v --tb=short` -- full suite passes, no regressions
3. `python -c "from bae.repl.views import UserView; from bae.repl.channels import ViewFormatter; assert isinstance(UserView(), ViewFormatter)"` -- protocol satisfied
4. `python -c "from bae.repl.shell import CortexShell; s = CortexShell(); assert s.router.py._formatter is not None"` -- wired
</verification>

<success_criteria>
- UserView renders ai_exec code in a Rich Panel with Syntax highlighting and a title containing the session label
- UserView renders ai_exec_result output grouped below the code panel as a single visual unit
- ai_exec writes are buffered (not printed as [py] prefix lines), satisfying DISP-04 deduplication
- Non-AI py channel writes (stdout, expr_result, error, warning, tool_translated, tool_result) render as standard [py] prefix lines
- CortexShell.router.py._formatter is a UserView instance
- All tests pass with pristine output
</success_criteria>

<output>
After completion, create `.planning/phases/24-execution-display/24-01-SUMMARY.md`
</output>
