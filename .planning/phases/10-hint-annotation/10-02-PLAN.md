---
phase: 10-hint-annotation
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/lm.py
  - examples/ootd.py
  - tests/test_fill_helpers.py
autonomous: true

must_haves:
  truths:
    - "_build_plain_model() preserves Field(description=...) in the dynamic model"
    - "transform_schema() output from the plain model includes description strings"
    - "examples/ootd.py RecommendOOTD fields use Field(description=...) where helpful"
    - "Plain field descriptions flow through _build_plain_model into transform_schema output for constrained decoding"
  artifacts:
    - path: "bae/lm.py"
      provides: "_build_plain_model preserving FieldInfo with descriptions"
      contains: "FieldInfo"
    - path: "examples/ootd.py"
      provides: "RecommendOOTD with Field(description=...) annotations"
      contains: "Field(description="
    - path: "tests/test_fill_helpers.py"
      provides: "Tests for description preservation in plain model"
  key_links:
    - from: "bae/lm.py (_build_plain_model)"
      to: "anthropic.transform_schema"
      via: "plain model with FieldInfo -> transform_schema -> JSON schema with descriptions"
      pattern: "transform_schema.*plain_model"
    - from: "examples/ootd.py"
      to: "bae/lm.py"
      via: "RecommendOOTD fields with descriptions flow through _build_plain_model into LLM output schema"
      pattern: "Field\\(description="
---

<objective>
Fix _build_plain_model() to preserve Field(description=...) in dynamic models so descriptions flow into JSON schemas for constrained decoding. Update ootd.py to demonstrate per-field context.

Purpose: Field(description=...) is the explicit, opt-in mechanism for per-field LLM context. Currently _build_plain_model() loses descriptions when creating dynamic models because it passes `(type, default)` tuples instead of preserving the original FieldInfo. This fix makes descriptions survive into the output schema that the LLM sees during constrained decoding.

Output: Updated bae/lm.py with FieldInfo-preserving _build_plain_model, updated examples/ootd.py with Field descriptions, new tests in test_fill_helpers.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bae/lm.py
@examples/ootd.py
@tests/test_fill_helpers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - _build_plain_model preserves Field descriptions</name>
  <files>bae/lm.py, tests/test_fill_helpers.py</files>
  <action>
RED phase: Add a new test class TestPlainModelDescriptions in tests/test_fill_helpers.py.

First, create a test node with Field descriptions:
```python
from pydantic import Field

class DescribedNode(Node):
    weather: WeatherDep
    top: str = Field(description="a specific garment for the upper body")
    bottom: str = Field(description="a specific garment for the lower body")
    accessories: list[str] = Field(default_factory=list)  # no description

    def __call__(self) -> None: ...
```

Test cases:
1. `test_plain_model_preserves_field_description`: Build plain model from DescribedNode. Check that `PlainModel.model_fields["top"].description == "a specific garment for the upper body"` and same for "bottom".

2. `test_plain_model_description_in_json_schema`: Build plain model from DescribedNode, call `transform_schema(PlainModel)`. Assert the JSON schema's `properties.top.description` equals "a specific garment for the upper body".

3. `test_plain_model_no_description_field_works`: The "accessories" field has no description — it should still work in the plain model. Assert `PlainModel.model_fields["accessories"].description is None` (or not set).

4. `test_plain_model_default_preserved_with_description`: The "accessories" field has `default_factory=list`. Assert the plain model preserves this default — `PlainModel.model_fields["accessories"].default_factory` is `list`.

Run tests — tests 1 and 2 MUST fail (current code loses descriptions).
Commit: `test(10-02): add failing tests for Field description preservation in _build_plain_model`

GREEN phase: Fix `_build_plain_model` in bae/lm.py (lines 43-67).

The current code passes `(type, default)` tuples to `create_model()`, which creates fresh FieldInfo objects — losing the original description, json_schema_extra, and other metadata.

The fix: pass `(type, FieldInfo)` tuples instead. Pydantic's `create_model()` accepts `(type, FieldInfo)` tuples where FieldInfo is the full field specification.

Replace the body of _build_plain_model:
```python
def _build_plain_model(target_cls: type) -> type[BaseModel]:
    """Create a dynamic Pydantic model with only plain fields from target.

    Used to constrain LLM output to only the fields it should generate
    (not dep/recall fields). Preserves Field(description=...) metadata
    so descriptions flow into JSON schemas for constrained decoding.
    """
    fields = classify_fields(target_cls)
    hints = get_type_hints(target_cls, include_extras=True)

    # Collect plain fields with their types and FieldInfo
    plain_fields: dict[str, Any] = {}
    for name in target_cls.model_fields:
        if fields.get(name, "plain") == "plain":
            base_type = _get_base_type(hints.get(name))
            field_info = target_cls.model_fields[name]
            plain_fields[name] = (base_type, field_info)

    return create_model(
        f"{target_cls.__name__}Plain",
        **plain_fields,
    )
```

The key change: `plain_fields[name] = (base_type, field_info)` instead of `(base_type, field_info.default)` or `(base_type, ...)`. By passing the original FieldInfo object, Pydantic preserves description, default, default_factory, json_schema_extra, and all other field metadata.

IMPORTANT: Verify this doesn't break existing tests. The old code had special handling for `field_info.default is not None` vs `...` — the new approach handles both cases because FieldInfo already carries the correct default internally.

Run tests — they MUST pass.
Commit: `feat(10-02): _build_plain_model preserves FieldInfo — descriptions survive into JSON schema`

REFACTOR: If all tests pass, no refactor needed. The change is minimal and clear.
  </action>
  <verify>`cd /Users/dzaramelcone/lab/bae && uv run pytest tests/test_fill_helpers.py -x -q` — all tests pass including new description tests</verify>
  <done>_build_plain_model preserves Field(description=...) via FieldInfo pass-through. transform_schema output includes description strings.</done>
</task>

<task type="auto">
  <name>Task 2: Add Field(description=...) to ootd.py RecommendOOTD</name>
  <files>examples/ootd.py</files>
  <action>
Update RecommendOOTD in examples/ootd.py to use Field(description=...) on fields where per-field context is helpful.

Add `from pydantic import Field` to the existing pydantic import line (which already imports BaseModel, HttpUrl).

Update RecommendOOTD (currently lines 187-195):
```python
class RecommendOOTD(Node):
    top: str = Field(description="a specific garment for the upper body")
    bottom: str = Field(description="a specific garment for the lower body")
    footwear: str = Field(description="specific shoes or boots")
    accessories: list[str] = Field(description="jewelry, bags, hats, scarves, etc.")
    final_response: str = Field(description="casual message to the user with the recommendation")
    inspo: list[HttpUrl] = Field(description="outfit inspiration image URLs")

    def __call__(self) -> None: ...
```

Also add Field to the import: change `from pydantic import BaseModel, HttpUrl` to `from pydantic import BaseModel, Field, HttpUrl`.

Do NOT add descriptions to IsTheUserGettingDressed or AnticipateUsersDay fields — those are either caller-provided (start node) or dep-filled, where descriptions are less useful.

Commit: `feat(10-02): add Field(description=...) to RecommendOOTD — explicit per-field LLM context`
  </action>
  <verify>Verify the example still parses: `cd /Users/dzaramelcone/lab/bae && uv run python -c "from examples.ootd import graph; print(f'Graph nodes: {len(graph.nodes)}')"` — prints "Graph nodes: 3"</verify>
  <done>RecommendOOTD fields have Field(description=...) annotations. Descriptions will flow into JSON output schema via _build_plain_model + transform_schema.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/ -x -q` — all tests pass
- `uv run python -c "from bae.lm import _build_plain_model; from anthropic import transform_schema; from examples.ootd import RecommendOOTD; m = _build_plain_model(RecommendOOTD); s = transform_schema(m); print(s['properties']['top'])"` — output includes "description": "a specific garment for the upper body"
- `grep 'Field(description=' examples/ootd.py` — shows 6 fields with descriptions
- Existing tests in test_fill_helpers.py (TestBuildPlainModel, TestValidatePlainFields) still pass — FieldInfo pass-through is backward compatible
</verification>

<success_criteria>
- _build_plain_model preserves Field(description=...) in dynamic models
- transform_schema output includes description strings for described fields
- RecommendOOTD in ootd.py uses Field(description=...) on all 6 fields
- All 322+ tests pass
- No regressions in existing _build_plain_model or validate_plain_fields tests
</success_criteria>

<output>
After completion, create `.planning/phases/10-hint-annotation/10-02-SUMMARY.md`
</output>
