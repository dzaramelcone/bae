---
phase: 06-node-lm-protocol
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/compiler.py
  - tests/test_signature_v2.py
autonomous: true

must_haves:
  truths:
    - "Dep-annotated fields become InputFields in the DSPy Signature"
    - "Recall-annotated fields become InputFields in the DSPy Signature"
    - "Plain fields on non-start nodes become OutputFields (LLM fills these)"
    - "Plain fields on start nodes become InputFields (caller-provided)"
    - "Class name (+ optional docstring) is the Signature instruction"
    - "Existing node_to_signature() still works for v1 callers (backward compat)"
  artifacts:
    - path: "bae/compiler.py"
      provides: "Redesigned node_to_signature with is_start param and classify_fields integration"
      contains: "def node_to_signature"
    - path: "tests/test_signature_v2.py"
      provides: "Tests for v2 signature generation from field classification"
  key_links:
    - from: "bae/compiler.py"
      to: "bae/resolver.py"
      via: "import classify_fields"
      pattern: "from bae.resolver import classify_fields"
    - from: "bae/compiler.py"
      to: "dspy"
      via: "make_signature, InputField, OutputField"
      pattern: "dspy.make_signature"
---

<objective>
Redesign node_to_signature() to use Phase 5's classify_fields() for determining InputField vs OutputField mapping, with an is_start parameter to handle start node semantics (caller-provided fields).

Purpose: This is the bridge between Phase 5's field classification system and DSPy's Signature generation. It replaces the old Context-marker-based approach with the new classify_fields-based approach, enabling the LM to receive proper context (Dep/Recall fields as InputFields) and generate proper output (plain fields as OutputFields).

Output: Updated bae/compiler.py with v2 node_to_signature, new test file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-node-lm-protocol/06-CONTEXT.md
@.planning/phases/06-node-lm-protocol/06-RESEARCH.md
@bae/compiler.py
@bae/resolver.py
@bae/markers.py
@bae/node.py
@tests/test_compiler.py
</context>

<feature>
  <name>node_to_signature() v2 with classify_fields integration</name>
  <files>bae/compiler.py, tests/test_signature_v2.py</files>
  <behavior>
    The new node_to_signature() accepts an optional `is_start: bool = False` parameter.

    Field mapping rules:
    - Dep fields -> InputField (context from external sources)
    - Recall fields -> InputField (context from trace)
    - Plain fields on start node (is_start=True) -> InputField (caller-provided)
    - Plain fields on non-start node (is_start=False) -> OutputField (LLM fills)

    Instruction:
    - node_cls.__name__ is the instruction text
    - If node_cls.__doc__ is not None, append ": {docstring.strip()}" to instruction

    The function still works when called without is_start (defaults to False), maintaining backward compatibility with existing callers in DSPyBackend.

    IMPORTANT: The existing _extract_context_fields() function in compiler.py is only used by the old code path. Keep it for now (Phase 8 removes it). The new node_to_signature should NOT use _extract_context_fields -- it uses classify_fields from bae.resolver instead.

    IMPORTANT: The old node_to_signature always added a generic "output" OutputField. The new version creates OutputFields from the node's actual plain fields (with their real names and types). No more generic "output" field -- the OutputFields are the node's actual fields that the LLM needs to fill. If the node has NO output fields (e.g., a start node where all plain fields are InputFields), the signature has only InputFields.

    Helper needed: A _get_base_type helper (may already exist in graph.py -- reuse or move) to extract the base type from Annotated[T, ...] -> T.

    Test cases:
    - Node with Dep field: dep field becomes InputField
    - Node with Recall field: recall field becomes InputField
    - Node with plain field (non-start): plain field becomes OutputField
    - Node with plain field (start): plain field becomes InputField
    - Node with mixed fields: each classified correctly
    - Node with docstring: instruction = "ClassName: docstring"
    - Node without docstring: instruction = "ClassName"
    - Node with only Dep/Recall fields (non-start): no OutputFields, only InputFields
    - Start node with only plain fields: all InputFields, no OutputFields
    - Result is a valid dspy.Signature subclass
    - Backward compat: calling without is_start defaults to non-start behavior
    - Existing test_compiler.py tests still pass (they use old Context marker pattern -- that's fine, the old _extract_context_fields path still exists)
  </behavior>
  <implementation>
    In bae/compiler.py:
    1. Add `from bae.resolver import classify_fields` import
    2. Add or reuse _get_base_type helper (extract base type from Annotated, handling union types)
    3. Modify node_to_signature() to accept `is_start: bool = False` parameter
    4. New implementation:
       a. Call classify_fields(node_cls) to get field classifications
       b. Get type hints with include_extras=True
       c. For each classified field:
          - "dep" or "recall" -> (base_type, dspy.InputField())
          - "plain" AND is_start -> (base_type, dspy.InputField())
          - "plain" AND NOT is_start -> (base_type, dspy.OutputField())
       d. Build instruction from class name + optional docstring
       e. Return dspy.make_signature(fields, instruction)
    5. Keep _extract_context_fields() function as-is (used by DSPyBackend v1 code)
    6. Keep existing compile_graph() function (it calls node_to_signature without is_start -- that's fine, defaults to non-start)
  </implementation>
</feature>

<verification>
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/test_signature_v2.py -v` -- all new tests pass
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/test_compiler.py -v` -- existing tests still pass
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -v` -- full test suite passes
</verification>

<success_criteria>
- node_to_signature uses classify_fields for field -> InputField/OutputField mapping
- is_start=True makes plain fields InputFields (caller-provided)
- is_start=False (default) makes plain fields OutputFields (LLM-filled)
- Dep and Recall fields are always InputFields regardless of is_start
- Class name + docstring becomes instruction
- Backward compatible: existing callers work without modification
</success_criteria>

<output>
After completion, create `.planning/phases/06-node-lm-protocol/06-02-SUMMARY.md`
</output>
