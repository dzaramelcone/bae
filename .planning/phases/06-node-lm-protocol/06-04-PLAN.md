---
phase: 06-node-lm-protocol
plan: 04
type: tdd
wave: 2
depends_on: ["06-02"]
files_modified:
  - bae/lm.py
  - bae/dspy_backend.py
  - tests/test_lm_protocol.py
autonomous: true

must_haves:
  truths:
    - "LM Protocol exposes choose_type(types, context) -> type[Node]"
    - "LM Protocol exposes fill(target, context, instruction) -> Node instance"
    - "choose_type picks one type from a list of candidate node types"
    - "fill creates a node instance with plain fields populated by the LM"
    - "Existing make/decide methods still work (backward compat)"
    - "DSPyBackend implements choose_type and fill using DSPy Predict"
    - "PydanticAIBackend implements choose_type and fill"
    - "ClaudeCLIBackend implements choose_type and fill"
  artifacts:
    - path: "bae/lm.py"
      provides: "Updated LM Protocol with choose_type + fill, backend implementations"
      contains: "def choose_type"
    - path: "bae/dspy_backend.py"
      provides: "DSPyBackend with choose_type + fill using new node_to_signature"
      contains: "def fill"
    - path: "tests/test_lm_protocol.py"
      provides: "Tests for choose_type/fill on all backends"
  key_links:
    - from: "bae/lm.py"
      to: "bae/node.py"
      via: "Node type references in Protocol signatures"
      pattern: "type\\[.*Node\\]"
    - from: "bae/dspy_backend.py"
      to: "bae/compiler.py"
      via: "node_to_signature for fill() implementation"
      pattern: "node_to_signature"
---

<objective>
Add choose_type() and fill() methods to the LM Protocol and implement them on all three backends (PydanticAIBackend, ClaudeCLIBackend, DSPyBackend). These replace the semantic role of make/decide for v2, though make/decide are preserved for backward compatibility.

Purpose: The LM protocol separates "pick successor type" (choose_type) from "populate fields" (fill). This clean separation maps directly to the v2 node contract where bae handles the entire lifecycle: resolve deps, resolve recalls, then have LM fill remaining fields and choose the next type.

Output: Updated bae/lm.py and bae/dspy_backend.py with new protocol methods, new test file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-node-lm-protocol/06-CONTEXT.md
@.planning/phases/06-node-lm-protocol/06-RESEARCH.md
@.planning/phases/06-node-lm-protocol/06-02-SUMMARY.md
@bae/lm.py
@bae/dspy_backend.py
@bae/compiler.py
@bae/node.py
@tests/test_dspy_backend.py
</context>

<feature>
  <name>LM Protocol choose_type/fill methods</name>
  <files>bae/lm.py, bae/dspy_backend.py, tests/test_lm_protocol.py</files>
  <behavior>
    New LM Protocol methods (added alongside existing make/decide):

    ```python
    def choose_type(
        self,
        types: list[type[Node]],
        context: dict[str, object],
    ) -> type[Node]:
        """Pick successor type from candidates, given resolved context fields."""

    def fill(
        self,
        target: type[T],
        context: dict[str, object],
        instruction: str,
    ) -> T:
        """Populate a node's plain fields given resolved context."""
    ```

    choose_type behavior:
    - Receives a list of concrete Node types (no None -- terminal detection is the graph's job)
    - Receives context dict of resolved field values (from resolve_fields)
    - Returns one of the types from the list
    - For single-type lists, can skip LLM call and return the type directly (optimization)

    fill behavior:
    - Receives target Node type to instantiate
    - Receives context dict (Dep + Recall resolved values = InputFields for LM)
    - Receives instruction string (node class name + optional docstring)
    - Uses node_to_signature(target, is_start=False) to generate DSPy Signature for the target
    - Actually, fill() should generate a signature where context keys are InputFields and the target's plain fields are OutputFields. This is exactly what node_to_signature(target, is_start=False) produces -- context fields (Dep/Recall) are InputFields, plain fields are OutputFields.
    - Returns an instance of target with plain fields filled by the LM

    Backend implementations:

    DSPyBackend.choose_type:
    - Build a choice signature with context as InputField and choice as OutputField
    - Use dspy.Predict to pick from type names
    - Map chosen name back to type
    - (Similar to existing _predict_choice but takes context dict instead of node)

    DSPyBackend.fill:
    - Call node_to_signature(target, is_start=False) to get signature
    - Create dspy.Predict(signature) predictor
    - Pass context dict as inputs (these map to the InputFields in the signature)
    - Parse the OutputField values into target type using model_validate
    - (Similar to existing make but context comes from dict, not from node fields)

    PydanticAIBackend.choose_type:
    - Build prompt from context dict (format as XML)
    - Ask pydantic-ai agent to pick from type names
    - Map back to type

    PydanticAIBackend.fill:
    - Build prompt from context + instruction
    - Use pydantic-ai agent with target as output type
    - Return instance

    ClaudeCLIBackend.choose_type:
    - Similar two-step: context -> pick type name via CLI
    - Map back to type

    ClaudeCLIBackend.fill:
    - Context + instruction -> CLI with target's JSON schema
    - Parse response into target instance

    IMPORTANT: Keep existing make/decide methods on ALL backends. They are still used by v1 code paths and existing tests. Phase 8 removes them.

    IMPORTANT: fill() does NOT call the target's constructor with all fields. It calls the LM to generate OutputField values, then uses model_construct() (or model_validate) to create the instance with BOTH the context fields AND the LM-generated fields. The context dict provides the InputField values; the LM generates the OutputField values.

    Test cases (using mock/unit tests -- no real LLM calls):
    - LM Protocol has choose_type method
    - LM Protocol has fill method
    - DSPyBackend: choose_type with single type returns that type (optimization)
    - DSPyBackend: choose_type with multiple types calls predictor
    - DSPyBackend: fill creates instance with plain fields from LM and context fields from dict
    - PydanticAIBackend: choose_type picks from candidates
    - PydanticAIBackend: fill returns target instance
    - ClaudeCLIBackend: choose_type uses two-step CLI pattern
    - ClaudeCLIBackend: fill uses CLI with JSON schema
    - Existing test_dspy_backend.py tests still pass (make/decide still work)

    For DSPyBackend tests, mock dspy.Predict to return controlled output. For PydanticAIBackend/ClaudeCLIBackend tests, mock the underlying agent/CLI calls.
  </behavior>
  <implementation>
    In bae/lm.py:
    1. Add choose_type and fill to LM Protocol class (with ... body as Protocol methods)
    2. Add choose_type and fill to PydanticAIBackend
    3. Add choose_type and fill to ClaudeCLIBackend

    In bae/dspy_backend.py:
    4. Add choose_type method (reuse logic from _predict_choice but with context dict)
    5. Add fill method (use node_to_signature with is_start=False, build inputs from context)
    6. Keep all existing methods (make, decide, _extract_context_fields, etc.)

    Key detail for fill(): The context dict keys should map to InputField names in the signature. The LM generates values for OutputField names. The returned instance needs ALL fields populated -- both InputField values (from context) and OutputField values (from LM). Use model_construct or model_validate to build the final instance.
  </implementation>
</feature>

<verification>
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/test_lm_protocol.py -v` -- all new tests pass
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/test_dspy_backend.py -v` -- existing tests still pass
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -v` -- full test suite passes
</verification>

<success_criteria>
- LM Protocol defines choose_type and fill methods
- All three backends implement choose_type and fill
- choose_type correctly picks one type from candidates given context
- fill correctly creates node instances with LM-generated plain fields and context-provided fields
- Existing make/decide methods still work on all backends
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/06-node-lm-protocol/06-04-SUMMARY.md`
</output>
