---
phase: 06-node-lm-protocol
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/node.py
  - tests/test_node_config.py
autonomous: true

must_haves:
  truths:
    - "NodeConfig is a standalone TypedDict, not extending ConfigDict"
    - "node_config is a ClassVar on Node, separate from model_config"
    - "Subclasses inherit node_config from parent unless overridden"
    - "_wants_lm detects whether __call__ declares an lm parameter"
    - "Existing tests still pass (no breakage from NodeConfig restructuring)"
  artifacts:
    - path: "bae/node.py"
      provides: "NodeConfig TypedDict, node_config ClassVar, _wants_lm helper"
      contains: "class NodeConfig"
    - path: "tests/test_node_config.py"
      provides: "Tests for NodeConfig, node_config inheritance, _wants_lm"
  key_links:
    - from: "bae/node.py"
      to: "bae/lm.py"
      via: "TYPE_CHECKING import for LM type in NodeConfig"
      pattern: "if TYPE_CHECKING"
---

<objective>
Redesign NodeConfig as a standalone TypedDict (not extending Pydantic's ConfigDict), add node_config as a separate ClassVar on Node, and implement _wants_lm() helper for detecting opt-in LM injection in __call__.

Purpose: NodeConfig must be separate from Pydantic's model_config to avoid conflating framework config with node-specific config. _wants_lm enables the auto-route vs escape-hatch distinction in Phase 7.

Output: Updated bae/node.py with new NodeConfig + _wants_lm, new test file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-node-lm-protocol/06-CONTEXT.md
@.planning/phases/06-node-lm-protocol/06-RESEARCH.md
@bae/node.py
@bae/lm.py
@tests/test_node.py
@tests/test_auto_routing.py
</context>

<feature>
  <name>NodeConfig redesign and _wants_lm helper</name>
  <files>bae/node.py, tests/test_node_config.py</files>
  <behavior>
    NodeConfig behavior:
    - NodeConfig is TypedDict(total=False) with a single key: lm (typed as LM under TYPE_CHECKING)
    - NodeConfig does NOT extend ConfigDict -- it is a standalone TypedDict
    - Node has `node_config: ClassVar[NodeConfig] = NodeConfig()` as a class attribute
    - Node still has `model_config = ConfigDict(arbitrary_types_allowed=True)` (standard Pydantic)
    - The old NodeConfig(ConfigDict, total=False) with model/temperature keys is replaced
    - Pydantic ignores node_config because it's ClassVar
    - Subclass without node_config inherits parent's empty NodeConfig()
    - Subclass WITH node_config = NodeConfig(lm=some_lm) overrides parent

    _wants_lm behavior:
    - _wants_lm(method) -> bool
    - Returns True if method has a parameter named "lm" (besides self)
    - Returns False if no "lm" parameter
    - Works on both bound and unbound methods
    - Works on Node.__call__ signatures

    IMPORTANT: Keep make/decide on LM Protocol -- don't remove anything. Keep existing Node.__call__ default implementation for now (it uses lm.decide(self)). The base Node.__call__ signature still has lm -- that's fine for backward compat. Phase 7 changes the execution loop; Phase 8 cleans up.

    Test cases:
    - NodeConfig() creates empty dict
    - NodeConfig(lm=mock_lm) stores lm value
    - NodeConfig is NOT a subclass of ConfigDict
    - Node.node_config defaults to empty NodeConfig()
    - Node.model_config is standard ConfigDict (not NodeConfig)
    - Subclass inherits node_config from Node (empty)
    - Subclass can override node_config with NodeConfig(lm=mock_lm)
    - Override does not leak to parent or sibling classes
    - _wants_lm returns True for def __call__(self, lm: LM)
    - _wants_lm returns True for def __call__(self, lm)
    - _wants_lm returns False for def __call__(self)
    - _wants_lm returns False for def __call__(self, other_param)
    - Existing test_node.py and test_auto_routing.py still pass
  </behavior>
  <implementation>
    In bae/node.py:
    1. Replace `class NodeConfig(ConfigDict, total=False)` with `class NodeConfig(TypedDict, total=False)` containing only `lm: LM` (under TYPE_CHECKING guard if needed, or using string annotation)
    2. Change Node class: replace `model_config: ClassVar[NodeConfig] = NodeConfig()` with two separate lines:
       - `model_config = ConfigDict(arbitrary_types_allowed=True)` (standard Pydantic config)
       - `node_config: ClassVar[NodeConfig] = NodeConfig()` (bae-specific config)
    3. Add _wants_lm function using inspect.signature to check for "lm" parameter
    4. Import TypedDict from typing
    5. Keep ALL existing functionality intact (Node.__call__ still takes lm, etc.)

    The NodeConfig TypedDict needs special handling for the `lm` field type since LM is a Protocol from bae.lm. Use TYPE_CHECKING guard and string annotation, or since TypedDict supports string annotations, use `"LM"` as the type. Actually, TypedDict with total=False and a TYPE_CHECKING import should work fine -- the type is only used at type-check time.
  </implementation>
</feature>

<verification>
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/test_node_config.py -v` -- all new tests pass
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/test_node.py tests/test_auto_routing.py -v` -- existing tests still pass
- `cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -v` -- full test suite passes
</verification>

<success_criteria>
- NodeConfig is a standalone TypedDict with `lm` key, NOT extending ConfigDict
- node_config is ClassVar[NodeConfig] on Node, separate from model_config
- _wants_lm correctly detects lm parameter presence
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/06-node-lm-protocol/06-01-SUMMARY.md`
</output>
