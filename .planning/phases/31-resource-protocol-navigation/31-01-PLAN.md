---
phase: 31-resource-protocol-navigation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/repl/resource.py
  - tests/test_resource.py
autonomous: true

must_haves:
  truths:
    - "ResourceRegistry.navigate('source') enters a resource and returns entry display with functions table, breadcrumb, and state"
    - "ResourceRegistry.back() pops navigation stack and returns parent entry display"
    - "ResourceRegistry.homespace() clears stack and returns root nav tree"
    - "ResourceHandle('source', registry)() calls registry.navigate('source')"
    - "ResourceHandle('source', registry).meta() calls registry.navigate('source.meta')"
    - "Dotted navigation (source.meta) resolves through children and pushes only the final resource"
    - "Nav tree shows indented structure with 'you are here' marker and @resource() hyperlinks"
    - "Bad navigation produces fuzzy correction error (e.g., 'No resource sourc. Did you mean @source()?')"
    - "Unsupported tool error includes nav hint to the right resource"
    - "Navigation stack caps at 20 depth"
  artifacts:
    - path: "bae/repl/resource.py"
      provides: "Resourcespace protocol, ResourceRegistry, ResourceHandle, ResourceError, entry/nav/error formatting"
      contains: "class Resourcespace"
    - path: "tests/test_resource.py"
      provides: "Tests for protocol, registry, navigation, handles, errors"
      min_lines: 150
  key_links:
    - from: "bae/repl/resource.py"
      to: "rich.tree.Tree"
      via: "nav() rendering"
      pattern: "Tree"
    - from: "bae/repl/resource.py"
      to: "difflib"
      via: "fuzzy name matching"
      pattern: "get_close_matches"
---

<objective>
Build the Resourcespace protocol, ResourceRegistry with navigation state machine, ResourceHandle callable objects, and all error/display formatting.

Purpose: Foundation for the entire v7.0 resourcespace system -- every subsequent phase composes on this protocol.
Output: `bae/repl/resource.py` with full protocol, registry, handles, formatting. Tests proving navigation, errors, display.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-resource-protocol-navigation/31-RESEARCH.md
@bae/repl/channels.py (Protocol+Registry pattern to follow)
@bae/repl/namespace.py (NsInspector callable pattern)
@bae/repl/views.py (_rich_to_ansi for nav tree rendering)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Tests for Resourcespace protocol, registry, navigation, handles, and errors</name>
  <files>tests/test_resource.py</files>
  <action>
Create `tests/test_resource.py` with tests covering all protocol behavior. Use a minimal stub Resourcespace for testing (a class satisfying the protocol with in-memory data).

Test categories:

**Protocol conformance:**
- A class with `name`, `description`, `enter()`, `nav()`, `read()`, `supported_tools()`, `children()` is `isinstance(Resourcespace)`
- A class missing a required method is NOT `isinstance(Resourcespace)`

**Registry navigation:**
- `registry.register(space)` makes it navigable by name
- `registry.navigate("source")` returns entry display string containing functions table and breadcrumb
- `registry.current` is the navigated resource after navigate()
- `registry.current` is None at root (before any navigation)
- `registry.back()` pops to previous location
- `registry.back()` at root returns root nav (no crash)
- `registry.homespace()` clears entire stack, returns root nav tree
- `registry.breadcrumb()` returns "home" at root, "home > source" after navigating to source
- Dotted navigation: `registry.navigate("source.meta")` enters meta subresource of source
- Dotted navigation breadcrumb: "home > source > meta"
- Direct jump from any depth: navigate("tasks") when inside source.meta jumps correctly
- Stack depth caps at 20 (navigate 21 times, stack stays at 20)

**ResourceHandle:**
- `ResourceHandle("source", registry)()` returns same as `registry.navigate("source")`
- `ResourceHandle("source", registry).meta()` returns same as `registry.navigate("source.meta")`
- `repr(ResourceHandle("source", registry))` contains "@source()"

**Entry display format (per CONTEXT.md locked decisions):**
- Entry contains breadcrumb line
- Entry contains resource description and state
- Entry contains functions table with columns: tool override, function name, description
- Entry contains "Advanced:" block if resource provides Python hints

**Nav tree:**
- Nav tree output contains `@resource()` mentions for each navigable target
- Nav tree marks current position
- Nav tree indents children under parents

**Error formatting:**
- Navigate to nonexistent resource returns error with fuzzy suggestion (register "source", navigate "sourc" -> "Did you mean @source()?")
- Navigate to nonexistent with no close match returns plain error
- `format_unsupported_error(resource, "write")` returns message with nav hint
- Errors contain @resource() hyperlinks

All tests should FAIL initially (RED phase) since resource.py doesn't exist yet.
  </action>
  <verify>`uv run pytest tests/test_resource.py -x -q` -- all tests fail with ImportError or similar (RED)</verify>
  <done>Test file exists with 20+ test functions, all failing</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement Resourcespace protocol, ResourceRegistry, ResourceHandle, formatting</name>
  <files>bae/repl/resource.py</files>
  <action>
Create `bae/repl/resource.py` implementing everything the tests require.

**Resourcespace Protocol** (follow `ViewFormatter` pattern from channels.py):
```python
@runtime_checkable
class Resourcespace(Protocol):
    name: str
    description: str
    def enter(self) -> str: ...
    def nav(self) -> str: ...
    def read(self, target: str = "") -> str: ...
    def supported_tools(self) -> set[str]: ...
    def children(self) -> dict[str, "Resourcespace"]: ...
```

**ResourceError** -- dataclass for protocol-level error wrapping:
- `message: str` -- human-readable error
- `hints: list[str]` -- @resource() hyperlinks for better targets
- `__str__` returns formatted error with hints

**ResourceRegistry** -- flat dict + navigation stack:
- `_spaces: dict[str, Resourcespace]` -- registered resources
- `_stack: list[Resourcespace]` -- navigation history (cap at 20)
- `register(space)` -- add by space.name
- `navigate(target: str) -> str` -- resolve dotted paths, push stack, return entry display. On error, fuzzy match with `difflib.get_close_matches` and return formatted error.
- `back() -> str` -- pop stack, return entry or root nav
- `homespace() -> str` -- clear stack, return root nav tree
- `current -> Resourcespace | None` -- top of stack
- `breadcrumb() -> str` -- "home > source > meta" chain from stack
- `_root_nav() -> str` -- render nav tree from root using `rich.tree.Tree` via `_rich_to_ansi` from views.py. Shows all registered resources as `@resource()` with their children. Marks current position with " <-- you are here" if navigated in. Cap tree depth at 2 levels; collapse deeper with "+N more".
- `_entry_display(space: Resourcespace) -> str` -- breadcrumb + description + state + functions table + Advanced hints. Functions table format per CONTEXT.md: `| Tool | Function | Returns |` with columns for tool override, name, description. Resource provides this data via `enter()`.
- Transition message on navigation: "Left source -> entering tasks" (brief, per CONTEXT.md)

**ResourceHandle** -- callable namespace object:
- `__init__(self, name: str, registry: ResourceRegistry)`
- `__call__() -> str` -- calls `registry.navigate(self._name)`
- `__getattr__(child) -> ResourceHandle` -- returns handle for dotted path
- `__repr__()` -- `@{name}() -- navigate to {name}`

**Error formatting functions:**
- `format_unsupported_error(space, tool) -> str` -- "source does not support edit. Try @source.meta()" per CONTEXT.md. Check children for the tool and suggest the right one.
- `format_nav_error(target, registry) -> str` -- fuzzy match + hyperlink. "No resource 'sourc'. Did you mean @source()?"

**Navigation details per CONTEXT.md locked decisions:**
- Dotted navigation resolves target directly, pushes only the final resource onto stack (not intermediates). Per Pitfall 6 in research.
- `back()` returns to wherever the agent was before the jump
- Direct jump from any depth: navigate("tasks") while inside source.meta pushes tasks on stack (stack: [source, source.meta, tasks])

Use `from bae.repl.views import _rich_to_ansi` for nav tree rendering to ANSI.
  </action>
  <verify>`uv run pytest tests/test_resource.py -x -q` -- all tests pass (GREEN)</verify>
  <done>All test_resource.py tests pass. resource.py implements full protocol, registry, handles, formatting.</done>
</task>

</tasks>

<verification>
```bash
uv run pytest tests/test_resource.py -x -q
uv run pytest tests/ -x -q --ignore=tests/test_integration.py
```
All tests pass including existing test suite.
</verification>

<success_criteria>
- Resourcespace protocol is runtime-checkable
- Registry supports register, navigate (including dotted), back, homespace
- ResourceHandle is callable with dotted attribute access
- Entry display includes breadcrumb, functions table, state, Advanced hints
- Nav tree renders with @resource() hyperlinks and position marker
- Errors include fuzzy suggestions and @resource() hyperlinks
- Navigation stack caps at 20
</success_criteria>

<output>
After completion, create `.planning/phases/31-resource-protocol-navigation/31-01-SUMMARY.md`
</output>
