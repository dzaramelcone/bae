---
phase: 31-resource-protocol-navigation
plan: 02
type: tdd
wave: 2
depends_on: ["31-01"]
files_modified:
  - bae/repl/tools.py
  - tests/test_tools_router.py
autonomous: true

must_haves:
  truths:
    - "ToolRouter dispatches read/write/edit/glob/grep to current resource when navigated in"
    - "ToolRouter falls through to filesystem (homespace) when at root"
    - "Unsupported tool returns formatted error with nav hint"
    - "All resource tool output is pruned to 500 tokens (~2000 chars) with structure preservation"
    - "Error output is never pruned"
    - "Pruning preserves headings and counts, trims content details"
    - "Pruned output includes indicator (e.g., '[pruned: 42 -> 10 items]')"
    - "Multiple errors in a single operation are collected and reported together"
  artifacts:
    - path: "bae/repl/tools.py"
      provides: "ToolRouter with dispatch, pruning, homespace passthrough"
      contains: "class ToolRouter"
    - path: "tests/test_tools_router.py"
      provides: "Tests for dispatch routing, pruning, error handling"
      min_lines: 100
  key_links:
    - from: "bae/repl/tools.py"
      to: "bae/repl/resource.py"
      via: "registry.current for dispatch routing"
      pattern: "registry\\.current"
    - from: "bae/repl/tools.py"
      to: "bae/repl/ai.py"
      via: "_exec_* functions for homespace fallback"
      pattern: "_exec_read|_exec_glob|_exec_grep"
---

<objective>
Build the ToolRouter that intercepts tool calls and dispatches to the current resource's handlers, with homespace filesystem fallback and structure-first pruning.

Purpose: Tool dispatch routing is what makes resourcespace context-aware -- same tools, different behavior per location.
Output: `bae/repl/tools.py` with ToolRouter and pruning. Tests proving dispatch, pruning, errors.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-resource-protocol-navigation/31-RESEARCH.md
@.planning/phases/31-resource-protocol-navigation/31-01-SUMMARY.md
@bae/repl/resource.py (protocol and registry from Plan 01)
@bae/repl/ai.py (_exec_* functions for homespace fallback, run_tool_calls for integration pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Tests for ToolRouter dispatch, pruning, and error handling</name>
  <files>tests/test_tools_router.py</files>
  <action>
Create `tests/test_tools_router.py` with tests covering tool dispatch and pruning. Use the same minimal stub Resourcespace from test_resource.py (or create a similar one).

**Dispatch routing tests:**
- At root (registry.current is None), ToolRouter.dispatch("read", "some/file.py") calls filesystem read (homespace passthrough)
- When navigated into a resource that supports "read", dispatch("read", "target") calls resource.read("target")
- When navigated into a resource that does NOT support "write", dispatch("write", ...) returns formatted unsupported error
- Dispatch catches ResourceError from resource methods and returns error string (never pruned)
- Root dispatch auto-defaults: dispatch("read", "") at root lists resourcespaces (per CONTEXT.md: "read() at root lists resourcespaces")

**Pruning tests:**
- Output under 2000 chars passes through unchanged
- Output over 2000 chars is pruned to ~2000 chars
- Pruned output contains "[pruned:" indicator
- Headings (lines starting with #, |, or ===) are preserved in pruning
- First and last structural blocks are preserved
- Error output (containing "Error" or ResourceError) is never pruned, even if over cap
- Output with list items: keeps first N items, appends pruning indicator

**Token cap constant:**
- `TOKEN_CAP == 500`
- `CHAR_CAP == 2000` (TOKEN_CAP * 4)

**Error collection:**
- Multiple errors from a single dispatch are collected and returned together

All tests should FAIL initially (RED phase).
  </action>
  <verify>`uv run pytest tests/test_tools_router.py -x -q` -- all tests fail with ImportError (RED)</verify>
  <done>Test file exists with 15+ test functions, all failing</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement ToolRouter with dispatch, pruning, and homespace fallback</name>
  <files>bae/repl/tools.py</files>
  <action>
Create `bae/repl/tools.py` implementing the ToolRouter.

**Constants:**
```python
TOKEN_CAP = 500   # protocol-level constant, not configurable
CHAR_CAP = TOKEN_CAP * 4  # ~4 chars/token heuristic
```

**ToolRouter class:**
```python
class ToolRouter:
    def __init__(self, registry: ResourceRegistry):
        self._registry = registry

    def dispatch(self, tool: str, arg: str, **kwargs) -> str:
        """Route tool call to current resource or homespace."""
```

- If `registry.current` is None (at root): call `_homespace_dispatch(tool, arg, **kwargs)` which delegates to the existing `_exec_*` functions from `ai.py`. For `read` at root with empty arg, return a listing of registered resourcespaces (per CONTEXT.md "Tools at homespace root auto-dispatch to sensible defaults").
- If `registry.current` is not None: check `current.supported_tools()`. If tool not supported, return `format_unsupported_error(current, tool)` from resource.py. If supported, call `getattr(current, tool)(arg, **kwargs)`.
- Wrap resource method calls in try/except for ResourceError -- return `str(error)` directly (no pruning on errors).
- For non-error output, call `_prune(result)`.

**Pruning algorithm (`_prune`):**
Per CONTEXT.md locked decisions: deterministic, structure-first, no LM calls.

```
def _prune(self, output: str) -> str:
    if len(output) <= CHAR_CAP:
        return output
    # Parse into lines
    # Identify structural lines (headings, table headers, separators)
    # Identify content lines (everything else)
    # Budget: keep all structural lines, fill remaining budget with content
    # Preserve first block and last line
    # Append "[pruned: {total_items} -> {shown_items} items]"
```

Structural line detection: lines matching `^#{1,6} `, `^\|`, `^[=-]+$`, `^  *-`, or lines that are blank (block separators). Content lines are everything else.

Keep all structural lines. From content lines, keep first N that fit within remaining char budget. Always keep the last content line if it looks like a summary (contains "total", "items", or a count pattern). Append `[pruned: {total} -> {shown} items]` at the end.

**Error detection for pruning bypass:**
Never prune output where the source was a ResourceError exception. The `dispatch` method already handles this by returning error strings before the `_prune` call.

**Homespace dispatch:**
Import `_exec_read, _exec_write, _exec_edit_read, _exec_edit_replace, _exec_glob, _exec_grep` from `bae.repl.ai`. Map tool names to functions:
```python
_HOMESPACE = {
    "read": _exec_read,
    "write": _exec_write,
    "edit": _exec_edit_read,
    "glob": _exec_glob,
    "grep": _exec_grep,
}
```
  </action>
  <verify>`uv run pytest tests/test_tools_router.py -x -q` -- all tests pass (GREEN)</verify>
  <done>All test_tools_router.py tests pass. ToolRouter dispatches correctly with pruning and error handling.</done>
</task>

</tasks>

<verification>
```bash
uv run pytest tests/test_tools_router.py -x -q
uv run pytest tests/ -x -q --ignore=tests/test_integration.py
```
All tests pass including existing test suite.
</verification>

<success_criteria>
- ToolRouter dispatches to current resource's handlers when navigated in
- ToolRouter falls through to filesystem _exec_* functions at root
- Unsupported tools return clear errors with nav hints
- Output over 2000 chars is pruned with structure preservation
- Error output is never pruned
- Pruning indicator always present when pruning happens
</success_criteria>

<output>
After completion, create `.planning/phases/31-resource-protocol-navigation/31-02-SUMMARY.md`
</output>
