---
phase: 31-resource-protocol-navigation
plan: 03
type: execute
wave: 3
depends_on: ["31-01", "31-02"]
files_modified:
  - bae/repl/ai.py
  - bae/repl/shell.py
  - bae/repl/namespace.py
  - bae/repl/toolbar.py
  - bae/repl/ai_prompt.md
  - tests/test_ai.py
autonomous: true

must_haves:
  truths:
    - "run_tool_calls() routes through ToolRouter when router is provided"
    - "CortexShell creates ResourceRegistry, ToolRouter, and seeds ResourceHandles into namespace"
    - "homespace() and back() are available as top-level namespace callables"
    - "AI prompt includes navigation instructions"
    - "Toolbar shows current resource location when navigated in"
    - "Resource handles are excluded from _build_context namespace dump"
  artifacts:
    - path: "bae/repl/ai.py"
      provides: "run_tool_calls with optional router parameter"
      contains: "router"
    - path: "bae/repl/shell.py"
      provides: "ResourceRegistry and ToolRouter creation, namespace seeding"
      contains: "ResourceRegistry"
    - path: "bae/repl/ai_prompt.md"
      provides: "Navigation instructions for AI"
      contains: "resource"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/resource.py"
      via: "ResourceRegistry creation and namespace seeding"
      pattern: "ResourceRegistry|ResourceHandle"
    - from: "bae/repl/ai.py"
      to: "bae/repl/tools.py"
      via: "ToolRouter dispatch in run_tool_calls"
      pattern: "ToolRouter|router"
    - from: "bae/repl/shell.py"
      to: "bae/repl/tools.py"
      via: "ToolRouter creation"
      pattern: "ToolRouter"
---

<objective>
Wire ResourceRegistry, ToolRouter, and ResourceHandles into the existing cortex shell, AI agent, and prompt system.

Purpose: Without integration, the protocol and router are isolated modules -- this plan makes them live in the running system.
Output: Modified ai.py, shell.py, namespace.py, toolbar.py, ai_prompt.md. All existing tests continue to pass.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-resource-protocol-navigation/31-01-SUMMARY.md
@.planning/phases/31-resource-protocol-navigation/31-02-SUMMARY.md
@bae/repl/ai.py
@bae/repl/shell.py
@bae/repl/namespace.py
@bae/repl/toolbar.py
@bae/repl/ai_prompt.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ToolRouter into run_tool_calls and update AI context</name>
  <files>bae/repl/ai.py, bae/repl/ai_prompt.md</files>
  <action>
**ai.py modifications:**

1. Add `router` parameter to `run_tool_calls()` with backward-compatible default `None`. Follow the same pattern as `Graph.arun(dep_cache=None)` for backward-compat param addition:

```python
def run_tool_calls(text: str, router=None) -> list[tuple[str, str]]:
```

When `router` is not None, instead of calling `_exec_*` functions directly, call `router.dispatch(tool_name, arg)`. The tool name mapping: "R" -> "read", "E" -> "edit", "G" -> "glob", "Grep" -> "grep", "W" -> "write". Only dispatch through router when we have one; otherwise fall through to existing behavior (100% backward compat).

Modify the `pending` lambda construction in the single-line tag, OSC8, write, and edit-replace sections to check if router exists and dispatch through it.

2. Add `router` parameter to `AI.__init__()`:

```python
def __init__(self, ..., router=None) -> None:
    self._tool_router = router
```

Pass `self._tool_router` to `run_tool_calls()` in the eval loop.

3. Update `_build_context()` to include resource location when registry is available. Add resource handles to `_SKIP` set so they don't clutter namespace dump. Add `"homespace"`, `"back"` to `_SKIP` as well.

4. Add a `_resource_context(registry)` helper that returns a brief string like:
```
[Location: home > source]
```
This is injected into every `_send()` call (per Pitfall 1 from research -- inject location into EVERY send, not just first `_build_context()`). Add `registry` parameter to AI.__init__() or pass through via namespace convention.

**ai_prompt.md modifications:**

Append a navigation section after the existing content:

```markdown
## Resources
Navigate with `<run>source()</run>`, `<run>tasks()</run>`, etc. `@resource()` mentions are navigable.
`<run>homespace()</run>` returns to root. `<run>back()</run>` returns to previous.
`<run>source.nav()</run>` shows navigation targets.
Tools (R/W/E/G/Grep) operate on the current resource when navigated in.
```

Keep it brief -- the AI learns from the functions table on entry, not from lengthy prompt instructions.
  </action>
  <verify>`uv run pytest tests/test_ai.py -x -q` -- existing AI tests still pass. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite passes.</verify>
  <done>run_tool_calls accepts optional router, AI passes it through, ai_prompt.md has navigation section, _build_context excludes resource handles</done>
</task>

<task type="auto">
  <name>Task 2: Create ResourceRegistry in CortexShell and seed namespace with handles</name>
  <files>bae/repl/shell.py, bae/repl/namespace.py, bae/repl/toolbar.py</files>
  <action>
**shell.py modifications:**

In `CortexShell.__init__()`, after the AI session creation block:

1. Create ResourceRegistry and ToolRouter:
```python
from bae.repl.resource import ResourceRegistry, ResourceHandle
from bae.repl.tools import ToolRouter

self.registry = ResourceRegistry()
self._tool_router = ToolRouter(self.registry)
```

2. Create and seed namespace with navigation handles:
```python
self.namespace["homespace"] = ResourceHandle("homespace", self.registry)
self.namespace["back"] = ResourceHandle("back", self.registry)
```

Note: No concrete resourcespaces to register yet (those come in Phases 32-35). The registry starts empty. `homespace()` at root returns the root nav tree (which will be empty initially, showing "No resourcespaces registered yet").

3. Pass `router=self._tool_router` to AI creation. Update `_get_or_create_session()`:
```python
self._ai_sessions[label] = AI(
    lm=self._lm,
    router=self.router,
    namespace=self.namespace,
    tm=self.tm,
    label=label,
    tool_router=self._tool_router,
)
```

4. Add toolbar location widget. After existing toolbar.add calls:
```python
from bae.repl.toolbar import make_location_widget
self.toolbar.add("location", make_location_widget(self))
```

5. Add toolbar style for location:
```python
"toolbar.location": "fg:ansigreen",
```

**namespace.py modifications:**

Add resource handle names to `_PRELOADED` is NOT needed (they're seeded in shell.py, not in seed()). No changes needed here -- the handles get excluded via `_SKIP` in `_build_context()` which was updated in Task 1.

**toolbar.py modifications:**

Add `make_location_widget()` function:

```python
def make_location_widget(shell) -> ToolbarWidget:
    """Built-in widget: current resource location (hidden at root)."""
    def widget():
        if not hasattr(shell, 'registry') or shell.registry.current is None:
            return []
        return [("class:toolbar.location", f" {shell.registry.breadcrumb()} ")]
    return widget
```
  </action>
  <verify>`uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite passes including all new and existing tests.</verify>
  <done>CortexShell creates registry and router, namespace has homespace() and back(), toolbar shows location, AI routes tools through ToolRouter</done>
</task>

</tasks>

<verification>
```bash
uv run pytest tests/ -x -q --ignore=tests/test_integration.py
```
Full test suite passes. No regressions. Resource protocol, registry, tool routing, and shell integration all wired.
</verification>

<success_criteria>
- run_tool_calls(text, router=None) is backward compatible -- no router means existing behavior
- CortexShell creates ResourceRegistry and ToolRouter
- homespace() and back() are callable in namespace
- AI prompt includes navigation instructions
- Toolbar shows resource location when navigated in
- All 647+ existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-resource-protocol-navigation/31-03-SUMMARY.md`
</output>
