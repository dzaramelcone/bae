---
phase: 03-optimization
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - bae/compiler.py
  - bae/__init__.py
  - tests/test_optimizer.py
autonomous: true

must_haves:
  truths:
    - "CompiledGraph.optimize() uses optimize_node for each node class"
    - "CompiledGraph stores optimized predictors"
    - "CompiledGraph.save() persists optimized state"
    - "CompiledGraph.load() restores optimized state"
    - "All optimizer functions exported from bae package"
  artifacts:
    - path: "bae/compiler.py"
      provides: "CompiledGraph with optimization methods"
      contains: "def optimize|def save|def load"
    - path: "bae/__init__.py"
      provides: "Public exports for optimizer"
      contains: "trace_to_examples|optimize_node"
    - path: "tests/test_optimizer.py"
      provides: "Integration tests for CompiledGraph"
      contains: "test_compiled_graph"
  key_links:
    - from: "bae/compiler.py"
      to: "bae/optimizer.py"
      via: "import optimizer functions"
      pattern: "from bae\\.optimizer import"
    - from: "bae/__init__.py"
      to: "bae/optimizer.py"
      via: "export optimizer functions"
      pattern: "from bae\\.optimizer import"
---

<objective>
Wire optimizer into CompiledGraph and export public API

Purpose: Connect the optimizer functions to the existing CompiledGraph class, implementing the TODO stubs. Add save/load methods. Export all optimizer functions from the bae package.

Output: Working CompiledGraph with optimization, tests verifying end-to-end flow
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/03-optimization/03-RESEARCH.md
@.planning/phases/03-optimization/03-01-SUMMARY.md
@.planning/phases/03-optimization/03-02-SUMMARY.md
@.planning/phases/03-optimization/03-03-SUMMARY.md

@bae/compiler.py
@bae/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CompiledGraph methods</name>
  <files>bae/compiler.py</files>
  <action>
    Update CompiledGraph class in bae/compiler.py:

    1. Add import at top:
       from bae.optimizer import optimize_node, save_optimized, load_optimized, trace_to_examples, node_transition_metric

    2. Update __init__ to store optimized predictors:
       - Add self.optimized: dict[type[Node], dspy.Predict] = {}

    3. Implement optimize() method:
       ```python
       def optimize(
           self,
           trainset: list[dspy.Example],
           metric: Callable | None = None,
       ) -> "CompiledGraph":
           """Optimize all node predictors with collected traces.

           Args:
               trainset: Training examples (from trace_to_examples)
               metric: Scoring function (defaults to node_transition_metric)

           Returns:
               Self for chaining
           """
           for node_cls in self.graph.nodes:
               self.optimized[node_cls] = optimize_node(
                   node_cls, trainset, metric
               )
           return self
       ```

    4. Implement save() method:
       ```python
       def save(self, path: str | Path) -> None:
           """Save optimized predictors to directory."""
           from pathlib import Path
           save_optimized(self.optimized, Path(path))
       ```

    5. Add load() class method:
       ```python
       @classmethod
       def load(cls, graph: Graph, path: str | Path) -> "CompiledGraph":
           """Load optimized predictors from directory."""
           from pathlib import Path
           compiled = compile_graph(graph)
           compiled.optimized = load_optimized(list(graph.nodes), Path(path))
           return compiled
       ```

    6. Remove or keep the async run() TODO - it's not needed for Phase 3 scope
  </action>
  <verify>python -c "from bae.compiler import CompiledGraph; print('Import OK')"</verify>
  <done>CompiledGraph has optimize(), save(), load() methods that delegate to optimizer functions</done>
</task>

<task type="auto">
  <name>Task 2: Export optimizer functions from bae package</name>
  <files>bae/__init__.py</files>
  <action>
    Update bae/__init__.py to export optimizer functions:

    1. Add import:
       from bae.optimizer import (
           trace_to_examples,
           node_transition_metric,
           optimize_node,
           save_optimized,
           load_optimized,
       )

    2. Add to __all__:
       # Optimizer
       "trace_to_examples",
       "node_transition_metric",
       "optimize_node",
       "save_optimized",
       "load_optimized",
  </action>
  <verify>python -c "from bae import trace_to_examples, optimize_node, save_optimized, load_optimized; print('Exports OK')"</verify>
  <done>All optimizer functions accessible via `from bae import ...`</done>
</task>

<task type="auto">
  <name>Task 3: Add CompiledGraph integration tests</name>
  <files>tests/test_optimizer.py</files>
  <action>
    Add integration tests at end of tests/test_optimizer.py:

    ```python
    # ============================================================
    # CompiledGraph Integration Tests
    # ============================================================

    class TestCompiledGraphOptimize:
        """Tests for CompiledGraph.optimize()."""

        def test_optimize_creates_predictors_for_all_nodes(self, sample_trainset):
            """optimize() creates optimized predictor for each node in graph."""
            from bae import Graph, compile_graph

            # Create simple graph
            class Start(Node):
                text: Annotated[str, Context()]

                def __call__(self, lm: LM) -> "End":
                    ...

            class End(Node):
                result: str

            graph = Graph(nodes=[Start, End])
            compiled = compile_graph(graph)

            # Optimize with trainset (may be small, that's ok)
            compiled.optimize(sample_trainset)

            # Should have predictors for both nodes
            assert Start in compiled.optimized
            assert End in compiled.optimized

        def test_optimize_returns_self_for_chaining(self, sample_trainset):
            """optimize() returns self for method chaining."""
            from bae import Graph, compile_graph

            class SimpleNode(Node):
                text: str

            graph = Graph(nodes=[SimpleNode])
            compiled = compile_graph(graph)

            result = compiled.optimize(sample_trainset)
            assert result is compiled


    class TestCompiledGraphSaveLoad:
        """Tests for CompiledGraph save/load."""

        def test_save_load_roundtrip(self, tmp_path, sample_trainset):
            """save() then load() produces working CompiledGraph."""
            from bae import Graph, compile_graph

            class RoundTripNode(Node):
                data: Annotated[str, Context()]

                def __call__(self, lm: LM) -> None:
                    ...

            graph = Graph(nodes=[RoundTripNode])
            compiled = compile_graph(graph)
            compiled.optimize(sample_trainset)

            # Save
            save_path = tmp_path / "compiled"
            compiled.save(save_path)

            # Load into new CompiledGraph
            loaded = CompiledGraph.load(graph, save_path)

            # Should have same nodes in optimized dict
            assert RoundTripNode in loaded.optimized
    ```

    Also add a sample_trainset fixture if not already present:

    ```python
    @pytest.fixture
    def sample_trainset():
        """Create sample training set for optimizer tests."""
        # Create minimal trainset - not enough for real optimization
        # but sufficient for testing the plumbing
        examples = []
        for i in range(5):  # Intentionally small
            ex = dspy.Example(
                node_type="TestNode",
                text=f"sample {i}",
                next_node_type="NextNode",
            ).with_inputs("node_type", "text")
            examples.append(ex)
        return examples
    ```
  </action>
  <verify>pytest tests/test_optimizer.py -v -k "CompiledGraph"</verify>
  <done>Integration tests verify CompiledGraph.optimize(), save(), and load() work together</done>
</task>

</tasks>

<verification>
```bash
# All optimizer tests pass
pytest tests/test_optimizer.py -v

# All project tests pass
pytest tests/ -v

# Imports work
python -c "from bae import trace_to_examples, optimize_node, save_optimized, load_optimized, compile_graph; print('All exports OK')"
```
</verification>

<success_criteria>
- CompiledGraph.optimize() uses optimize_node for each node class
- CompiledGraph.save() and .load() persist/restore optimized state
- All optimizer functions exported from bae package root
- All tests pass
- Phase 3 requirements OPT-01 through OPT-04 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-optimization/03-04-SUMMARY.md`
</output>
