---
phase: 05-markers-resolver
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/markers.py
  - bae/exceptions.py
  - bae/resolver.py
  - tests/test_resolver.py
autonomous: true

must_haves:
  truths:
    - "Dep(callable) creates a frozen marker storing a reference to the callable"
    - "Recall() creates a frozen marker with no parameters"
    - "RecallError is a BaeError subclass that can be raised and caught"
    - "classify_fields returns 'dep' for Dep-annotated fields, 'recall' for Recall-annotated, 'plain' for others"
    - "v1 Dep(description='...') still works (backward compat until Phase 8 cleanup)"
  artifacts:
    - path: "bae/markers.py"
      provides: "v2 Dep(callable) and Recall() markers"
      contains: "class Dep"
    - path: "bae/exceptions.py"
      provides: "RecallError exception"
      contains: "class RecallError"
    - path: "bae/resolver.py"
      provides: "classify_fields() function"
      contains: "def classify_fields"
    - path: "tests/test_resolver.py"
      provides: "Tests for markers and field classification"
  key_links:
    - from: "bae/resolver.py"
      to: "bae/markers.py"
      via: "imports Dep, Recall for isinstance checks"
      pattern: "isinstance.*Dep|isinstance.*Recall"
---

<objective>
Create the v2 marker types (Dep with callable, Recall) and the field classification function that determines how each node field should be resolved.

Purpose: Every other Phase 5 plan depends on these markers and the field classification logic. This is the foundation layer.
Output: Updated `bae/markers.py` with v2 Dep/Recall, `bae/exceptions.py` with RecallError, new `bae/resolver.py` with `classify_fields()`, and tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-markers-resolver/05-CONTEXT.md
@.planning/phases/05-markers-resolver/05-RESEARCH.md
@bae/markers.py
@bae/exceptions.py
@bae/node.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for v2 markers + classify_fields</name>
  <files>tests/test_resolver.py, bae/markers.py, bae/exceptions.py</files>
  <action>
Create `tests/test_resolver.py` with the following test classes and tests. All tests should fail initially (markers and resolver don't exist yet in v2 form).

**Class `TestDepMarker`:**
- `test_dep_stores_callable`: Create `Dep(some_function)` where `some_function` is a plain function. Assert `dep.fn is some_function`.
- `test_dep_frozen`: Create `Dep(some_function)`, attempt to reassign `dep.fn = other`. Assert `FrozenInstanceError` is raised.
- `test_dep_backward_compat`: Create `Dep(description="old style")`. Assert `dep.description == "old style"` and `dep.fn is None`. This tests v1 usage still works.

**Class `TestRecallMarker`:**
- `test_recall_creates_marker`: Create `Recall()`. Assert it's an instance of `Recall`.
- `test_recall_frozen`: Create `Recall()`, attempt to set an attribute. Assert `FrozenInstanceError` is raised.

**Class `TestRecallError`:**
- `test_recall_error_is_bae_error`: Assert `issubclass(RecallError, BaeError)`.
- `test_recall_error_message`: Raise and catch `RecallError("no match for Foo")`, assert message is preserved.

**Class `TestClassifyFields`:**
- `test_dep_field_classified`: Define a test Node subclass with `data: Annotated[str, Dep(some_fn)]`. Call `classify_fields(TestNode)`. Assert `result["data"] == "dep"`.
- `test_recall_field_classified`: Define a test Node with `prev: Annotated[str, Recall()]`. Assert `result["prev"] == "recall"`.
- `test_plain_field_classified`: Define a test Node with `name: str`. Assert `result["name"] == "plain"`.
- `test_mixed_fields`: Define a test Node with one dep field, one recall field, one plain field. Assert all three are classified correctly.
- `test_annotated_without_marker`: Define a test Node with `data: Annotated[str, "some other metadata"]`. Assert `result["data"] == "plain"`.

Use `from bae.markers import Dep, Recall` and `from bae.exceptions import RecallError` and `from bae.resolver import classify_fields` for imports.

For test Node subclasses, import `from bae.node import Node` and `from typing import Annotated`.

Define simple dep functions at module level for test use:
```python
def get_data() -> str:
    return "test data"
```

Run tests: `pytest tests/test_resolver.py -v`. All tests must FAIL (RED).

Commit: `test(05-01): add failing tests for v2 markers and classify_fields`
  </action>
  <verify>`pytest tests/test_resolver.py -v` shows all tests FAILING (ImportError or AssertionError expected for classify_fields tests)</verify>
  <done>Test file exists with comprehensive tests covering Dep(callable), Recall(), RecallError, and classify_fields. All tests fail.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement v2 markers, RecallError, and classify_fields</name>
  <files>bae/markers.py, bae/exceptions.py, bae/resolver.py</files>
  <action>
**Update `bae/markers.py`:**

Modify the `Dep` dataclass to support v2 `Dep(callable)` while preserving v1 `Dep(description="...")` backward compatibility:
- Add `fn: Callable | None = None` as the FIRST field (before `description`)
- Keep `description: str = ""` as the second field
- Import `Callable` from `collections.abc`
- Update the docstring to document both usages (v2 field annotation and v1 __call__ param annotation)

Add the `Recall` dataclass:
- Frozen dataclass with no fields (just `pass` body)
- Docstring explains it searches the execution trace backward for matching type via MRO

**Update `bae/exceptions.py`:**

Add `RecallError(BaeError)` class:
- Follows existing pattern (inherits from BaeError, has `pass` body)
- Docstring: "Raised when Recall() finds no matching field in the execution trace."

**Create `bae/resolver.py`:**

Create the new module with:
- Module docstring explaining this is the field resolver for Dep and Recall annotations
- `from __future__ import annotations` at top
- Import `get_type_hints`, `get_args`, `get_origin`, `Annotated` from `typing`
- Import `Dep`, `Recall` from `bae.markers`

Implement `classify_fields(node_cls: type) -> dict[str, str]`:
- Use `get_type_hints(node_cls, include_extras=True)` to get all field hints
- For each field, check if `get_origin(hint) is Annotated`
- If Annotated, walk `get_args(hint)[1:]` looking for `isinstance(m, Dep)` or `isinstance(m, Recall)`
- Return dict mapping field name to `"dep"`, `"recall"`, or `"plain"`
- Skip the `"return"` key if present in hints

Run tests: `pytest tests/test_resolver.py -v`. All tests must PASS (GREEN).

Commit: `feat(05-01): implement v2 Dep/Recall markers, RecallError, classify_fields`
  </action>
  <verify>`pytest tests/test_resolver.py -v` shows all tests PASSING. Also run `pytest tests/ -v` to verify no existing tests broke.</verify>
  <done>Dep(callable) works, Recall() works, RecallError exists, classify_fields correctly classifies dep/recall/plain fields. All existing tests still pass.</done>
</task>

</tasks>

<verification>
```bash
# All new tests pass
pytest tests/test_resolver.py -v

# No existing tests broken
pytest tests/ -v

# Imports work
python -c "from bae.markers import Dep, Recall; from bae.exceptions import RecallError; from bae.resolver import classify_fields; print('OK')"

# v1 backward compat
python -c "from bae.markers import Dep; d = Dep(description='old'); assert d.fn is None; print('v1 compat OK')"

# v2 usage
python -c "from bae.markers import Dep; d = Dep(lambda: 42); assert d.fn is not None; print('v2 OK')"
```
</verification>

<success_criteria>
- Dep(callable) creates a marker storing the callable reference
- Dep(description="...") still works for v1 backward compatibility
- Recall() creates a parameterless marker
- RecallError inherits from BaeError
- classify_fields() correctly classifies dep, recall, and plain fields
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-markers-resolver/05-01-SUMMARY.md`
</output>
