---
phase: 05-markers-resolver
plan: 02
type: tdd
wave: 2
depends_on: ["05-01"]
files_modified:
  - bae/resolver.py
  - tests/test_resolver.py
autonomous: true

must_haves:
  truths:
    - "build_dep_dag() constructs a TopologicalSorter from Dep-annotated fields and their transitive deps"
    - "Circular dep chains raise graphlib.CycleError with human-readable function names in the message"
    - "Dep function return type mismatch (MRO check fails) raises an error naming the function and expected type"
    - "Dep functions without return type annotations raise an error at build time"
    - "Dep chaining works: dep functions with Dep-annotated params are walked transitively"
  artifacts:
    - path: "bae/resolver.py"
      provides: "build_dep_dag() and validate_node_deps() functions"
      contains: "def build_dep_dag"
    - path: "tests/test_resolver.py"
      provides: "Tests for dep DAG construction and validation"
  key_links:
    - from: "bae/resolver.py"
      to: "graphlib"
      via: "TopologicalSorter for DAG and CycleError for cycle detection"
      pattern: "graphlib\\.TopologicalSorter|graphlib\\.CycleError"
---

<objective>
Build the dependency DAG from Dep-annotated fields and validate it at graph construction time: cycle detection, return type MRO checks, and missing return type annotations.

Purpose: Build-time validation catches dep configuration errors early. The topological sort order produced here is consumed by the resolver in Plan 04.
Output: `build_dep_dag()` and `validate_node_deps()` in `bae/resolver.py`, with comprehensive TDD tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-markers-resolver/05-CONTEXT.md
@.planning/phases/05-markers-resolver/05-RESEARCH.md
@.planning/phases/05-markers-resolver/05-01-SUMMARY.md
@bae/resolver.py
@bae/markers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for dep DAG and build-time validation</name>
  <files>tests/test_resolver.py</files>
  <action>
Add new test classes to the existing `tests/test_resolver.py`.

Define test dep functions at module level (or within classes as needed):

```python
# Simple dep functions for testing
def get_location() -> str:
    return "NYC"

def get_weather(location: Annotated[str, Dep(get_location)]) -> str:
    return f"Weather in {location}"

def get_forecast(weather: Annotated[str, Dep(get_weather)]) -> str:
    return f"Forecast: {weather}"
```

For circular dep testing:
```python
def circular_a(b: Annotated[str, Dep(circular_b)]) -> str:  # type: ignore[name-defined]
    return b

def circular_b(a: Annotated[str, Dep(circular_a)]) -> str:
    return a
```
Note: Use forward reference tricks or define them carefully so Python can parse them. The simplest approach is to define `circular_b` first with a placeholder, then reassign. Or define both without Dep annotations initially, then construct `Dep` objects manually in tests. **The implementer should find the most practical approach that makes the circular reference testable.**

**Class `TestBuildDepDag`:**
- `test_single_dep`: Node with one `Dep(get_location)` field. `build_dep_dag(NodeCls)` returns a TopologicalSorter. Calling `list(ts.static_order())` includes `get_location`.
- `test_chained_deps`: Node with `Dep(get_weather)` field where `get_weather` depends on `get_location`. Static order has `get_location` before `get_weather`.
- `test_deep_chain`: Node with `Dep(get_forecast)` which chains through `get_weather` to `get_location`. Order is `get_location`, `get_weather`, `get_forecast`.
- `test_multiple_independent_deps`: Node with two independent dep fields. Both appear in static order (order between them doesn't matter).
- `test_shared_transitive_dep`: Two dep fields that both transitively depend on the same leaf function. Leaf appears only once in static order.
- `test_circular_deps_detected`: Node with circular dep chain. `build_dep_dag(NodeCls)` and then calling `ts.static_order()` (or `ts.prepare()`) raises `graphlib.CycleError`.

**Class `TestValidateNodeDeps`:**
- `test_valid_deps_no_errors`: Node with properly typed dep. `validate_node_deps(NodeCls, is_start=False)` returns empty list.
- `test_return_type_mismatch`: Dep function returns `int` but field expects `str`. Validation returns error mentioning the function name and expected type.
- `test_missing_return_annotation`: Dep function has no return type annotation (a lambda or function without `-> T`). Validation returns error naming the function.
- `test_subclass_return_type_valid`: Dep function returns a subclass of the field type. Validation returns empty list (MRO check passes).
- `test_recall_on_start_node_error`: Node with `Recall()` field, `validate_node_deps(NodeCls, is_start=True)` returns error about recall on start node.
- `test_recall_on_non_start_valid`: Same node, `validate_node_deps(NodeCls, is_start=False)` returns empty list.

Run tests: `pytest tests/test_resolver.py -v -k "TestBuildDepDag or TestValidateNodeDeps"`. All new tests must FAIL.

Commit: `test(05-02): add failing tests for dep DAG construction and validation`
  </action>
  <verify>`pytest tests/test_resolver.py -v -k "TestBuildDepDag or TestValidateNodeDeps"` shows all new tests FAILING</verify>
  <done>Tests exist for dep DAG construction (single, chained, deep chain, circular) and build-time validation (return type MRO, missing annotations, recall on start). All fail.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement build_dep_dag and validate_node_deps</name>
  <files>bae/resolver.py</files>
  <action>
Add to `bae/resolver.py`:

**`build_dep_dag(node_cls: type) -> graphlib.TopologicalSorter`:**
- Import `graphlib` at the top of the module
- Create a `TopologicalSorter` instance
- Use a `visited: set` to avoid infinite walking
- Define inner function `walk(fn)` that:
  1. Skips if `fn` already in `visited`
  2. Adds `fn` to `visited`
  3. Calls `get_type_hints(fn, include_extras=True)` to get param annotations
  4. For each param (skip `"return"`), if `get_origin(hint) is Annotated`, walk `get_args(hint)[1:]` for `Dep` instances
  5. For each found `Dep(sub_fn)`, call `ts.add(fn, sub_fn)` (fn depends on sub_fn) and recursively `walk(sub_fn)`
  6. Always `ts.add(fn)` to ensure leaf nodes are in the DAG
- Walk all Dep-annotated fields on `node_cls` to seed the DAG
- Return the `TopologicalSorter` (caller calls `static_order()` or `prepare()`)

**`validate_node_deps(node_cls: type, is_start: bool) -> list[str]`:**
- Collect errors as a list of strings
- Use `get_type_hints(node_cls, include_extras=True)` to get field annotations
- For each field with `Annotated` origin:
  - Extract `base_type = get_args(hint)[0]`
  - Walk metadata `get_args(hint)[1:]`:
    - If `isinstance(m, Recall)` and `is_start`: append error about recall on start node
    - If `isinstance(m, Dep)`:
      - Get dep function's type hints: `get_type_hints(m.fn, include_extras=True)`
      - Check `ret_type = dep_hints.get("return")`
      - If `ret_type is None`: append error about missing return annotation (use `_callable_name(m.fn)`)
      - Elif `isinstance(ret_type, type) and isinstance(base_type, type) and not issubclass(ret_type, base_type)`: append error about type mismatch
    - `break` after first marker (only process first Dep/Recall per field)
- Return errors list

**Helper `_callable_name(fn) -> str`:**
- Return `getattr(fn, "__qualname__", None) or getattr(fn, "__name__", repr(fn))`

Also attempt to build the dep DAG and catch `graphlib.CycleError` in validation:
- Call `build_dep_dag(node_cls)` inside a try/except
- On `CycleError`, format the cycle using `_callable_name` on each element in `e.args[1]`
- Append formatted cycle error to the errors list

Run tests: `pytest tests/test_resolver.py -v`. All tests must PASS.

Commit: `feat(05-02): implement dep DAG construction and build-time validation`
  </action>
  <verify>`pytest tests/test_resolver.py -v` shows all tests PASSING. `pytest tests/ -v` shows no regressions.</verify>
  <done>build_dep_dag constructs valid TopologicalSorter for dep chains. validate_node_deps catches: circular deps (with readable names), return type mismatches, missing return annotations, recall on start node. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
# All resolver tests pass
pytest tests/test_resolver.py -v

# No regressions
pytest tests/ -v

# Cycle detection works with readable names
python -c "
from bae.resolver import build_dep_dag, validate_node_deps
print('DAG and validation imported OK')
"
```
</verification>

<success_criteria>
- build_dep_dag returns a TopologicalSorter with correct dependency ordering
- Circular deps are detected and reported with human-readable function names
- Return type mismatches are caught at validation time
- Missing return type annotations are caught at validation time
- Recall on start node is caught at validation time
- Deep dep chains (3+ levels) are walked correctly
- Shared transitive deps appear only once in the DAG
</success_criteria>

<output>
After completion, create `.planning/phases/05-markers-resolver/05-02-SUMMARY.md`
</output>
