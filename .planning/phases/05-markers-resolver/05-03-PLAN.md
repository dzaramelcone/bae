---
phase: 05-markers-resolver
plan: 03
type: tdd
wave: 2
depends_on: ["05-01"]
files_modified:
  - bae/resolver.py
  - tests/test_resolver.py
autonomous: true

must_haves:
  truths:
    - "recall_from_trace walks the trace list backward and returns the first LLM-filled field value matching the target type"
    - "recall_from_trace skips Dep-annotated and Recall-annotated fields (only searches LLM-filled fields)"
    - "recall_from_trace raises RecallError when no matching field is found in the trace"
    - "recall_from_trace supports subclass matching via issubclass/MRO"
    - "When multiple nodes in trace have matching fields, the most recent (last in trace) wins"
  artifacts:
    - path: "bae/resolver.py"
      provides: "recall_from_trace() function"
      contains: "def recall_from_trace"
    - path: "tests/test_resolver.py"
      provides: "Tests for recall from trace"
  key_links:
    - from: "bae/resolver.py"
      to: "bae/exceptions.py"
      via: "raises RecallError when no match found"
      pattern: "raise RecallError"
---

<objective>
Implement the trace recall function that searches the execution trace backward for the most recent LLM-filled field matching a target type.

Purpose: Recall enables nodes to access prior LLM reasoning without explicit data passing. This is the "read" side of the implicit trace system that replaces v1's Bind marker.
Output: `recall_from_trace()` in `bae/resolver.py` with comprehensive TDD tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-markers-resolver/05-CONTEXT.md
@.planning/phases/05-markers-resolver/05-RESEARCH.md
@.planning/phases/05-markers-resolver/05-01-SUMMARY.md
@bae/resolver.py
@bae/markers.py
@bae/node.py
@bae/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for recall_from_trace</name>
  <files>tests/test_resolver.py</files>
  <action>
Add a new test class `TestRecallFromTrace` to `tests/test_resolver.py`.

Define test Node subclasses for trace testing. These nodes represent what would be in a trace after execution. Use `model_construct()` to create instances with fields populated (simulating post-execution state):

```python
# Test node types for recall testing
class VibeCheck(Node):
    mood: str
    def __call__(self, lm) -> None: ...

class WeatherReport(Node):
    temperature: int
    conditions: str
    def __call__(self, lm) -> None: ...

class DepNode(Node):
    """Node with a dep-annotated field (should be skipped by recall)."""
    external_data: Annotated[str, Dep(get_data)]
    reasoning: str
    def __call__(self, lm) -> None: ...
```

**Tests:**
- `test_recall_finds_matching_type`: Trace has `[VibeCheck(mood="happy")]`. `recall_from_trace(trace, str)` returns `"happy"`.
- `test_recall_most_recent_wins`: Trace has `[VibeCheck(mood="sad"), VibeCheck(mood="happy")]`. `recall_from_trace(trace, str)` returns `"happy"` (last node wins).
- `test_recall_searches_backward`: Trace has `[WeatherReport(temperature=72, conditions="sunny"), VibeCheck(mood="chill")]`. `recall_from_trace(trace, int)` returns `72` (found on WeatherReport).
- `test_recall_skips_dep_fields`: Create a `DepNode` with both `external_data="dep value"` and `reasoning="llm value"` (using `model_construct`). Trace has `[dep_node]`. `recall_from_trace(trace, str)` returns `"llm value"`, NOT `"dep value"` (dep field is skipped).
- `test_recall_no_match_raises_error`: Trace has `[VibeCheck(mood="ok")]`. `recall_from_trace(trace, int)` raises `RecallError`.
- `test_recall_empty_trace_raises_error`: Trace is `[]`. `recall_from_trace(trace, str)` raises `RecallError`.
- `test_recall_subclass_matching`: Define a base class `Animal` (a plain class, not a Node) and subclass `Dog(Animal)`. Define a Node with field `pet: Animal`. Populate it with a `Dog` instance. `recall_from_trace(trace, Animal)` returns the Dog instance. This tests MRO/issubclass matching.
- `test_recall_skips_recall_fields`: Define a Node with `recalled: Annotated[str, Recall()]` and `original: str`. Create instance with both populated. `recall_from_trace(trace, str)` returns value from `original`, not `recalled`.

Use `from bae.resolver import recall_from_trace` for imports.

Run tests: `pytest tests/test_resolver.py -v -k "TestRecallFromTrace"`. All new tests must FAIL.

Commit: `test(05-03): add failing tests for recall_from_trace`
  </action>
  <verify>`pytest tests/test_resolver.py -v -k "TestRecallFromTrace"` shows all new tests FAILING</verify>
  <done>Tests exist for recall: basic match, most-recent-wins, backward search, dep/recall field skipping, no-match error, empty trace error, subclass matching. All fail.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement recall_from_trace</name>
  <files>bae/resolver.py</files>
  <action>
Add to `bae/resolver.py`:

**`recall_from_trace(trace: list, target_type: type) -> object`:**
- Import `RecallError` from `bae.exceptions`
- Walk `reversed(trace)` (most recent node first)
- For each node in the trace:
  - Get `hints = get_type_hints(node.__class__, include_extras=True)`
  - For each `field_name, hint` in `hints.items()`:
    - Skip `"return"` key
    - Determine if the field is infrastructure (dep or recall annotated):
      - If `get_origin(hint) is Annotated`: check `get_args(hint)[1:]` for `isinstance(m, (Dep, Recall))`
      - If any marker found, skip this field (it's not LLM-filled)
    - Determine the base type:
      - If `Annotated`: `base_type = get_args(hint)[0]`
      - Else: `base_type = hint`
    - Check if `isinstance(base_type, type) and issubclass(base_type, target_type)`:
      - If match: get `value = getattr(node, field_name, None)`
      - If `value is not None`: return `value`
- If no match found after exhausting trace: `raise RecallError(f"No field matching {target_type.__name__} found in trace")`

**Important:** The type matching direction is `issubclass(field_type, target_type)` -- the field's type must be a subclass of (or equal to) the target type. This means if you're looking for `Animal`, a field of type `Dog` (which extends `Animal`) matches. Review the RESEARCH.md Pattern 4 for reference.

Run tests: `pytest tests/test_resolver.py -v`. All tests must PASS.

Commit: `feat(05-03): implement recall_from_trace with backward trace search`
  </action>
  <verify>`pytest tests/test_resolver.py -v` shows all tests PASSING. `pytest tests/ -v` shows no regressions.</verify>
  <done>recall_from_trace correctly searches trace backward, skips dep/recall fields, supports subclass matching, raises RecallError on no match. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
# All resolver tests pass
pytest tests/test_resolver.py -v

# No regressions
pytest tests/ -v

# Quick smoke test
python -c "from bae.resolver import recall_from_trace; print('recall_from_trace imported OK')"
```
</verification>

<success_criteria>
- recall_from_trace walks trace backward and returns first match
- Most recent node in trace wins when multiple matches exist
- Dep-annotated fields are skipped (not LLM reasoning)
- Recall-annotated fields are skipped (infrastructure)
- RecallError raised with clear message when no match found
- Subclass matching works via issubclass/MRO
- Empty trace raises RecallError
</success_criteria>

<output>
After completion, create `.planning/phases/05-markers-resolver/05-03-SUMMARY.md`
</output>
