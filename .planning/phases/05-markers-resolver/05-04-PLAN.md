---
phase: 05-markers-resolver
plan: 04
type: tdd
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - bae/resolver.py
  - bae/__init__.py
  - tests/test_resolver.py
autonomous: true

must_haves:
  truths:
    - "resolve_dep calls dep functions with resolved transitive deps injected as kwargs"
    - "Per-run dep cache keyed by callable identity prevents duplicate calls to the same dep function"
    - "Dep function runtime exceptions propagate raw (no wrapping)"
    - "resolve_fields returns a dict of {field_name: resolved_value} for all Dep and Recall fields"
    - "resolve_fields resolves fields in declaration order (deps and recalls interleaved)"
    - "Recall and Dep markers, RecallError, classify_fields, resolve_fields are exported from bae package"
  artifacts:
    - path: "bae/resolver.py"
      provides: "resolve_dep() and resolve_fields() functions"
      contains: "def resolve_fields"
    - path: "bae/__init__.py"
      provides: "Package exports for Recall, RecallError, resolve_fields, classify_fields"
    - path: "tests/test_resolver.py"
      provides: "Tests for dep resolution, caching, and resolve_fields orchestration"
  key_links:
    - from: "bae/resolver.py"
      to: "bae/resolver.py:build_dep_dag"
      via: "resolve_fields uses topological order from build_dep_dag"
      pattern: "build_dep_dag|static_order"
    - from: "bae/resolver.py"
      to: "bae/resolver.py:recall_from_trace"
      via: "resolve_fields dispatches to recall_from_trace for Recall fields"
      pattern: "recall_from_trace"
    - from: "bae/__init__.py"
      to: "bae/resolver.py"
      via: "exports resolve_fields, classify_fields"
      pattern: "from bae.resolver import"
---

<objective>
Implement dep resolution with per-run caching and the resolve_fields orchestrator that ties dep resolution and recall together, resolving all non-LLM fields in declaration order. Export new public API from bae package.

Purpose: This is the capstone of Phase 5 -- the resolver that Phase 7 will wire into Graph.run(). It combines dep DAG resolution (Plan 02) and trace recall (Plan 03) into a single entry point.
Output: `resolve_dep()`, `resolve_fields()` in `bae/resolver.py`, updated `bae/__init__.py` exports, comprehensive TDD tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-markers-resolver/05-CONTEXT.md
@.planning/phases/05-markers-resolver/05-RESEARCH.md
@.planning/phases/05-markers-resolver/05-01-SUMMARY.md
@.planning/phases/05-markers-resolver/05-02-SUMMARY.md
@.planning/phases/05-markers-resolver/05-03-SUMMARY.md
@bae/resolver.py
@bae/markers.py
@bae/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for dep resolution, caching, and resolve_fields</name>
  <files>tests/test_resolver.py</files>
  <action>
Add new test classes to `tests/test_resolver.py`.

Define module-level tracking for cache verification:

```python
call_count: dict[str, int] = {}

def tracked_get_location() -> str:
    call_count["get_location"] = call_count.get("get_location", 0) + 1
    return "NYC"

def tracked_get_weather(location: Annotated[str, Dep(tracked_get_location)]) -> str:
    call_count["get_weather"] = call_count.get("get_weather", 0) + 1
    return f"Sunny in {location}"

def failing_dep() -> str:
    raise ConnectionError("API down")
```

**Class `TestResolveDep`:**
- `test_resolve_leaf_dep`: `resolve_dep(get_location, cache={})` returns `"NYC"` and adds `get_location` to cache.
- `test_resolve_chained_dep`: `resolve_dep(get_weather, cache={})` first resolves `get_location`, then calls `get_weather(location="NYC")`. Returns weather string.
- `test_cache_prevents_duplicate_calls`: Reset `call_count`. Resolve `tracked_get_weather` twice with the same cache dict. `call_count["get_location"]` should be `1` (cached after first call).
- `test_cache_keyed_by_identity`: Resolve with pre-populated cache `{get_location: "cached"}`. `resolve_dep(get_weather, cache)` uses `"cached"` instead of calling `get_location`.
- `test_dep_exception_propagates_raw`: `resolve_dep(failing_dep, cache={})` raises `ConnectionError` directly (not wrapped).

**Class `TestResolveFields`:**
- `test_resolve_dep_field`: Node with `location: Annotated[str, Dep(get_location)]`. `resolve_fields(NodeCls, trace=[], dep_cache={})` returns `{"location": "NYC"}`.
- `test_resolve_recall_field`: Node with `mood: Annotated[str, Recall()]`. Trace contains a node with a `mood: str` field set to `"happy"`. `resolve_fields(NodeCls, trace=trace, dep_cache={})` returns `{"mood": "happy"}`.
- `test_resolve_mixed_fields`: Node with one dep field and one recall field. Both resolved correctly in a single `resolve_fields` call. Plain fields are NOT in the returned dict.
- `test_resolve_fields_declaration_order`: Node with interleaved dep and recall fields. The keys in the returned dict appear in field declaration order.
- `test_resolve_dep_caching_across_fields`: Node with two fields that depend on the same transitive dep function. Reset `call_count`, resolve fields. The shared dep is called only once.
- `test_resolve_fields_empty_for_plain_only`: Node with only plain fields. `resolve_fields` returns empty dict.
- `test_dep_cache_persists_across_calls`: Call `resolve_fields` twice for different node classes sharing the same `dep_cache` dict. Deps resolved in the first call are cached for the second.

Run tests: `pytest tests/test_resolver.py -v -k "TestResolveDep or TestResolveFields"`. All new tests must FAIL.

Commit: `test(05-04): add failing tests for dep resolution, caching, and resolve_fields`
  </action>
  <verify>`pytest tests/test_resolver.py -v -k "TestResolveDep or TestResolveFields"` shows all new tests FAILING</verify>
  <done>Tests exist for dep resolution (leaf, chained, cached, error propagation) and resolve_fields orchestration (dep, recall, mixed, declaration order, cache persistence). All fail.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement resolve_dep, resolve_fields, and update package exports</name>
  <files>bae/resolver.py, bae/__init__.py</files>
  <action>
**Add to `bae/resolver.py`:**

**`resolve_dep(fn: Callable, cache: dict) -> object`:**
- If `fn in cache`: return `cache[fn]`
- Get `hints = get_type_hints(fn, include_extras=True)`
- Build `kwargs: dict[str, object]` for the function's dep-annotated params:
  - For each param (skip `"return"`), if `get_origin(hint) is Annotated`:
    - Walk metadata for `Dep` instances
    - If found: `kwargs[param_name] = resolve_dep(m.fn, cache)` (recursive, transitive dep)
- Call `result = fn(**kwargs)`
- Store `cache[fn] = result`
- Return `result`

Note: Topological order from `build_dep_dag` guarantees no infinite recursion in a valid DAG. For resolve_dep's recursive calls, the cache short-circuits already-resolved deps. If the DAG is invalid (has cycles), that's caught at build time by `validate_node_deps`, not here.

**`resolve_fields(node_cls: type, trace: list, dep_cache: dict) -> dict[str, object]`:**
- `resolved: dict[str, object] = {}`
- Get `hints = get_type_hints(node_cls, include_extras=True)`
- For each `field_name, hint` in `hints.items()`:
  - Skip `"return"` key
  - If `get_origin(hint) is not Annotated`: continue (plain field)
  - Walk `get_args(hint)[1:]`:
    - If `isinstance(m, Dep)`:
      - `resolved[field_name] = resolve_dep(m.fn, dep_cache)`
      - `break`
    - If `isinstance(m, Recall)`:
      - `base_type = get_args(hint)[0]`
      - `resolved[field_name] = recall_from_trace(trace, base_type)`
      - `break`
- Return `resolved`

**Update `bae/__init__.py`:**

Add imports and exports for:
- `from bae.markers import Recall` (add to existing Dep import)
- `from bae.exceptions import RecallError` (add to existing exception imports)
- `from bae.resolver import classify_fields, resolve_fields`
- Add `"Recall"`, `"RecallError"`, `"classify_fields"`, `"resolve_fields"` to `__all__`

Run tests: `pytest tests/test_resolver.py -v`. All tests must PASS.
Run full suite: `pytest tests/ -v`. No regressions.

Commit: `feat(05-04): implement resolve_dep, resolve_fields, and export public API`
  </action>
  <verify>`pytest tests/test_resolver.py -v` shows all tests PASSING. `pytest tests/ -v` shows no regressions. `python -c "from bae import Recall, RecallError, classify_fields, resolve_fields; print('exports OK')"` succeeds.</verify>
  <done>resolve_dep handles leaf deps, chained deps, and caching by callable identity. resolve_fields orchestrates dep + recall resolution in field declaration order. Dep exceptions propagate raw. All Phase 5 resolver functions are exported from bae package. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
# All resolver tests pass
pytest tests/test_resolver.py -v

# No regressions
pytest tests/ -v

# Package exports work
python -c "
from bae import Recall, RecallError, classify_fields, resolve_fields
from bae import Dep  # Still works
print('All Phase 5 exports OK')
"

# Quick integration smoke test
python -c "
from typing import Annotated
from bae import Node, Dep, Recall, resolve_fields

def get_data() -> str:
    return 'hello'

class TestNode(Node):
    data: Annotated[str, Dep(get_data)]
    name: str
    def __call__(self, lm) -> None: ...

result = resolve_fields(TestNode, trace=[], dep_cache={})
assert result == {'data': 'hello'}, f'Expected data=hello, got {result}'
print('Smoke test PASSED')
"
```
</verification>

<success_criteria>
- resolve_dep calls dep functions with correct kwargs from transitive dep resolution
- Per-run cache prevents duplicate dep function calls (keyed by callable identity)
- Cache persists across multiple resolve_fields calls when same dict is passed
- Dep function exceptions propagate raw (ConnectionError stays ConnectionError)
- resolve_fields returns dict of resolved Dep and Recall field values only
- Plain fields are excluded from resolve_fields output
- Fields resolve in declaration order
- Recall, RecallError, classify_fields, resolve_fields exported from bae package
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-markers-resolver/05-04-SUMMARY.md`
</output>
