---
phase: 16-channel-io
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/repl/channels.py
  - tests/repl/test_channels.py
autonomous: true

must_haves:
  truths:
    - "Channel.write() records to SessionStore with correct mode/channel/direction"
    - "Channel.write() buffers all content regardless of visibility"
    - "Channel._display() renders color-coded prefix via print_formatted_text"
    - "ChannelRouter.write() dispatches to the named channel"
    - "ChannelRouter attribute access returns channels (router.py, router.graph)"
    - "ChannelRouter.visible returns only visible channel names"
    - "Debug handler receives all writes when enabled"
  artifacts:
    - path: "bae/repl/channels.py"
      provides: "Channel, ChannelRouter, CHANNEL_DEFAULTS, enable_debug, disable_debug, toggle_channels"
      contains: "class Channel"
    - path: "tests/repl/test_channels.py"
      provides: "Unit tests for Channel and ChannelRouter"
      contains: "test_channel_write_records_to_store"
  key_links:
    - from: "bae/repl/channels.py"
      to: "bae/repl/store.py"
      via: "Channel.write() calls store.record()"
      pattern: "self\\.store\\.record"
---

<objective>
Build the Channel and ChannelRouter classes with TDD -- the output multiplexing layer that wraps display + persistence into a single write() call.

Purpose: Channels are the core abstraction for Phase 16. Every subsequent task (shell wiring, graph wrapper, debug logging, TUI toggle) depends on these classes existing and being correct.
Output: `bae/repl/channels.py` with Channel, ChannelRouter, CHANNEL_DEFAULTS, debug helpers, toggle function. Full test suite.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-channel-io/16-RESEARCH.md
@bae/repl/store.py
@bae/repl/modes.py
</context>

<feature>
  <name>Channel and ChannelRouter output multiplexing</name>
  <files>bae/repl/channels.py, tests/repl/test_channels.py</files>
  <behavior>
    Channel is a dataclass with name, color, visible, store, _buffer fields.
    - Channel.write(content, mode="", direction="output", metadata=None) -> always records to store (if store set), always appends to _buffer, displays only if visible
    - Channel._display(content) -> renders each line with FormattedText([('color bold', '[name]'), ('', ' '), ('', line)]) via print_formatted_text
    - Channel.label -> "[name]"
    - Channel.__repr__ -> 'Channel("name", visible/hidden, N entries)'

    ChannelRouter is a dataclass with _channels dict and debug_handler.
    - register(name, color, store=None) -> creates Channel, stores in _channels, returns it
    - write(channel, content, **kwargs) -> dispatches to _channels[channel].write(**kwargs), also emits to debug_handler if set
    - __getattr__(name) -> returns _channels[name] for namespace access (router.py, router.graph)
    - visible -> list of visible channel names
    - all -> list of all channel names

    CHANNEL_DEFAULTS = dict mapping channel names to colors:
      py: #87ff87, graph: #ffaf87, ai: #87d7ff, bash: #d7afff, debug: #808080

    enable_debug(router, log_dir=None) -> attaches FileHandler to router.debug_handler writing to .bae/debug.log
    disable_debug(router) -> closes and removes debug_handler

    toggle_channels(router) -> async function using checkboxlist_dialog(...).run_async() for TUI visibility toggle

    Cases:
      Channel.write("hello", mode="PY") with visible=True -> store.record called, buffer has "hello", display called
      Channel.write("hello", mode="PY") with visible=False -> store.record called, buffer has "hello", display NOT called
      ChannelRouter.write("py", "hello") -> delegates to py channel
      ChannelRouter.write("nonexistent", "x") -> no-op (no error)
      router.py -> returns Channel("py", ...)
      router.nonexistent -> raises AttributeError
      router.visible with py visible and bash hidden -> ["py", ...] without "bash"
      enable_debug(router, tmp_dir) -> router.debug_handler is FileHandler
      disable_debug(router) -> router.debug_handler is None
  </behavior>
  <implementation>
    Create bae/repl/channels.py with:

    1. Channel dataclass using @dataclass. Fields: name (str), color (str), visible (bool, default True), store (SessionStore | None, default None), _buffer (list[str], field(default_factory=list, repr=False)).
       - Use TYPE_CHECKING guard for SessionStore import.
       - write() method: calls self.store.record(mode or self.name.upper(), self.name, direction, content, metadata) if store exists, appends content to _buffer, calls _display(content) only if self.visible.
       - _display() method: splits content on newlines, for each line creates FormattedText tuple with (f'{self.color} bold', self.label), ('', ' '), ('', line), calls print_formatted_text.
       - label property returns f"[{self.name}]".
       - __repr__ returns f'Channel({self.name!r}, {"visible" if self.visible else "hidden"}, {len(self._buffer)} entries)'.

    2. ChannelRouter dataclass. Fields: _channels (dict[str, Channel], field(default_factory=dict, repr=False)), debug_handler (logging.FileHandler | None, field(default=None, repr=False)).
       - register() creates Channel, stores in _channels, returns it.
       - write() looks up channel in _channels, calls ch.write(content, **kwargs). If debug_handler set, creates LogRecord and emits.
       - __getattr__ for names not starting with _ returns _channels[name] or raises AttributeError.
       - visible property: list comprehension of names where ch.visible is True.
       - all property: list of _channels keys.

    3. CHANNEL_DEFAULTS dict at module level.

    4. enable_debug(router, log_dir=None) -> creates FileHandler at (log_dir or Path.cwd()/".bae")/"debug.log" with timestamp formatter, assigns to router.debug_handler.

    5. disable_debug(router) -> closes handler if exists, sets to None.

    6. async toggle_channels(router) -> uses checkboxlist_dialog with values=[(name, f"[{name}] channel") for name in router.all], default_values=router.visible. Result updates visibility. None result = cancelled (no change).

    Match existing code style: from __future__ import annotations, TYPE_CHECKING guards, absolute imports, Google-style docstrings.
  </implementation>
</feature>

<verification>
```bash
cd /Users/dzaramelcone/lab/bae && python -m pytest tests/repl/test_channels.py -v
```
All tests pass. No regressions in existing tests:
```bash
python -m pytest tests/ -x -q
```
</verification>

<success_criteria>
- Channel.write() records to store, buffers, and conditionally displays
- ChannelRouter dispatches writes and supports attribute access
- Debug handler captures all channel output to file
- toggle_channels function exists (full integration tested in Plan 02)
- All tests pass including existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/16-channel-io/16-01-SUMMARY.md`
</output>
