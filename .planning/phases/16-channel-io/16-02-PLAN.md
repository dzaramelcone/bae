---
phase: 16-channel-io
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - bae/repl/shell.py
  - bae/repl/bash.py
  - tests/repl/test_store_integration.py
autonomous: true

must_haves:
  truths:
    - "All PY mode output goes through router.write('py', ...) instead of print() + store.record()"
    - "All BASH mode output goes through router.write('bash', ...) instead of print() + store.record()"
    - "NL and GRAPH stubs route output through their channels"
    - "channels object is accessible in the REPL namespace"
    - "Ctrl+O opens the channel visibility toggle dialog"
    - "Graph wrapper captures bae.graph logger output through [graph] channel"
    - "Bash output displays with color-coded [bash] prefix"
    - "Input recording still goes through store.record() directly (channels are output-only)"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "CortexShell with ChannelRouter integration"
      contains: "self.router"
    - path: "bae/repl/bash.py"
      provides: "dispatch_bash returning raw (stdout, stderr) without printing"
      contains: "dispatch_bash"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/channels.py"
      via: "CortexShell creates ChannelRouter, calls router.write()"
      pattern: "self\\.router\\.write"
    - from: "bae/repl/shell.py"
      to: "bae/repl/channels.py"
      via: "Ctrl+O keybinding calls toggle_channels()"
      pattern: "toggle_channels"
---

<objective>
Wire the channel system into CortexShell -- replace all direct print()/store.record() output calls with router.write(), add the Ctrl+O channel toggle keybinding, update bash.py to return raw data (caller handles display), and add the graph wrapper.

Purpose: This connects the channel abstraction (Plan 01) to the running REPL, completing all five CHAN requirements.
Output: Modified shell.py, bash.py, updated integration tests.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-channel-io/16-RESEARCH.md
@.planning/phases/16-channel-io/16-01-SUMMARY.md
@bae/repl/shell.py
@bae/repl/bash.py
@bae/repl/store.py
@bae/repl/channels.py
@bae/repl/exec.py
@bae/graph.py
@tests/repl/test_store_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ChannelRouter into CortexShell and update bash.py</name>
  <files>bae/repl/shell.py, bae/repl/bash.py</files>
  <action>
    **bash.py changes:**
    Remove the `print()` and `print_formatted_text()` calls from `dispatch_bash()`. The function should ONLY return `(stdout, stderr)` -- the caller (shell.py) is now responsible for display via channels. Keep the `cd` special-case logic but remove its `print_formatted_text` call too -- return the error string in stderr position instead.

    **shell.py changes:**

    1. Add imports: `from bae.repl.channels import ChannelRouter, CHANNEL_DEFAULTS, toggle_channels`

    2. In `CortexShell.__init__()`:
       - Create `self.router = ChannelRouter()`
       - Register all channels from CHANNEL_DEFAULTS: `for name, cfg in CHANNEL_DEFAULTS.items(): self.router.register(name, cfg["color"], store=self.store)`
       - Add `self.namespace["channels"] = self.router`

    3. In `_build_key_bindings()`, add a new keybinding:
       ```python
       @kb.add("c-o")
       def open_channel_toggle(event):
           """Ctrl+O opens channel visibility toggle."""
           async def _toggle():
               await toggle_channels(shell.router)
               event.app.invalidate()
           event.app.create_background_task(_toggle())
       ```

    4. Replace output handling in the REPL loop (inside `run()`):

       **PY mode** -- replace `print(captured, end="")` + `store.record(...)` with `self.router.write("py", captured, mode="PY", metadata={"type": "stdout"})`. Same pattern for result and error output. Remove the bare `print()` calls for py output.
       - captured stdout: `self.router.write("py", captured.rstrip("\n"), mode="PY", metadata={"type": "stdout"})`
       - expr result: `self.router.write("py", output, mode="PY", metadata={"type": "expr_result"})`
       - error: `self.router.write("py", tb.rstrip("\n"), mode="PY", metadata={"type": "error"})`

       **BASH mode** -- replace `store.record()` with `router.write()`:
       - stdout: `self.router.write("bash", stdout.rstrip("\n"), mode="BASH")`
       - stderr: `self.router.write("bash", stderr.rstrip("\n"), mode="BASH", metadata={"type": "stderr"})`

       **NL mode** -- replace `print(stub)` + `store.record()` with:
       - `self.router.write("ai", stub, mode="NL")`

       **GRAPH mode** -- replace `print(stub)` + `store.record()` with:
       - `self.router.write("graph", stub, mode="GRAPH")`

    5. Input recording stays as `self.store.record(...)` -- channels are for output only.

    6. Update `_shutdown()`: replace bare `print()` with `self.router.write("debug", ...)` for the "cancelled N tasks" message.

    7. Add `channel_arun()` as an async function in shell.py (or channels.py -- whichever is cleaner, but shell.py has access to the router). Implementation:
       ```python
       async def channel_arun(graph, start_node, router, *, lm=None, max_iters=10):
           """Wrap graph.arun() routing output through [graph] channel."""
           import logging
           from io import StringIO
           graph_logger = logging.getLogger("bae.graph")
           buf = StringIO()
           handler = logging.StreamHandler(buf)
           handler.setFormatter(logging.Formatter("%(name)s: %(message)s"))
           graph_logger.addHandler(handler)
           old_level = graph_logger.level
           graph_logger.setLevel(logging.DEBUG)
           try:
               result = await graph.arun(start_node, lm=lm, max_iters=max_iters)
           finally:
               graph_logger.removeHandler(handler)
               graph_logger.setLevel(old_level)
           captured = buf.getvalue()
           if captured:
               router.write("graph", captured.rstrip(), mode="GRAPH", metadata={"type": "log"})
           if result and result.trace:
               terminal = result.trace[-1]
               router.write("graph", repr(terminal), mode="GRAPH", metadata={"type": "result"})
           return result
       ```

    8. Update the GRAPH mode handler: if `self.namespace.get("graph")` exists, call `await channel_arun(graph, ...)`. Otherwise keep the stub message but route through the graph channel.

    **What to avoid:**
    - Do NOT use bare `print()` for any channel-routed output. All output must go through `router.write()` which calls `print_formatted_text()` internally.
    - Do NOT call `store.record()` for output that goes through channels -- the channel's `write()` already calls `store.record()`.
    - Do NOT modify `bae/graph.py` -- wrapper pattern only.
    - Do NOT change how `async_exec` works -- it still returns (result, captured_stdout). The shell routes captured_stdout through the channel after async_exec returns.
  </action>
  <verify>
    ```bash
    cd /Users/dzaramelcone/lab/bae && python -m pytest tests/repl/ -v -x
    ```
    All existing tests pass (test_exec.py, test_store.py, test_store_integration.py, test_channels.py).
    Manual smoke test: `python -c "from bae.repl.channels import ChannelRouter, CHANNEL_DEFAULTS; print('import ok')"` succeeds.
  </verify>
  <done>
    - All output in shell.py routes through router.write() -- no bare print() for mode output
    - bash.py returns raw data without printing
    - Ctrl+O keybinding registered
    - channel_arun wrapper function exists
    - channels object in namespace
    - Input recording still uses store.record() directly
  </done>
</task>

<task type="auto">
  <name>Task 2: Update integration tests for channel-routed output</name>
  <files>tests/repl/test_store_integration.py</files>
  <action>
    Read the existing test_store_integration.py and update any tests that assert on direct store.record() patterns if they now go through channels.

    The integration tests likely test that mode output ends up in the store. Since channel.write() calls store.record() internally, the store assertions should still pass -- but the metadata or channel names may differ slightly.

    Also add new integration-level tests:
    1. **test_channel_output_in_store**: Create a ChannelRouter with a real SessionStore (tmp_path), register a channel, write through it, verify the entry appears in store with correct channel name and content.
    2. **test_channels_in_namespace**: Create a CortexShell (or mock enough of it), verify `shell.namespace["channels"]` is a ChannelRouter instance.
    3. **test_channel_visibility_toggle**: Create a router with channels, set one to hidden, verify router.visible excludes it.
    4. **test_debug_logging_writes_file**: Enable debug, write through router, disable debug, read the debug log file and verify content is present.
    5. **test_bash_dispatch_no_print**: Call dispatch_bash("echo hello"), verify it returns ("hello\n", "") without printing (mock print to confirm no calls).

    Match existing test style: pytest fixtures, Google-style docstrings on each test, tmp_path for filesystem.
  </action>
  <verify>
    ```bash
    cd /Users/dzaramelcone/lab/bae && python -m pytest tests/repl/ -v
    cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -x -q
    ```
    All tests pass including the new integration tests. Full suite green with no regressions.
  </verify>
  <done>
    - Integration tests verify channel output ends up in SessionStore
    - Debug logging to file verified
    - bash.py no-print behavior verified
    - Full test suite passes (0 failures)
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -v --tb=short

# Import check -- channels module loads cleanly
python -c "from bae.repl.channels import Channel, ChannelRouter, CHANNEL_DEFAULTS, enable_debug, disable_debug, toggle_channels; print('All exports OK')"

# Shell creates router
python -c "
from unittest.mock import patch
with patch('bae.repl.shell.PromptSession'):
    from bae.repl.shell import CortexShell
    s = CortexShell()
    assert hasattr(s, 'router')
    assert 'channels' in s.namespace
    print('Shell integration OK')
"

# Ruff lint passes
python -m ruff check bae/repl/channels.py bae/repl/shell.py bae/repl/bash.py
```
</verification>

<success_criteria>
- Every mode's output routes through router.write() with color-coded channel prefix (CHAN-01)
- toggle_channels() wired to Ctrl+O keybinding (CHAN-02)
- channels accessible as namespace object with attribute access (CHAN-03)
- Debug logging to file works via enable_debug/disable_debug (CHAN-04)
- channel_arun wraps graph.arun() without modifying bae source (CHAN-05)
- All existing tests pass -- no regressions
- All new integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-channel-io/16-02-SUMMARY.md`
</output>
