---
phase: 27-graph-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/graph.py
  - bae/__init__.py
  - bae/repl/engine.py
  - examples/ootd.py
  - tests/test_graph.py
  - tests/repl/test_engine.py
autonomous: true

must_haves:
  truths:
    - "graph() factory returns an async callable with typed signature derived from start node required plain fields"
    - "Calling the returned callable executes the graph and returns GraphResult"
    - "The callable's __signature__ matches the start node's required fields for introspection"
    - "examples/ootd.py exports ootd as a free-standing async callable, not a Graph instance"
    - "Engine can submit pre-built coroutines via submit_coro() with lifecycle tracking"
    - "GraphRun stores GraphResult after successful completion for inspect/trace"
  artifacts:
    - path: "bae/graph.py"
      provides: "graph() factory function returning async callable"
      contains: "def graph"
    - path: "bae/__init__.py"
      provides: "graph exported from bae package"
      contains: "graph"
    - path: "bae/repl/engine.py"
      provides: "submit_coro() method and GraphRun.result field"
      contains: "submit_coro"
    - path: "examples/ootd.py"
      provides: "ootd as free-standing async callable"
      contains: "ootd = graph("
    - path: "tests/test_graph.py"
      provides: "Tests for graph() factory"
      contains: "test_graph_factory"
    - path: "tests/repl/test_engine.py"
      provides: "Tests for submit_coro and result storage"
      contains: "test_submit_coro"
  key_links:
    - from: "bae/graph.py"
      to: "bae/__init__.py"
      via: "export"
      pattern: "from bae.graph import.*graph"
    - from: "examples/ootd.py"
      to: "bae/graph.py"
      via: "import and call graph()"
      pattern: "from bae import.*graph"
    - from: "bae/repl/engine.py"
      to: "bae/graph.py"
      via: "submit_coro wraps callable output"
      pattern: "submit_coro"
---

<objective>
Create the `graph()` factory function that returns free-standing async callables, and extend the engine to support coroutine submission and result storage.

Purpose: This is the foundational API redesign for Phase 27. `graph()` produces typed async callables from node classes, hiding Graph/Node internals from clients. Engine enhancements (submit_coro, result storage) enable GRAPH mode commands in Plan 02.

Output: `graph()` factory exported from `bae`, `examples/ootd.py` updated, engine ready for coroutine submission, all tests passing.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-graph-mode/27-RESEARCH.md
@bae/graph.py
@bae/__init__.py
@bae/repl/engine.py
@examples/ootd.py
@tests/test_graph.py
@tests/repl/test_engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: graph() factory function and ootd.py migration</name>
  <files>bae/graph.py, bae/__init__.py, examples/ootd.py, tests/test_graph.py</files>
  <action>
Create a module-level `graph()` factory function in `bae/graph.py`. This is NOT a method on Graph class -- it is a standalone function that IS the public API.

**`graph()` factory (in bae/graph.py):**

```python
def graph(start: type[Node]) -> ...:
```

1. Internally creates `Graph(start=start)` to discover topology and compute `_input_fields`
2. Defines an inner async function whose parameters are derived from the Graph's `_input_fields` dict
3. The inner function calls `g.arun(lm=lm, dep_cache=dep_cache, **kwargs)` and returns `GraphResult`
4. The inner function also accepts optional `lm` and `dep_cache` keyword-only params (defaulting to None)
5. Builds a proper `inspect.Signature` from the `_input_fields` FieldInfo objects (use `inspect.Parameter` with name, annotation from field's `annotation`, kind=KEYWORD_ONLY) and sets it on the inner function via `wrapper.__signature__`
6. Sets `wrapper.__name__` to the start class name (lowercased or original -- match examples/ootd.py pattern: `ootd = graph(start=IsTheUserGettingDressed)`)
7. Sets `wrapper.__doc__` to something like `f"Run {start.__name__} graph."`
8. Stores the internal Graph on the wrapper as `wrapper._graph` so the engine can access topology for display (e.g., `ootd._graph.start.__name__`)
9. Returns the wrapper

**Key implementation detail for the signature:** Use `inspect.Parameter` objects built from `Graph._input_fields`. For each `(name, field_info)` pair:
- `annotation` = field_info.annotation
- `kind` = `inspect.Parameter.KEYWORD_ONLY` (all params are keyword-only to match arun's **kwargs pattern)
- `default` = `inspect.Parameter.empty` (they are required fields)

Then append `lm` and `dep_cache` as keyword-only params with default=None.

**Export from `bae/__init__.py`:**
Add `graph` (lowercase) to imports and `__all__`. Import: `from bae.graph import Graph, graph`.

**Update `examples/ootd.py`:**
Change the bottom of the file:
```python
# Old:
graph = Graph(start=IsTheUserGettingDressed)
if __name__ == "__main__":
    result = graph.run(...)

# New:
from bae import graph  # (already importing from bae at top)

ootd = graph(start=IsTheUserGettingDressed)

if __name__ == "__main__":
    import asyncio
    result = asyncio.run(ootd(user_info=UserInfo(), user_message="ugh i just got up"))
    print(result.trace[-1].model_dump_json(indent=2))
```

Note: The existing `from bae import Dep, Graph, Node, Recall` line needs `graph` added (lowercase). Keep `Graph` in the import too since cli.py still uses it internally. But `examples/ootd.py` should import `graph` (the factory function) from bae.

**Tests in `tests/test_graph.py`:**
Add a new test class `TestGraphFactory` with:
- `test_graph_factory_returns_callable`: `fn = graph(start=DepStart)` -- fn is callable, asyncio.iscoroutinefunction(fn) is True
- `test_graph_factory_signature`: `fn = graph(start=Start)` -- `inspect.signature(fn)` has a `query` parameter of kind KEYWORD_ONLY
- `test_graph_factory_executes`: `fn = graph(start=DepStart)` -- `result = await fn()` returns GraphResult (DepStart has no required plain fields... actually it does: greeting is a Dep, not plain. DepStart has zero required plain fields since greeting is Dep-annotated. So `await fn()` should work with no args). Actually wait -- we need a start node with required plain fields. Use `Start` which has `query: str`. So: `result = await fn(query="hello", lm=MockV2LM())` returns GraphResult. But Start has custom __call__ that uses lm.decide. Actually check: Start's `__call__` is `async def __call__(self, lm: LM) -> Process | Clarify`. This uses the old v1 pattern. For a clean test, create a new simple node pair:

```python
class FactoryStart(Node):
    message: str
    def __call__(self) -> FactoryEnd: ...

class FactoryEnd(Node):
    reply: str
```

Then: `fn = graph(start=FactoryStart)`. `sig = inspect.signature(fn)` has `message` param. `result = await fn(message="hi", lm=MockV2LM())` returns GraphResult with 2 nodes in trace.

- `test_graph_factory_has_internal_graph`: `fn = graph(start=FactoryStart)` -- `fn._graph` is a Graph instance
- `test_graph_factory_missing_field_raises`: `fn = graph(start=FactoryStart)` -- `await fn(lm=MockV2LM())` raises TypeError mentioning "message"
- `test_graph_factory_name`: `fn = graph(start=FactoryStart)` -- `fn.__name__ == "FactoryStart"`

Note: Use `MockV2LM` from the existing test file (already defined there for dep_cache tests). It fills by constructing from resolved dict which is what ellipsis-body nodes need.
  </action>
  <verify>
`uv run pytest tests/test_graph.py -x -q` -- all tests pass including new TestGraphFactory tests.
`uv run python -c "from bae import graph; print(graph)"` -- imports without error.
`uv run python -c "import inspect; from examples.ootd import ootd; print(inspect.signature(ootd))"` -- shows signature with user_info, user_message params.
  </verify>
  <done>
`graph()` factory in bae/graph.py creates async callables with typed signatures. Exported from bae package. examples/ootd.py uses `ootd = graph(start=IsTheUserGettingDressed)`. All existing + new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Engine submit_coro and GraphRun result storage</name>
  <files>bae/repl/engine.py, tests/repl/test_engine.py</files>
  <action>
**GraphRun.result field (in engine.py):**
Add `result: GraphResult | None = None` to the GraphRun dataclass (after the `error` field). This stores the graph execution result for inspect/trace commands.

**Store result in _execute (in engine.py):**
In `GraphRegistry._execute()`, after the `await run.graph.arun(...)` call returns `result`, add `run.result = result` before setting `run.state = GraphState.DONE`. This way inspect/trace can access the full trace.

**submit_coro method (in engine.py):**
Add `submit_coro()` to GraphRegistry:

```python
def submit_coro(
    self, coro, tm: TaskManager, *, name: str = "graph",
) -> GraphRun:
    """Submit a pre-built coroutine as a managed graph run.

    Used when `run <expr>` evaluates to an already-constructed coroutine
    (e.g., `ootd(user_info=..., user_message=...)`). The coroutine is
    wrapped with lifecycle tracking but TimingLM cannot be injected
    since the LM is already bound inside the coroutine.
    """
    run_id = f"g{self._next_id}"
    self._next_id += 1
    run = GraphRun(run_id=run_id, graph=None)
    self._runs[run_id] = run
    wrapped = self._wrap_coro(run, coro)
    tm.submit(wrapped, name=f"graph:{run_id}:{name}", mode="graph")
    return run
```

Add `_wrap_coro` as an async method:

```python
async def _wrap_coro(self, run: GraphRun, coro):
    """Wrap a coroutine with lifecycle tracking."""
    try:
        result = await coro
        run.state = GraphState.DONE
        # Store result if it's a GraphResult
        if hasattr(result, 'trace'):
            run.result = result
        return result
    except asyncio.CancelledError:
        run.state = GraphState.CANCELLED
        raise
    except Exception as e:
        run.state = GraphState.FAILED
        run.error = f"{type(e).__name__}: {e}"
        raise
    finally:
        run.ended_ns = time.perf_counter_ns()
        self._archive(run)
```

Note: `graph` field on GraphRun becomes `graph: Graph | None` since submit_coro may not have a Graph reference. Update the type hint. The existing `submit()` always passes a Graph, so no breakage.

Also update the TYPE_CHECKING import to include GraphResult:
```python
if TYPE_CHECKING:
    from bae.graph import Graph
    from bae.result import GraphResult
```

And update GraphRun type annotation:
```python
@dataclass
class GraphRun:
    run_id: str
    graph: Graph | None
    state: GraphState = GraphState.RUNNING
    ...
    result: GraphResult | None = None
```

**Tests in tests/repl/test_engine.py:**
Add to TestGraphRegistry:

- `test_submit_coro_creates_running_graphrun`: Create a simple coroutine `async def fake(): return "done"`. `run = registry.submit_coro(fake(), tm, name="test")`. Verify `run.state == GraphState.RUNNING`, `run.run_id == "g1"`.

- `test_submit_coro_completes_to_done`: Submit a coroutine that returns something, await the task, verify `run.state == GraphState.DONE`.

- `test_submit_coro_failure_sets_failed`: Submit a coroutine that raises, verify `run.state == GraphState.FAILED` and `run.error` contains the exception message.

- `test_submit_coro_cancellation`: Submit a slow coroutine, revoke, verify CANCELLED.

- `test_execute_stores_result`: Submit a graph via `submit()` (existing pattern with MockLM), await completion, verify `run.result is not None` and `run.result.trace` has entries.

- `test_submit_coro_stores_graphresult`: Submit a coroutine that returns a GraphResult, verify `run.result` is set.
  </action>
  <verify>
`uv run pytest tests/repl/test_engine.py -x -q` -- all tests pass including new ones.
`uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite passes.
  </verify>
  <done>
GraphRun stores GraphResult after completion. submit_coro() accepts pre-built coroutines with full lifecycle tracking. Engine ready for GRAPH mode commands to submit callable results and inspect completed runs.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_graph.py tests/repl/test_engine.py -x -q` -- all pass
2. `uv run python -c "from bae import graph; print(graph)"` -- factory is importable
3. `uv run python -c "import inspect; from examples.ootd import ootd; sig = inspect.signature(ootd); print(sig); assert 'user_info' in sig.parameters; assert 'user_message' in sig.parameters"` -- ootd has correct signature
4. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite, no regressions
</verification>

<success_criteria>
- graph() factory creates async callables with introspectable typed signatures
- examples/ootd.py exports `ootd` as a callable, not a Graph
- Engine stores GraphResult on completed runs for inspection
- Engine accepts pre-built coroutines via submit_coro()
- All existing tests continue to pass
- New tests cover factory behavior and engine enhancements
</success_criteria>

<output>
After completion, create `.planning/phases/27-graph-mode/27-01-SUMMARY.md`
</output>
