---
phase: 20-ai-eval-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - bae/repl/channels.py
  - bae/repl/shell.py
  - bae/repl/toolbar.py
  - tests/repl/test_channels.py
  - tests/repl/test_task_lifecycle.py
autonomous: true

must_haves:
  truths:
    - "AI output renders markdown formatting (headers, bold, code blocks, lists) in the terminal"
    - "Ctrl-C task menu renders as a numbered list printed to scrollback, not in the toolbar"
  artifacts:
    - path: "bae/repl/channels.py"
      provides: "render_markdown() function and markdown-aware Channel._display"
      contains: "render_markdown"
    - path: "bae/repl/shell.py"
      provides: "Task menu prints to scrollback on Ctrl-C"
      contains: "print_formatted_text"
    - path: "bae/repl/toolbar.py"
      provides: "render_task_menu still exists for reference but menu prints to scrollback"
  key_links:
    - from: "bae/repl/channels.py"
      to: "rich.markdown.Markdown"
      via: "render_markdown function"
      pattern: "Console.*force_terminal.*True"
    - from: "bae/repl/channels.py"
      to: "prompt_toolkit ANSI"
      via: "print_formatted_text(ANSI(...))"
      pattern: "ANSI"
---

<objective>
Add Rich-based markdown rendering for AI channel output and move the Ctrl-C task menu from the toolbar to scrollback.

Purpose: SC6 (markdown rendering) and SC7 (task menu in scrollback) are display-layer changes independent of the eval loop and multi-session work.
Output: AI responses render with formatted headers, bold, code blocks, and lists. Task menu prints above the prompt as permanent scrollback.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-ai-eval-loop/20-RESEARCH.md

@bae/repl/channels.py
@bae/repl/shell.py
@bae/repl/toolbar.py
@tests/repl/test_channels.py
@tests/repl/test_task_lifecycle.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rich markdown rendering for AI channel output</name>
  <files>pyproject.toml, bae/repl/channels.py, tests/repl/test_channels.py</files>
  <action>
1. Add `"rich>=14.3"` to dependencies in pyproject.toml. Run `uv lock` to update the lockfile.

2. In `bae/repl/channels.py`, add a `render_markdown(text, width)` function:
   - Import `StringIO` from `io`, `Console` from `rich.console`, `Markdown` from `rich.markdown`
   - Create `Console(file=buf, width=width, force_terminal=True)` — `force_terminal=True` is CRITICAL because Rich strips ANSI when writing to StringIO otherwise
   - `console.print(Markdown(text))`
   - Return `buf.getvalue()`
   - Default `width` from `os.get_terminal_size().columns` (detect per-render for terminal resize handling)

3. Add a `markdown` flag to `Channel.__init__` (default `False`). Set it in the `CHANNEL_DEFAULTS` dict for the `"ai"` channel only: `"ai": {"color": "#87d7ff", "markdown": True}`.

4. Update `ChannelRouter.register()` to accept and pass through the `markdown` parameter.

5. Update `Channel._display()`:
   - If `self.markdown` is True: call `render_markdown(content)`, then `print_formatted_text(ANSI(ansi_text))`. Import `ANSI` from `prompt_toolkit.formatted_text`. Print channel label on its own line before the rendered content.
   - If `self.markdown` is False: existing line-by-line display (no change).
   - Process the ENTIRE response as one markdown block — do NOT split on newlines first. Markdown headers, code blocks, and lists span multiple lines.

6. Add tests in `tests/repl/test_channels.py`:
   - `test_render_markdown_basic`: verify `render_markdown("# Hello\n**bold**")` returns a non-empty string containing ANSI escape codes (`\x1b[`)
   - `test_render_markdown_code_block`: verify code blocks render (contains the code text)
   - `test_channel_markdown_flag`: create Channel with markdown=True, verify flag is set
   - `test_channel_defaults_ai_markdown`: verify CHANNEL_DEFAULTS["ai"] has "markdown": True
   - `test_non_markdown_channel_display`: verify Channel with markdown=False still does line-by-line display (mock print_formatted_text, check calls)
  </action>
  <verify>
`uv run pytest tests/repl/test_channels.py -v` — all tests pass including new markdown tests.
`uv run python -c "from bae.repl.channels import render_markdown; print(repr(render_markdown('# Test\n**bold**')))"` — output contains ANSI escape sequences.
  </verify>
  <done>render_markdown() converts markdown to ANSI via Rich. AI channel uses markdown rendering. Non-AI channels unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Task menu in scrollback instead of toolbar</name>
  <files>bae/repl/shell.py, tests/repl/test_task_lifecycle.py</files>
  <action>
1. In `bae/repl/shell.py`, update the `handle_interrupt` key binding (Ctrl-C, the case where tasks are running and menu is not yet open):
   - Instead of just setting `shell._task_menu = True` and relying on toolbar render, PRINT the task list to scrollback using `print_formatted_text`.
   - For each active task, print a FormattedText line: yellow bold number + task name (same visual as render_task_menu but printed, not returned).
   - Print a hint line: `"  #=cancel  ^C=all  esc=back"` in grey.
   - Still set `shell._task_menu = True` for keybinding filter gating (digits/arrow/esc need to be active).

2. Update `_toolbar()` method: when `_task_menu` is True, show normal toolbar (NOT render_task_menu). The menu is now in scrollback, so toolbar stays normal. This means removing the `if self._task_menu: return render_task_menu(...)` branch.

3. Update digit key cancel handler: after cancelling a task, print updated task list to scrollback again (so user sees current state). If no tasks remain, dismiss menu.

4. Update Esc dismiss: print a brief "menu dismissed" or just dismiss silently (no scrollback needed).

5. Update tests in `tests/repl/test_task_lifecycle.py`:
   - Tests for Ctrl-C behavior: verify that when tasks are active and Ctrl-C fires, `_task_menu` is set to True (keybinding gating still works)
   - The toolbar should now render normally even when `_task_menu=True` (it no longer branches to render_task_menu)
   - Keep existing tests for second Ctrl-C kill-all, Esc dismiss, digit cancel logic
  </action>
  <verify>
`uv run pytest tests/repl/test_task_lifecycle.py -v` — all tests pass.
`uv run pytest tests/repl/ -v` — full repl suite green, no regressions.
  </verify>
  <done>Ctrl-C prints numbered task list to scrollback. Toolbar stays normal. Keybinding filter still gates digit/arrow/esc to menu mode.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/repl/ -v` — full repl suite passes
- `from bae.repl.channels import render_markdown` works and produces ANSI output
- `CHANNEL_DEFAULTS["ai"]` includes `"markdown": True`
- Channel._display for ai channel renders entire response as one markdown block
- Ctrl-C with active tasks prints task list to scrollback (not toolbar)
</verification>

<success_criteria>
SC6: AI output renders markdown formatting in the terminal (headers, bold, code blocks, lists) via Rich Markdown -> ANSI -> prompt_toolkit bridge
SC7: Ctrl-C task menu renders as printed scrollback, not toolbar content
</success_criteria>

<output>
After completion, create `.planning/phases/20-ai-eval-loop/20-01-SUMMARY.md`
</output>
