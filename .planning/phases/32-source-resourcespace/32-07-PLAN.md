---
phase: 32-source-resourcespace
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/resource.py
  - bae/repl/shell.py
  - bae/repl/tools.py
  - bae/repl/ai.py
  - bae/repl/ai_prompt.md
  - tests/test_resource.py
  - tests/test_tools_router.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "home() is a callable in the namespace that navigates to root"
    - "At home, tools (read, glob, grep) are available in the namespace"
    - "homespace() no longer exists anywhere in code, tests, or docs"
  artifacts:
    - path: "bae/repl/resource.py"
      provides: "home() method on ResourceRegistry that sets home as current with tools"
      contains: "def home"
    - path: "bae/repl/shell.py"
      provides: "namespace['home'] as ResourceHandle or callable, not lambda wrapping homespace"
    - path: "bae/repl/tools.py"
      provides: "_homespace_dispatch renamed, no homespace references"
    - path: "bae/repl/ai.py"
      provides: "_SKIP set uses 'home' not 'homespace'"
    - path: "bae/repl/ai_prompt.md"
      provides: "home() references, not homespace()"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/resource.py"
      via: "namespace['home'] calls registry.home()"
      pattern: "home"
    - from: "bae/repl/resource.py"
      to: "_put_tools"
      via: "home() injects root-level tools into namespace"
      pattern: "_put_tools|_home_tools"
---

<objective>
Rename homespace() to home() and make home a resource with tools.

Purpose: Dzara reported that homespace() should be home(). Home is a resource -- it should have its own tools (read, glob, grep for filesystem), not just clear everything. When at home, the namespace should have read/glob/grep bound to homespace filesystem operations.
Output: home() is a first-class navigation target with tool callables in the namespace.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bae/repl/resource.py
@bae/repl/shell.py
@bae/repl/tools.py
@bae/repl/ai.py
@bae/repl/ai_prompt.md
@tests/test_resource.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename homespace to home and inject home tools</name>
  <files>bae/repl/resource.py, bae/repl/shell.py, bae/repl/tools.py, bae/repl/ai.py, bae/repl/ai_prompt.md, tests/test_resource.py, tests/test_tools_router.py</files>
  <action>
**resource.py:**
1. Rename `ResourceRegistry.homespace()` to `ResourceRegistry.home()`.
2. In `home()`: after clearing the stack, instead of just calling `_put_tools()` (which removes all tools when current is None), inject home-level tools into the namespace. The home-level tools are the filesystem fallback operations from ToolRouter: read, glob, grep.
3. Approach: Add a `_home_tools` dict to ResourceRegistry that stores the home-level tool callables. Set it during `__init__` or via a setter. In `_put_tools()`, when `current is None` (at home), inject `_home_tools` instead of nothing. This way both `home()` and `back()` (when popping to root) get home tools.
4. The `_home_tools` dict will be set by shell.py during init, containing `{"read": <homespace_read>, "glob": <homespace_glob>, "grep": <homespace_grep>}` -- these are the same filesystem functions currently in ToolRouter._homespace_dispatch.

**Concretely in _put_tools():**
```python
def _put_tools(self) -> None:
    if self._namespace is None:
        return
    for name in _TOOL_NAMES:
        self._namespace.pop(name, None)
    current = self.current
    if current is not None:
        self._namespace.update(current.tools())
    elif self._home_tools:
        self._namespace.update(self._home_tools)
```

**shell.py:**
1. Replace `self.namespace["homespace"] = lambda: self.registry.homespace()` with `self.namespace["home"] = lambda: self.registry.home()`
2. After creating the ToolRouter, set home tools on the registry. The home tools should wrap ToolRouter._homespace_dispatch for each tool:
```python
self.registry._home_tools = {
    "read": lambda target="": self._tool_router._home_dispatch("read", target),
    "glob": lambda pattern="": self._tool_router._home_dispatch("glob", pattern),
    "grep": lambda pattern="", path="": self._tool_router._home_dispatch("grep", pattern, path=path),
}
```
Wait -- simpler approach. Import the _exec_read, _exec_glob, _exec_grep from ai.py (already public module-level functions) and bind them directly:
```python
from bae.repl.ai import _exec_read, _exec_glob, _exec_grep
self.registry._home_tools = {
    "read": _exec_read,
    "glob": _exec_glob,
    "grep": _exec_grep,
}
```
This matches what ToolRouter._homespace_dispatch already delegates to.

**tools.py:**
1. Rename `_homespace_dispatch` to `_home_dispatch`.
2. Update the error message from "homespace root" to "home".
3. Update docstrings/comments: "homespace" -> "home".

**ai.py:**
1. In `_SKIP` set: change `"homespace"` to `"home"`.

**ai_prompt.md:**
1. Replace `homespace()` with `home()` in the Resources section.

**tests/test_resource.py:**
1. Rename all `homespace` method calls to `home()`.
2. Test names: `test_homespace_*` -> `test_home_*`.
3. Add new test: `test_home_injects_tools` -- after calling `reg.home()`, verify that read/glob/grep are in the namespace (when `_home_tools` is set).
4. Update `test_homespace_removes_tools` -> `test_home_swaps_to_home_tools` -- after navigating to a resource then calling home(), the resource's tools are removed and home tools are injected.

**tests/test_tools_router.py:**
1. Update any `homespace` references to `home`.
  </action>
  <verify>`uv run pytest tests/test_resource.py tests/test_tools_router.py -x -q` passes. Then full suite: `uv run pytest tests/ -x -q --ignore=tests/test_integration.py`. Grep for any remaining "homespace" references: `grep -rn homespace bae/ tests/` should return nothing.</verify>
  <done>home() is a namespace callable that navigates to root and injects read/glob/grep; homespace() no longer exists anywhere in the codebase</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- all tests pass
- `grep -rn homespace bae/ tests/` -- zero matches
- `grep -rn "home" bae/repl/resource.py` -- shows home() method
</verification>

<success_criteria>
home() navigates to root and provides read/glob/grep tools in the namespace. No trace of homespace() anywhere.
</success_criteria>

<output>
After completion, create `.planning/phases/32-source-resourcespace/32-07-SUMMARY.md`
</output>
