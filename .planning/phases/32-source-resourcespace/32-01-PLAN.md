---
phase: 32-source-resourcespace
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/repl/source.py
  - tests/test_source.py
autonomous: true

must_haves:
  truths:
    - "SourceResourcespace conforms to Resourcespace protocol"
    - "Module paths resolve to filesystem paths and back without exposing raw paths"
    - "Path traversal attempts (../, absolute, path separators) raise ResourceError"
    - "read() at root shows top-level packages with docstring + class/function counts"
    - "read('bae.ai') shows module summary when not navigated in"
    - "read('bae.ai.AI') shows symbol source via AST line ranges"
    - "enter() shows subresource listing and package overview"
    - "nav() returns navigable tree of packages and subresources"
  artifacts:
    - path: "bae/repl/source.py"
      provides: "SourceResourcespace class with module path resolution and read-only tools"
      contains: "class SourceResourcespace"
    - path: "tests/test_source.py"
      provides: "Tests for protocol conformance, path resolution, safety, read operations"
  key_links:
    - from: "bae/repl/source.py"
      to: "bae/repl/resource.py"
      via: "implements Resourcespace protocol"
      pattern: "Resourcespace"
---

<objective>
SourceResourcespace with module path resolution, path safety, and read operations (summary + symbol).

Purpose: Establish the core read-only semantic interface over the Python project. This is the foundation for all source operations -- path resolution and safety validation gate every tool call. Read is the most-used operation and proves the module-based addressing pattern end-to-end.

Output: `bae/repl/source.py` with SourceResourcespace implementing Resourcespace protocol, module path translation, path safety, and read at three levels (package listing, module summary, symbol source).
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-source-resourcespace/32-RESEARCH.md
@.planning/phases/32-source-resourcespace/32-CONTEXT.md
@.planning/phases/31-resource-protocol-navigation/31-01-SUMMARY.md
@bae/repl/resource.py
@bae/repl/tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Tests for SourceResourcespace protocol, path resolution, safety, and read</name>
  <files>tests/test_source.py</files>
  <action>
Create tests/test_source.py with tests covering:

**Protocol conformance (3 tests):**
- SourceResourcespace is an instance of Resourcespace protocol (runtime_checkable)
- `supported_tools()` returns `{"read", "write", "edit", "glob", "grep"}`
- `children()` returns dict with keys "meta", "deps", "config", "tests"

**Module path resolution (5 tests):**
- `_module_to_path("bae.repl.ai")` returns `{project_root}/bae/repl/ai.py`
- `_module_to_path("bae.repl")` returns `{project_root}/bae/repl/__init__.py` (package)
- `_module_to_path("bae.nonexistent")` raises ResourceError
- `_path_to_module("{root}/bae/repl/ai.py")` returns `"bae.repl.ai"`
- `_path_to_module("{root}/bae/repl/__init__.py")` returns `"bae.repl"`

**Path safety (4 tests):**
- `_validate_module_path("bae.ai")` succeeds (no exception)
- `_validate_module_path("../etc/passwd")` raises ResourceError
- `_validate_module_path("/absolute/path")` raises ResourceError (contains `/`)
- `_validate_module_path("bae..ai")` raises ResourceError (empty segment)

**Read operations (5 tests):**
- `read("")` returns top-level packages listing with docstring + counts format
- `read("bae.repl.resource")` returns module summary (not full source): module path, first docstring line, class count, function count
- `read("bae.repl.resource.ResourceError")` returns source of that specific class (uses AST line range)
- `read("bae.repl.resource.ResourceError")` does NOT contain source from other classes (isolation check)
- `read("bae.nonexistent")` raises ResourceError

**Enter/nav (3 tests):**
- `enter()` contains "source" and lists subresources (deps, config, tests, meta)
- `nav()` returns tree with top-level packages
- `children()` keys match expected subresource names

Use the actual bae project as test data (construct SourceResourcespace with project root pointing to the real bae directory). This avoids test fixtures and validates against real code.

All tests must FAIL initially (RED phase).
  </action>
  <verify>`uv run pytest tests/test_source.py -x -q` -- all tests fail (no implementation yet)</verify>
  <done>20 tests written, all failing with ImportError or similar (no bae/repl/source.py yet)</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement SourceResourcespace with path resolution, safety, and read</name>
  <files>bae/repl/source.py</files>
  <action>
Create `bae/repl/source.py` implementing SourceResourcespace:

**Imports:** `ast`, `pathlib.Path`, `fnmatch` from stdlib. `ResourceError` from `bae.repl.resource`.

**Internal helpers (module-level):**

`_validate_module_path(path: str) -> None`:
- Reject if contains `/` or `\\` (path separators)
- Split on `.`, reject if any part is empty string or not a valid Python identifier (`str.isidentifier()`)
- Raise ResourceError with helpful message on failure

`_module_to_path(project_root: Path, dotted: str) -> Path`:
- Split dotted path on `.`
- Check if `project_root / parts...` is a directory with `__init__.py` -> return the `__init__.py`
- Else check if `.py` suffix exists -> return that
- Raise ResourceError if neither found

`_path_to_module(project_root: Path, filepath: Path) -> str`:
- Get relative path from project_root
- Strip `__init__.py` or `.py` suffix
- Join parts with `.`

`_module_summary(project_root: Path, module_path: str) -> str`:
- Resolve to file, read source, `ast.parse()`
- Extract first line of module docstring via `ast.get_docstring()`
- Count top-level ClassDef and non-private FunctionDef/AsyncFunctionDef nodes
- Return: `"{module_path} -- {first_line} ({N} classes, {M} functions)"`

`_read_symbol(project_root: Path, dotted_path: str) -> str`:
- Walk from longest possible module prefix to shortest, trying `_module_to_path` each time
- Once module found, remaining parts are symbol path
- Parse source with `ast.parse()`, walk AST to find the symbol (handle nested: class.method)
- Use `lineno` and `end_lineno` to extract source lines
- Raise ResourceError if symbol not found

`_discover_packages(project_root: Path) -> list[str]`:
- Look for directories under project_root that contain `__init__.py`
- Return sorted list of top-level package names (just one level deep)

**SourceResourcespace class:**

```python
class SourceResourcespace:
    name = "source"
    description = "Python project source tree"

    def __init__(self, project_root: Path):
        self._root = project_root
```

`enter() -> str`: Return brief description + list subresources (deps, config, tests, meta) with one-line descriptions. Then show top-level packages via `_discover_packages` with summaries.

`nav() -> str`: Return tree of top-level packages. For each package, list submodules (one level).

`read(target: str = "") -> str`:
- If `target` is empty: list top-level packages with summary (docstring + counts)
- Validate path with `_validate_module_path`
- Try `_module_to_path` first -- if it resolves to a module, return `_module_summary`
- If module resolution fails, try `_read_symbol` (the path includes a symbol)
- Budget check: if output exceeds CHAR_CAP (~2000 chars), raise ResourceError telling agent to narrow (per locked decision: no silent pruning)

`supported_tools() -> set[str]`: Return `{"read", "write", "edit", "glob", "grep"}`

`children() -> dict[str, Resourcespace]`: Return dict with placeholder subresource instances. For this plan, create minimal stub classes (DepsSubresource, ConfigSubresource, TestsSubresource, MetaSubresource) that satisfy the Resourcespace protocol with stub methods raising ResourceError("Not yet implemented"). Full subresource implementation is Plan 04.

All read output uses module paths only -- no filesystem paths in any return value.
  </action>
  <verify>`uv run pytest tests/test_source.py -x -q` -- all tests pass. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite green.</verify>
  <done>SourceResourcespace implements Resourcespace protocol with module path resolution, path safety validation, and read at three levels (package listing, module summary, symbol source). Subresources are stubs. All tests pass.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_source.py -x -q` -- all source tests pass
- `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite still green (707+ tests)
- `python -c "from bae.repl.source import SourceResourcespace; from bae.repl.resource import Resourcespace; s = SourceResourcespace(Path('.')); assert isinstance(s, Resourcespace)"` -- protocol conformance
</verification>

<success_criteria>
- SourceResourcespace is a valid Resourcespace per the protocol
- Module paths translate to filesystem paths and back
- Path traversal/absolute paths rejected with clear errors
- read() shows packages, module summaries, or symbol source depending on target depth
- No filesystem paths appear in any output
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/32-source-resourcespace/32-01-SUMMARY.md`
</output>
