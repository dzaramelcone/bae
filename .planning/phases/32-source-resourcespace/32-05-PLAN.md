---
phase: 32-source-resourcespace
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/resource.py
  - bae/repl/shell.py
  - tests/test_resource.py
  - tests/test_source.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Navigating source.deps() after source.config() produces breadcrumb 'home > source > deps', not 'home > source > config > source > deps'"
    - "read() is callable as a bare function in PY mode when navigated into a resourcespace"
    - "glob() and grep() are callable as bare functions when the current resource supports them"
    - "Error messages use source() syntax, not @source() syntax"
    - "Leaving a resourcespace (back/homespace) removes tool callables from namespace"
  artifacts:
    - path: "bae/repl/resource.py"
      provides: "Stack-replacing navigation and namespace tool injection"
      contains: "_sync_namespace"
    - path: "bae/repl/shell.py"
      provides: "Passes namespace to ResourceRegistry"
      contains: "namespace=self.namespace"
  key_links:
    - from: "bae/repl/resource.py"
      to: "namespace dict"
      via: "ResourceRegistry._sync_namespace injects/removes tool callables"
      pattern: "self\\._namespace\\[.tool.\\]"
    - from: "bae/repl/resource.py"
      to: "navigate"
      via: "_sync_namespace called after every stack change"
      pattern: "_sync_namespace"
---

<objective>
Fix two UAT-blocking gaps in resourcespace navigation:
1. Navigation stack accumulates indefinitely — sibling navigation (source.config then source.deps) appends instead of replacing from divergence point
2. Tool callables (read, glob, grep, etc.) not injected into REPL namespace — entry display shows them but they cause NameError

Purpose: Make resourcespace navigation and tools usable from PY mode REPL, not just AI tool dispatch
Output: Fixed resource.py with stack replacement + namespace injection, updated shell.py to pass namespace
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-source-resourcespace/32-04-SUMMARY.md
@bae/repl/resource.py
@bae/repl/shell.py
@bae/repl/tools.py
@bae/repl/source.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix navigation stack replacement and error message syntax</name>
  <files>bae/repl/resource.py, tests/test_resource.py</files>
  <action>
Fix ResourceRegistry.navigate() to replace the stack from the divergence point instead of always appending:

**Stack replacement logic:**
When navigate("source.deps") is called and the stack already contains [source, config]:
1. Build the new chain: [source, deps]
2. Find the longest common prefix between current stack and new chain
3. Truncate stack to common prefix length, then extend with the remainder of the new chain
4. Example: stack=[source, config], new=[source, deps] -> common prefix=[source] (length 1) -> stack becomes [source, deps]

The current code at lines 116-138 has two paths: single-part (appends one) and multi-part (appends chain). Both must use the replacement logic instead.

For single-part navigation (e.g., `source()`), the new chain is just [source_space]. For multi-part (e.g., `source.deps()`), the chain is [source_space, deps_space].

Replace lines 110-138 with:
```python
# Build navigation chain
chain = [space]
resolved_chain = space
for child_name in parts[1:]:
    resolved_chain = resolved_chain.children()[child_name]
    chain.append(resolved_chain)

# Transition message
prev = self.current
transition = ""
if prev is not None and prev is not chain[-1]:
    transition = f"Left {prev.name} -> entering {chain[-1].name}\n\n"

# Replace stack from divergence point (not append)
# Find longest common prefix between current stack and new chain
common = 0
for i in range(min(len(self._stack), len(chain))):
    if self._stack[i] is chain[i]:
        common = i + 1
    else:
        break
self._stack = self._stack[:common] + chain[common:]

if len(self._stack) > MAX_STACK_DEPTH:
    self._stack = self._stack[-MAX_STACK_DEPTH:]
```

**Fix error message syntax:**
In `format_nav_error()` and `format_unsupported_error()` and `_root_nav()`, replace `@resource()` with `resource()` in all user-facing strings. The `@` prefix is not valid Python and causes SyntaxError when users try to call it. Search for `@{` patterns in resource.py and remove the `@` prefix.

Specifically:
- `format_nav_error`: `@{suggestion}()` -> `{suggestion}()`
- `format_unsupported_error`: `@{space.name}.{child_name}()` -> `{space.name}.{child_name}()`
- `_root_nav`: `@{name}()` -> `{name}()`, `@{name}.{child_name}()` -> `{name}.{child_name}()`
- `ResourceHandle.__repr__`: `@{self._name}()` -> `{self._name}()`

Also fix in source.py `enter()`: `@source.{name}()` -> `source.{name}()`

**Tests:**
Add tests to tests/test_resource.py:
- `test_navigate_sibling_replaces_stack`: Navigate source.config then source.deps, assert breadcrumb is "home > source > deps" not "home > source > config > source > deps"
- `test_navigate_same_root_replaces`: Navigate source then source again, stack has exactly one source entry
- `test_error_messages_no_at_prefix`: Assert format_nav_error output does not contain "@"
  </action>
  <verify>`uv run pytest tests/test_resource.py -x -q` passes including new tests</verify>
  <done>Sibling navigation replaces stack from divergence point. Breadcrumb shows minimum path. Error messages use callable Python syntax without @ prefix.</done>
</task>

<task type="auto">
  <name>Task 2: Inject tool callables into namespace on navigation</name>
  <files>bae/repl/resource.py, bae/repl/shell.py, tests/test_resource.py</files>
  <action>
Give ResourceRegistry an optional namespace dict reference. On every navigation state change (navigate, back, homespace), sync tool callables into namespace.

**ResourceRegistry changes:**

1. Accept optional `namespace` parameter in `__init__`:
```python
def __init__(self, namespace: dict | None = None) -> None:
    self._spaces: dict[str, Resourcespace] = {}
    self._stack: list[Resourcespace] = []
    self._namespace = namespace
```

2. Add `_sync_namespace()` method that runs after every stack change:
```python
# All known tool names that could be injected
_TOOL_NAMES = {"read", "write", "edit", "glob", "grep"}

def _sync_namespace(self) -> None:
    """Inject/remove tool callables based on current resource."""
    if self._namespace is None:
        return
    current = self.current
    if current is None:
        # At homespace: remove all tool callables
        for name in _TOOL_NAMES:
            self._namespace.pop(name, None)
        return
    supported = current.supported_tools()
    for name in _TOOL_NAMES:
        if name in supported:
            method = getattr(current, name)
            self._namespace[name] = method
        else:
            self._namespace.pop(name, None)
```

3. Call `self._sync_namespace()` at the end of `navigate()`, `back()`, and `homespace()` -- right before returning.

**CortexShell changes (shell.py):**

Pass `namespace=self.namespace` when constructing ResourceRegistry:
```python
self.registry = ResourceRegistry(namespace=self.namespace)
```

**Tests:**
Add to tests/test_resource.py:
- `test_navigate_injects_tools`: Create a mock resourcespace with read/glob supported. Create registry with a namespace dict. Navigate into it. Assert namespace["read"] and namespace["glob"] are the resource's methods.
- `test_back_removes_tools`: Navigate in, then back. Assert "read" not in namespace.
- `test_homespace_removes_tools`: Navigate in, then homespace. Assert "read" not in namespace.
- `test_navigate_swaps_tools`: Navigate to resource supporting {read, glob}, then navigate to resource supporting {read, write}. Assert namespace has read and write but NOT glob.
  </action>
  <verify>`uv run pytest tests/test_resource.py tests/test_source.py -x -q` passes. Also `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` for full suite.</verify>
  <done>Navigating into a resourcespace makes its supported tools callable as bare functions (read(), glob(), etc.) in PY mode. Leaving removes them. Switching resources swaps the correct set.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full test suite passes
2. Manual verification scenario (for UAT re-test):
   - `source()` enters source resourcespace, entry display uses `source.meta()` not `@source.meta()`
   - `read()` works as bare callable, returns package listing
   - `source.config()` then `source.deps()` -- breadcrumb shows "home > source > deps"
   - `back()` removes read() from namespace
</verification>

<success_criteria>
- Navigation breadcrumb shows minimum path (no accumulation across sibling navigations)
- Tool callables injected on navigate, removed on back/homespace
- All error messages use Python-callable syntax (no @ prefix)
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/32-source-resourcespace/32-05-SUMMARY.md`
</output>
