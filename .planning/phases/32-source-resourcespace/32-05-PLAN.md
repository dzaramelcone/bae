---
phase: 32-source-resourcespace
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/resource.py
  - bae/repl/shell.py
  - bae/repl/source.py
  - tests/test_resource.py
  - tests/test_source.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Navigating source.deps() after source.config() produces breadcrumb 'home > source > deps', not 'home > source > config > source > deps'"
    - "read() is callable as a bare function in PY mode when navigated into a resourcespace"
    - "glob() and grep() are callable as bare functions when the current resource supports them"
    - "Error messages use source() syntax, not @source() syntax"
    - "Leaving a resourcespace (homespace) removes tool callables from namespace"
    - "Resourcespace protocol has tools() method returning dict of callables"
  artifacts:
    - path: "bae/repl/resource.py"
      provides: "Stack-replacing navigation and tools() protocol method"
      contains: "tools"
    - path: "bae/repl/shell.py"
      provides: "Passes namespace to ResourceRegistry"
      contains: "namespace=self.namespace"
  key_links:
    - from: "bae/repl/resource.py Resourcespace.tools()"
      to: "namespace dict"
      via: "ResourceRegistry puts tools dict into namespace on navigate"
      pattern: "self\\._namespace\\.update"
    - from: "bae/repl/resource.py navigate()"
      to: "stack replacement"
      via: "common-prefix divergence logic"
      pattern: "self\\._stack"
---

<objective>
Fix two UAT-blocking gaps in resourcespace navigation:
1. Navigation stack accumulates indefinitely — sibling navigation appends instead of replacing from divergence point
2. Tool callables (read, glob, grep, etc.) not in REPL namespace — Resourcespace protocol gets a tools() method returning callables dict; registry puts it into namespace on navigate

Purpose: Make resourcespace navigation and tools usable from PY mode REPL, not just AI tool dispatch
Output: Fixed resource.py with stack replacement + tools() protocol, updated shell.py, updated source.py
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-source-resourcespace/32-04-SUMMARY.md
@bae/repl/resource.py
@bae/repl/shell.py
@bae/repl/source.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix navigation stack replacement and error message syntax</name>
  <files>bae/repl/resource.py, tests/test_resource.py</files>
  <action>
Fix ResourceRegistry.navigate() to replace the stack from the divergence point instead of always appending:

**Stack replacement logic:**
When navigate("source.deps") is called and the stack already contains [source, config]:
1. Build the new chain: [source, deps]
2. Find the longest common prefix between current stack and new chain (by identity: `is`)
3. Truncate stack to common prefix length, then extend with remainder of new chain
4. Example: stack=[source, config], new=[source, deps] -> common=[source] -> stack becomes [source, deps]

Replace lines 110-138 with:
```python
# Build navigation chain
chain = [space]
resolved_chain = space
for child_name in parts[1:]:
    resolved_chain = resolved_chain.children()[child_name]
    chain.append(resolved_chain)

# Transition message
prev = self.current
transition = ""
if prev is not None and prev is not chain[-1]:
    transition = f"Left {prev.name} -> entering {chain[-1].name}\n\n"

# Replace stack from divergence point (not append)
common = 0
for i in range(min(len(self._stack), len(chain))):
    if self._stack[i] is chain[i]:
        common = i + 1
    else:
        break
self._stack = self._stack[:common] + chain[common:]

if len(self._stack) > MAX_STACK_DEPTH:
    self._stack = self._stack[-MAX_STACK_DEPTH:]
```

**Fix error message syntax:**
Remove `@` prefix from all user-facing resource references in resource.py. The `@` is not valid Python syntax. Find-and-replace:
- `format_nav_error`: `@{suggestion}()` -> `{suggestion}()`
- `format_unsupported_error`: `@{space.name}.{child_name}()` -> `{space.name}.{child_name}()`
- `_root_nav`: `@{name}()` -> `{name}()`, `@{name}.{child_name}()` -> `{name}.{child_name}()`
- `ResourceHandle.__repr__`: `@{self._name}()` -> `{self._name}()`

Also fix in source.py `enter()`: `@source.{name}()` -> `source.{name}()`

**Tests:**
Add tests to tests/test_resource.py:
- `test_navigate_sibling_replaces_stack`: Navigate source.config then source.deps, assert breadcrumb is "home > source > deps"
- `test_navigate_same_root_replaces`: Navigate source then source again, stack has exactly one source entry
- `test_error_messages_no_at_prefix`: Assert format_nav_error output does not contain "@"
  </action>
  <verify>`uv run pytest tests/test_resource.py -x -q` passes including new tests</verify>
  <done>Sibling navigation replaces stack from divergence point. Breadcrumb shows minimum path. Error messages use callable Python syntax.</done>
</task>

<task type="auto">
  <name>Task 2: Add tools() to Resourcespace protocol and inject on navigate</name>
  <files>bae/repl/resource.py, bae/repl/shell.py, bae/repl/source.py, tests/test_resource.py, tests/test_source.py</files>
  <action>
**Design: Resourcespace.tools() returns a dict of callables, registry puts it into namespace. Idempotent.**

**1. Add tools() to Resourcespace protocol (resource.py):**
```python
class Resourcespace(Protocol):
    ...
    def tools(self) -> dict[str, Callable]:
        """Tool callables keyed by standard tool name. Injected into namespace on navigate."""
        ...
```

Import `Callable` from `typing`.

**2. Implement tools() on SourceResourcespace and all subresources (source.py):**

On SourceResourcespace:
```python
def tools(self) -> dict[str, Callable]:
    return {
        "read": self.read,
        "write": self.write,
        "edit": self.edit,
        "glob": self.glob,
        "grep": self.grep,
    }
```

On each subresource, return only the tools it supports. For example DepsSubresource:
```python
def tools(self) -> dict[str, Callable]:
    return {"read": self.read, "write": self.write}
```

ConfigSubresource: `{"read": self.read}`
TestsSubresource: `{"read": self.read, "grep": self.grep}`
MetaSubresource: `{"read": self.read, "edit": self.edit}`

**3. ResourceRegistry gets namespace ref and tool injection (resource.py):**

```python
_TOOL_NAMES = frozenset({"read", "write", "edit", "glob", "grep"})

class ResourceRegistry:
    def __init__(self, namespace: dict | None = None) -> None:
        self._spaces: dict[str, Resourcespace] = {}
        self._stack: list[Resourcespace] = []
        self._namespace = namespace
```

Add `_put_tools()` — called at end of `navigate()`, `back()`, `homespace()`:
```python
def _put_tools(self) -> None:
    """Put current resource's tools into namespace. Idempotent."""
    if self._namespace is None:
        return
    current = self.current
    if current is None:
        # At homespace: clear all tool names
        for name in _TOOL_NAMES:
            self._namespace.pop(name, None)
        return
    # Put: clear all then update with current resource's tools
    for name in _TOOL_NAMES:
        self._namespace.pop(name, None)
    self._namespace.update(current.tools())
```

Call `self._put_tools()` at end of `navigate()` (before `return`), at end of `back()` (before both returns), and at end of `homespace()` (before `return`).

**4. CortexShell passes namespace (shell.py):**

Change:
```python
self.registry = ResourceRegistry()
```
to:
```python
self.registry = ResourceRegistry(namespace=self.namespace)
```

**5. Tests (tests/test_resource.py):**
- `test_navigate_injects_tools`: Create mock resourcespace with tools() returning {"read": mock_read}. Navigate into it. Assert namespace["read"] is mock_read.
- `test_homespace_removes_tools`: Navigate in, then homespace(). Assert "read" not in namespace.
- `test_navigate_swaps_tools`: Navigate to resource with {read, glob}, then to resource with {read, write}. Assert namespace has read+write, NOT glob.

**6. Tests (tests/test_source.py):**
- `test_source_tools_returns_all_five`: Assert SourceResourcespace.tools() returns dict with keys {read, write, edit, glob, grep}
- `test_deps_tools_returns_read_write`: Assert DepsSubresource.tools() returns dict with keys {read, write}
  </action>
  <verify>`uv run pytest tests/test_resource.py tests/test_source.py -x -q` passes. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` full suite green.</verify>
  <done>Resourcespace protocol has tools() method. Navigating into a resource puts its tool callables into namespace. Idempotent: clear all tool names then update with current resource's dict. No add/remove/swap logic.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full test suite passes
2. Manual verification scenario (for UAT re-test):
   - `source()` enters source resourcespace, entry display uses `source.meta()` not `@source.meta()`
   - `read()` works as bare callable, returns package listing
   - `source.config()` then `source.deps()` -- breadcrumb shows "home > source > deps"
   - `homespace()` removes read() from namespace
</verification>

<success_criteria>
- Navigation breadcrumb shows minimum path (no accumulation across sibling navigations)
- Resourcespace.tools() returns dict of callables, injected into namespace on navigate
- Tool injection is idempotent: clear-then-put, no conditional add/remove logic
- All error messages use Python-callable syntax (no @ prefix)
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/32-source-resourcespace/32-05-SUMMARY.md`
</output>
