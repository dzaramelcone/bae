---
phase: 32-source-resourcespace
plan: 04
type: execute
wave: 3
depends_on: ["32-01", "32-02", "32-03"]
files_modified:
  - bae/repl/source.py
  - bae/repl/shell.py
  - tests/test_source.py
autonomous: true

must_haves:
  truths:
    - "source.deps() enters deps subresource; read() lists project dependencies from pyproject.toml"
    - "source.config() enters config subresource; read() shows pyproject.toml sections"
    - "source.tests() enters tests subresource; read() lists test modules"
    - "source.meta() enters meta subresource scoped to SourceResourcespace's own code"
    - "SourceResourcespace registered in CortexShell; source() callable in namespace navigates to it"
    - "Agent calls source() and enters source resourcespace showing entry display"
  artifacts:
    - path: "bae/repl/source.py"
      provides: "Four subresource classes: DepsSubresource, ConfigSubresource, TestsSubresource, MetaSubresource"
    - path: "bae/repl/shell.py"
      provides: "SourceResourcespace registration and namespace handle"
    - path: "tests/test_source.py"
      provides: "Tests for subresources and shell registration"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/source.py"
      via: "registry.register(SourceResourcespace(...))"
      pattern: "SourceResourcespace"
    - from: "bae/repl/source.py DepsSubresource"
      to: "pyproject.toml"
      via: "tomllib.loads for reading"
      pattern: "tomllib"
---

<objective>
Subresources (deps, config, tests, meta) and shell registration.

Purpose: Complete the SourceResourcespace by implementing the four subresourcespaces declared in children() and wiring the whole thing into CortexShell. After this plan, the agent can call `source()` in the REPL and navigate the full source resource tree.

Output: Four subresource classes replacing stubs, SourceResourcespace registered in shell with namespace handle.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-source-resourcespace/32-RESEARCH.md
@.planning/phases/32-source-resourcespace/32-01-SUMMARY.md
@.planning/phases/32-source-resourcespace/32-02-SUMMARY.md
@.planning/phases/32-source-resourcespace/32-03-SUMMARY.md
@bae/repl/source.py
@bae/repl/shell.py
@bae/repl/resource.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement four subresources replacing stubs</name>
  <files>bae/repl/source.py, tests/test_source.py</files>
  <action>
Replace the stub subresource classes in bae/repl/source.py with real implementations:

**DepsSubresource:**
- `name = "deps"`, `description = "Project dependencies"`
- `enter()`: Show deps count and available operations (read, write for add/remove)
- `read(target="")`: Use `tomllib` to parse `pyproject.toml`, return `project.dependencies` list. If target given, filter to matching deps.
- `write(target, content="")`: Add dependency via `subprocess.run(["uv", "add", target])`. Return confirmation or ResourceError on failure.
- `supported_tools()`: `{"read", "write"}`
- `children()`: empty dict
- `nav()`: list current deps

**ConfigSubresource:**
- `name = "config"`, `description = "Project configuration (pyproject.toml)"`
- `enter()`: Show available config sections
- `read(target="")`: Parse pyproject.toml, if target given return that section (e.g., `read("project")` returns [project] section). If empty, list all top-level sections.
- `supported_tools()`: `{"read"}`
- `children()`: empty dict
- `nav()`: list config sections

**TestsSubresource:**
- `name = "tests"`, `description = "Test suite"`
- `enter()`: Show test module count and hint about running tests
- `read(target="")`: Discover test modules under `tests/` directory using module path discovery. If target given, read that specific test module.
- `supported_tools()`: `{"read", "grep"}`  (can search tests, and read them)
- `grep(pattern, path="")`: Search test files for pattern, output in module:line: format
- `children()`: empty dict
- `nav()`: list test modules

**MetaSubresource:**
- `name = "meta"`, `description = "Source resourcespace implementation"`
- Scoped to the SourceResourcespace's own module: `bae/repl/source.py`
- `enter()`: Show that this reads/edits the source resourcespace itself
- `read(target="")`: If empty, show source.py summary. If target given (symbol name), show that symbol's source from source.py.
- `edit(target, new_source="")`: Edit a symbol in source.py specifically (delegates to parent's edit logic scoped to `bae.repl.source`)
- `supported_tools()`: `{"read", "edit"}`
- `children()`: empty dict
- `nav()`: list classes/functions in source.py

Add tests for each subresource:
- DepsSubresource.read() returns dependency list from pyproject.toml
- ConfigSubresource.read() returns pyproject.toml sections
- ConfigSubresource.read("project") returns project section content
- TestsSubresource.read() lists test modules
- MetaSubresource.read() shows source.py summary
- MetaSubresource.read("SourceResourcespace") shows that class's source
  </action>
  <verify>`uv run pytest tests/test_source.py -x -q` -- all tests pass</verify>
  <done>Four subresources implemented with real functionality. Tests verify read operations on each.</done>
</task>

<task type="auto">
  <name>Task 2: Register SourceResourcespace in CortexShell</name>
  <files>bae/repl/shell.py, tests/test_source.py</files>
  <action>
In bae/repl/shell.py:

1. Import SourceResourcespace: `from bae.repl.source import SourceResourcespace`
2. In `CortexShell.__init__`, after `self.registry = ResourceRegistry()`:
   - Determine project root: Use the current working directory (`Path.cwd()`) -- this is where the REPL is launched from, and is the project root.
   - Create the source resourcespace: `source_rs = SourceResourcespace(project_root)`
   - Register it: `self.registry.register(source_rs)`
3. After the existing `self.namespace["homespace"]` and `self.namespace["back"]` lines:
   - Create and seed the ResourceHandle: `self.namespace["source"] = ResourceHandle("source", self.registry)`

Add a test in tests/test_source.py:
- Test that creating a ResourceHandle("source", registry) and calling it returns the entry display
- Test that `source.meta()` navigates to the meta subresource (dotted access via ResourceHandle.__getattr__)

The `tomlkit` dependency is needed for DepsSubresource write operations. Add it:
```bash
uv add tomlkit
```
(Per research: tomlkit for style-preserving TOML writes. tomllib from stdlib handles reads.)
  </action>
  <verify>`uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite green. Verify source handle exists in namespace.</verify>
  <done>SourceResourcespace registered in shell. `source()` navigates to it. `source.meta()` navigates to meta subresource. tomlkit added as dependency. All tests pass.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_source.py -x -q` -- all source tests pass
- `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite green
- `python -c "from bae.repl.source import SourceResourcespace, DepsSubresource, ConfigSubresource, TestsSubresource, MetaSubresource"` -- all classes importable
</verification>

<success_criteria>
- source.deps() enters deps subresource showing project dependencies
- source.config() enters config subresource showing pyproject.toml sections
- source.tests() enters tests subresource listing test modules
- source.meta() enters meta subresource scoped to source.py
- SourceResourcespace registered in CortexShell; source() callable navigates to it
- tomlkit dependency added
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/32-source-resourcespace/32-04-SUMMARY.md`
</output>
