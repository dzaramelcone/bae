---
phase: 32-source-resourcespace
plan: 03
type: tdd
wave: 2
depends_on: ["32-01"]
files_modified:
  - bae/repl/source.py
  - tests/test_source.py
autonomous: true

must_haves:
  truths:
    - "write() creates a new module with valid Python source and updates __init__.py"
    - "edit('bae.mod.ClassName.method', new_source=...) replaces that symbol's source"
    - "Invalid Python in write/edit is rejected before writing to disk"
    - "Hot-reload after edit succeeds; failed reload triggers automatic rollback"
    - "undo() reverts last edit via git"
    - "Syntax errors in new_source produce clear ResourceError before any file write"
  artifacts:
    - path: "bae/repl/source.py"
      provides: "write(), edit(), undo() methods on SourceResourcespace"
    - path: "tests/test_source.py"
      provides: "Tests for write, edit, rollback, undo operations"
  key_links:
    - from: "bae/repl/source.py edit()"
      to: "ast.parse for validation"
      via: "syntax check before write"
      pattern: "ast\\.parse"
    - from: "bae/repl/source.py edit()"
      to: "importlib.reload for hot-reload"
      via: "reload after successful write"
      pattern: "importlib\\.reload"
---

<objective>
Write, edit, undo, and hot-reload operations for SourceResourcespace.

Purpose: Enable the agent to modify project source through the semantic module interface. Edits target symbols (classes, functions, methods) by name rather than line numbers. Syntax validation catches errors before disk writes. Hot-reload with automatic rollback keeps the edit cycle tight.

Output: write(), edit(), and undo() on SourceResourcespace with AST-based symbol replacement, syntax validation, hot-reload, and git-based undo.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-source-resourcespace/32-RESEARCH.md
@.planning/phases/32-source-resourcespace/32-01-SUMMARY.md
@bae/repl/source.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Tests for write, edit, hot-reload, rollback, and undo</name>
  <files>tests/test_source.py</files>
  <action>
Add tests to tests/test_source.py. These tests MUST use a temporary directory with a minimal Python package structure (use `tmp_path` fixture, create a mini package with `__init__.py` and a module file). Do NOT modify the real bae source in tests.

**Setup fixture** (`tmp_project`): Creates a temp dir with:
```
mylib/__init__.py     (empty or "from mylib.core import Greeter")
mylib/core.py         (a simple module with a class and function)
```
Initialize a git repo in tmp_path (`git init`, `git add .`, `git commit -m "init"`) so undo works.

**Write tests (3 tests):**
- `write("mylib.utils", "def helper():\n    return 42\n")` creates `mylib/utils.py` with that content
- `write("mylib.utils", "not valid python {{{")` raises ResourceError (syntax validation)
- After successful write, `mylib/__init__.py` is updated to include the new module exposure

**Edit tests (4 tests):**
- `edit("mylib.core.Greeter.greet", new_source="    def greet(self):\n        return 'hello'\n")` replaces just that method
- After edit, reading `mylib.core.Greeter.greet` returns the new source
- `edit("mylib.core.Greeter.greet", new_source="not valid python")` raises ResourceError without modifying the file
- `edit("mylib.core.nonexistent_thing", new_source="...")` raises ResourceError

**Hot-reload + rollback (2 tests):**
- After a successful edit, the module is reloaded (test by importing the module and checking the new behavior works)
- If reload would fail (e.g., edit introduces import of nonexistent module), file is rolled back to pre-edit state and ResourceError reports the reload failure

**Undo (2 tests):**
- After an edit, `undo()` reverts the file to the git-committed state
- `undo()` returns a confirmation message

All new tests must fail initially.
  </action>
  <verify>`uv run pytest tests/test_source.py -k "write or edit or undo or reload or rollback" -x -q` -- all new tests fail</verify>
  <done>11 new tests written covering write/edit/undo/reload/rollback, all failing</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement write, edit, undo, and hot-reload</name>
  <files>bae/repl/source.py</files>
  <action>
Add to bae/repl/source.py:

**Helper: `_find_symbol(tree: ast.AST, symbol_parts: list[str]) -> ast.AST | None`:**
- Walk AST tree to find the named symbol
- For single part like "Greeter": search top-level ClassDef/FunctionDef/AsyncFunctionDef
- For dotted like ["Greeter", "greet"]: find Greeter first, then search its body for greet
- Return the AST node or None

**Helper: `_replace_symbol(source: str, symbol_parts: list[str], new_source: str) -> str`:**
- Parse source, find symbol via `_find_symbol`
- Get `lineno` and `end_lineno` from the AST node
- Detect indentation of the target symbol from its `col_offset`
- If new_source indentation doesn't match target's col_offset, auto-adjust (dedent to 0 then re-indent to col_offset)
- Validate new_source parses standalone: wrap in a dummy class body if it's a method (indented), or parse directly
- Replace lines `[lineno-1:end_lineno]` with new_source lines
- Validate the entire resulting module parses with `ast.parse()`
- Return the new complete source

**Helper: `_hot_reload(module_dotted: str, filepath: Path, old_source: str) -> None`:**
- `importlib.import_module(module_dotted)` then `importlib.reload(mod)`
- On any exception: write `old_source` back to filepath, raise ResourceError with the reload error message and hint to check the module

**SourceResourcespace.write(target: str, content: str = "") -> str:**
- Validate target as module path
- Validate content with `ast.parse(content)` -- raise ResourceError if invalid Python
- Resolve filesystem path via `_module_to_path` logic (but accept that it won't exist yet)
- Write content to the `.py` file
- Auto-update parent package `__init__.py`: append `from {parent}.{name} import *` or similar simple exposure. If __init__.py update fails (circular import), just skip it and note in return message.
- Attempt hot-reload; rollback on failure
- Return confirmation with module path

**SourceResourcespace.edit(target: str, new_source: str = "") -> str:**
- Validate target path
- Split into module part and symbol part (same logic as `_read_symbol`)
- Read current file source, save as `old_source`
- Call `_replace_symbol(source, symbol_parts, new_source)`
- Write result to file
- Attempt hot-reload; rollback to `old_source` on failure
- Return confirmation with what was edited

**SourceResourcespace.undo() -> str:**
- Run `git checkout -- .` scoped to project root via `subprocess.run`
- Return "Reverted to last committed state"
- On failure, raise ResourceError with git stderr

Per locked decision: write/edit work from any navigation level (no navigate-first requirement). The target is always a full dotted module path.
  </action>
  <verify>`uv run pytest tests/test_source.py -x -q` -- all tests pass. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- full suite green.</verify>
  <done>write(), edit(), undo() implemented with syntax validation, hot-reload, auto-rollback, and git-based undo. All tests pass.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_source.py -k "write or edit or undo" -x -q` -- mutation tests pass
- Invalid Python rejected before any file write
- Successful edit + reload cycle works end-to-end
- Failed reload auto-rollbacks to pre-edit state
- undo() reverts via git
</verification>

<success_criteria>
- write() creates modules with syntax validation and __init__.py update
- edit() replaces symbols by name with AST-based line replacement
- Hot-reload runs after every write/edit; failures trigger automatic rollback
- undo() reverts to last committed state via git
- No filesystem paths in output
</success_criteria>

<output>
After completion, create `.planning/phases/32-source-resourcespace/32-03-SUMMARY.md`
</output>
