---
phase: 32-source-resourcespace
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/source.py
  - tests/test_source.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "read() at source root shows submodule/subpackage counts for packages, not 0 classes / 0 functions"
  artifacts:
    - path: "bae/repl/source.py"
      provides: "_module_summary detects packages and shows submodule counts"
      contains: "subpackage"
  key_links:
    - from: "bae/repl/source.py"
      to: "_module_summary"
      via: "is_dir check distinguishes package from module"
      pattern: "subpackage|submodule"
---

<objective>
Fix _module_summary to show meaningful counts for packages.

Purpose: Currently _module_summary parses only __init__.py AST, producing "0 classes, 0 functions" for all packages. Packages should show submodule and subpackage counts instead.
Output: _module_summary detects packages vs modules and formats accordingly.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bae/repl/source.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix _module_summary for packages</name>
  <files>bae/repl/source.py, tests/test_source.py</files>
  <action>
In `_module_summary()` (source.py ~line 59-76), detect whether the resolved filepath is a package (__init__.py) or a plain module (.py file).

For **modules** (plain .py files): keep the current behavior -- show class count and function count from AST.

For **packages** (resolved to __init__.py): count immediate children instead:
- Count .py files (excluding __init__.py) as modules
- Count subdirectories with __init__.py as subpackages
- Format as: `{module_path} -- {first_line} ({N} subpackages, {M} modules)`
- If only modules (no subpackages): `{module_path} -- {first_line} ({M} modules)`
- If only subpackages: `{module_path} -- {first_line} ({N} subpackages)`

The filepath is already resolved by `_module_to_path()` -- check if `filepath.name == "__init__.py"` to detect packages.

Add tests in test_source.py:
- Test that _module_summary for a package directory shows submodule/subpackage counts (not 0 classes, 0 functions)
- Test that _module_summary for a plain module still shows class/function counts
  </action>
  <verify>`uv run pytest tests/test_source.py -x -q` passes. Manually verify: from bae.repl.source import _module_summary; from pathlib import Path; print(_module_summary(Path.cwd(), "bae")) should show something like "bae -- ... (2 subpackages, 0 modules)" or similar with nonzero counts.</verify>
  <done>read() at source root shows accurate submodule/subpackage counts for packages instead of "0 classes, 0 functions"</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_source.py -x -q` -- all tests pass
- `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` -- no regressions
</verification>

<success_criteria>
Package listings show meaningful counts (subpackages, modules) instead of 0 classes / 0 functions.
</success_criteria>

<output>
After completion, create `.planning/phases/32-source-resourcespace/32-06-SUMMARY.md`
</output>
