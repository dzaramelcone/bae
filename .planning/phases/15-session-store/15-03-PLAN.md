---
phase: 15-session-store
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/exec.py
  - bae/repl/store.py
  - bae/repl/shell.py
  - tests/repl/test_exec.py
  - tests/repl/test_store.py
  - tests/repl/test_store_integration.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "print() output during PY mode execution is captured and recorded in the session store"
    - "store.sessions() returns a list of all sessions from the REPL namespace"
    - "store.recent() and store.search() are accessible from the REPL namespace"
    - "store() display does not produce repr noise from Row objects"
  artifacts:
    - path: "bae/repl/exec.py"
      provides: "stdout capture during async_exec"
      contains: "sys.stdout"
    - path: "bae/repl/store.py"
      provides: "SessionStore.__call__ with inspector behavior, dict-based return"
    - path: "bae/repl/shell.py"
      provides: "SessionStore instance injected as namespace['store'], stdout recording"
  key_links:
    - from: "bae/repl/exec.py"
      to: "bae/repl/shell.py"
      via: "async_exec returns (result, stdout) tuple"
      pattern: "result, stdout = await async_exec"
    - from: "bae/repl/shell.py"
      to: "bae/repl/store.py"
      via: "store.record() for captured stdout"
      pattern: 'store\\.record.*type.*stdout'
    - from: "bae/repl/store.py"
      to: "bae/repl/shell.py"
      via: "SessionStore instance is namespace['store']"
      pattern: 'namespace\["store"\] = self\\.store'
---

<objective>
Close two UAT gaps from Phase 15: (1) print() stdout not captured during PY execution, (2) store in namespace is a closure hiding SessionStore methods and producing Row repr noise.

Purpose: UAT tests 4 and 6 fail -- print() output vanishes from session history, and cross-session browsing is impossible because store.sessions() raises AttributeError.
Output: Both gaps closed, all existing tests still pass, new tests verify the fixes.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-session-store/15-UAT.md
@bae/repl/exec.py
@bae/repl/store.py
@bae/repl/shell.py
@tests/repl/test_exec.py
@tests/repl/test_store.py
@tests/repl/test_store_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Capture stdout during async_exec and make SessionStore callable</name>
  <files>bae/repl/exec.py, bae/repl/store.py, bae/repl/shell.py</files>
  <action>
**Gap 1 -- stdout capture in async_exec (bae/repl/exec.py):**

Wrap the execution body of `async_exec` with a `contextlib.redirect_stdout` (or manual `sys.stdout` swap) to a `StringIO` buffer. Return a **tuple** `(result, captured_stdout)` instead of bare `result`.

- `result` behaves exactly as today: the last-expression value or `None`
- `captured_stdout` is the `StringIO.getvalue()` string (empty string if nothing printed)

The capture must wrap the entire execution including the `await` path. Use `io.StringIO` and `sys.stdout` swap in a try/finally to guarantee restoration:

```python
import sys
from io import StringIO

buf = StringIO()
old_stdout = sys.stdout
sys.stdout = buf
try:
    # ... existing compile + execute logic ...
finally:
    sys.stdout = old_stdout
captured = buf.getvalue()
```

Return `(result, captured)` at every return path.

**Gap 2 -- SessionStore callable (bae/repl/store.py):**

1. Delete `make_store_inspector()` entirely.
2. Add `__call__` method to `SessionStore` that implements the inspector behavior currently in the closure:
   - `store()` with no args prints session summary, returns `None`
   - `store('query')` prints FTS5 search results, returns `None`
   - Both cases return `None` (not the entries list) to suppress repr noise
   - Convert Row objects to dicts before printing so the output is clean
3. Keep all existing methods (`sessions()`, `recent()`, `search()`, `session_entries()`, `record()`, `close()`) untouched.

**Wire changes into shell (bae/repl/shell.py):**

1. Update the `async_exec` call site in the PY mode handler to unpack the tuple:
   ```python
   result, captured = await async_exec(text, self.namespace)
   if captured:
       print(captured, end="")
       self.store.record("PY", "repl", "output", captured, {"type": "stdout"})
   ```
   The `if result is not None:` block stays after, unchanged.

2. Replace `make_store_inspector` import and usage:
   - Remove `from bae.repl.store import ... make_store_inspector`
   - Change `self.namespace["store"] = make_store_inspector(self.store)` to `self.namespace["store"] = self.store`
   - Now `store.sessions()`, `store.recent()`, etc. all work from the REPL namespace.
  </action>
  <verify>
Run `uv run pytest tests/repl/test_exec.py tests/repl/test_store.py tests/repl/test_store_integration.py -x` -- expect failures in tests that depend on the old return type of async_exec and the old make_store_inspector. These will be fixed in Task 2.
  </verify>
  <done>
async_exec returns (result, stdout) tuple. SessionStore is callable with inspector display. Shell unpacks stdout and records it. Shell injects SessionStore instance directly into namespace.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tests for new async_exec return type and callable SessionStore</name>
  <files>tests/repl/test_exec.py, tests/repl/test_store.py, tests/repl/test_store_integration.py</files>
  <action>
**Update test_exec.py:**

Every `await async_exec(...)` call now returns `(result, captured_stdout)`. Update all assertions:

- `test_expr_returns_value`: unpack `result, stdout = await async_exec(...)`, assert `result == 2`, assert `stdout == ""`
- `test_assignment_returns_none`: unpack, assert `result is None`, assert `stdout == ""`
- `test_for_loop_with_underscore_returns_none`: unpack, assert `result is None`, assert `stdout == ""`
- `test_for_loop_with_print_returns_none`: unpack, **remove** the `patch("sys.stdout")` mock (async_exec now captures internally), assert `result is None`, assert `stdout == "0\n1\n2\n3\n4\n"`
- `test_await_expr_returns_value`: unpack, assert `result == "done"`, assert `stdout == ""`
- `test_multiline_last_expr`: unpack, assert `result == 15`, assert `stdout == ""`
- `test_multiline_last_statement`: unpack, assert `result is None`, assert `stdout == ""`

Add one new test:
- `test_print_captures_stdout`: `result, stdout = await async_exec("print('hello')", {})`, assert `result is None`, assert `stdout == "hello\n"`

**Update test_store_integration.py:**

- `test_store_inspector_prints_session`: replace `make_store_inspector(store)` with direct `store()` call. `store()` now returns `None`, so assert `result is None`. Check `capsys` output still contains session line.
- `test_store_inspector_search`: replace `make_store_inspector(store)` with direct `store('hello')` call. `store('hello')` returns `None`, so assert `result is None`. Check `capsys` output still contains "hello".
- Remove `make_store_inspector` from the import line.

Add one new test:
- `test_store_sessions_accessible`: call `store.sessions()`, assert it returns a list, assert `store.session_id` appears in the session IDs. This directly validates the UAT gap (AttributeError no longer occurs).

**Update test_store.py:**

No changes expected -- the unit tests use `SessionStore` methods directly, not the inspector.
  </action>
  <verify>
Run `uv run pytest tests/repl/ -x -v` -- ALL tests must pass, zero failures. Then run `uv run pytest -x` for full suite sanity (ignore known pre-existing failures in test_fill_protocol.py and test_integration.py).
  </verify>
  <done>
All repl tests pass. New tests verify: (1) async_exec captures print() stdout in its return tuple, (2) SessionStore.__call__ works as inspector without repr noise, (3) store.sessions() is accessible from the same object in namespace.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/repl/ -x -v` -- all tests pass
2. `uv run pytest tests/repl/test_exec.py::test_print_captures_stdout -v` -- new stdout capture test passes
3. `uv run pytest tests/repl/test_store_integration.py::test_store_sessions_accessible -v` -- new cross-session test passes
4. `uv run python -c "from bae.repl.exec import async_exec; import asyncio; r = asyncio.run(async_exec('print(42)', {})); print(type(r), r)"` -- returns tuple with stdout="42\n"
</verification>

<success_criteria>
- print() output during PY mode execution is captured and stored (UAT test 4 gap closed)
- store.sessions() works from the REPL namespace (UAT test 6 gap closed)
- store() display returns None (no Row repr noise)
- All existing repl tests updated and passing
- New tests cover both gaps
</success_criteria>

<output>
After completion, create `.planning/phases/15-session-store/15-03-SUMMARY.md`
</output>
