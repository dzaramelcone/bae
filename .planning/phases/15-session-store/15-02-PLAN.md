---
phase: 15-session-store
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - bae/repl/shell.py
  - bae/repl/bash.py
  - tests/repl/test_store_integration.py
autonomous: true

must_haves:
  truths:
    - "Every REPL input is recorded to the session store with mode and direction='input'"
    - "Every REPL output is recorded to the session store with mode, direction='output', and type metadata"
    - "Bash stdout and stderr are recorded as separate entries with stream metadata"
    - "store() is callable in the REPL namespace and shows session entries"
    - "store('query') searches across all entries via FTS5"
    - "Store is closed on shutdown (Ctrl-D / EOFError path)"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "CortexShell with store integration at all I/O points"
      contains: "self.store"
    - path: "bae/repl/bash.py"
      provides: "dispatch_bash returning stdout/stderr for store recording"
      contains: "return"
    - path: "tests/repl/test_store_integration.py"
      provides: "Integration tests for store recording across all modes"
      contains: "test_py_mode_records"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/store.py"
      via: "self.store = SessionStore(...) in __init__, store.record() in run()"
      pattern: "self\\.store\\.record"
    - from: "bae/repl/shell.py"
      to: "store() namespace callable"
      via: "self.namespace['store'] = make_store_inspector(self.store)"
      pattern: "make_store_inspector"
    - from: "bae/repl/bash.py"
      to: "bae/repl/shell.py"
      via: "dispatch_bash returns (stdout, stderr) tuple for shell to record"
      pattern: "return.*stdout.*stderr"
---

<objective>
Wire SessionStore into the REPL loop so every input and output is automatically recorded, and expose store() for user inspection.

Purpose: Satisfies STORE-01 (all I/O persisted), STORE-03 (cross-session via project-local .bae/store.db), and STORE-04 (store() inspection).
Output: Modified `shell.py` and `bash.py`, new `tests/repl/test_store_integration.py`.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-session-store/15-RESEARCH.md
@.planning/phases/15-session-store/15-01-SUMMARY.md
@bae/repl/shell.py
@bae/repl/bash.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hook store into shell.py and modify bash.py return value</name>
  <files>bae/repl/shell.py, bae/repl/bash.py</files>
  <action>
**bash.py changes:**

Modify `dispatch_bash()` to return a `tuple[str, str]` of (stdout_text, stderr_text) instead of printing directly. The shell caller will print AND record.

- For `cd` commands: return `("", "")` on success, `("", error_message)` on failure. Remove the `print_formatted_text` call for errors -- the shell handles display.
- For subprocess commands: decode stdout/stderr, print them as before (stdout plain, stderr red via `print_formatted_text`), then return the decoded strings.
- Return type annotation: `async def dispatch_bash(cmd: str) -> tuple[str, str]`

**shell.py changes:**

1. **Import store:** `from bae.repl.store import SessionStore, make_store_inspector` and `from pathlib import Path`

2. **__init__:** After creating `self.namespace`, add:
   ```python
   self.store = SessionStore(Path.cwd() / ".bae" / "store.db")
   self.namespace["store"] = make_store_inspector(self.store)
   ```

3. **run() loop -- record input** (after `if not text.strip(): continue`):
   ```python
   self.store.record(self.mode.value, "repl", "input", text)
   ```

4. **PY mode -- record output:**
   - After `result = await async_exec(text, self.namespace)`: if result is not None, `output = repr(result)`, print it, then `self.store.record("PY", "repl", "output", output, {"type": "expr_result"})`.
   - In the `except Exception` block: capture `tb = traceback.format_exc()`, print_exc as before, then `self.store.record("PY", "repl", "output", tb, {"type": "error"})`.

5. **NL mode -- record output:**
   - Capture the stub text, print it, record: `self.store.record("NL", "repl", "output", stub_text)`

6. **GRAPH mode -- record output:**
   - Capture the stub text, print it, record: `self.store.record("GRAPH", "repl", "output", stub_text)`

7. **BASH mode -- record output:**
   - Change `await dispatch_bash(text)` to `stdout, stderr = await dispatch_bash(text)`.
   - If stdout: `self.store.record("BASH", "stdout", "output", stdout)`
   - If stderr: `self.store.record("BASH", "stderr", "output", stderr, {"type": "stderr"})`

8. **Shutdown:** In `_shutdown()` or at the EOFError handler, add `self.store.close()`. Also close on KeyboardInterrupt path.

**make_store_inspector function** (add to `bae/repl/store.py`):

```python
def make_store_inspector(store: SessionStore):
    """Create a namespace callable for store inspection."""
    def store_fn(query: str | None = None, n: int = 20):
        if query:
            entries = store.search(query, limit=n)
            for e in entries:
                print(f"[{e['mode']}:{e['channel']}:{e['direction']}] {e['content'][:80]}")
        else:
            entries = store.session_entries()
            print(f"Session {store.session_id}: {len(entries)} entries")
            for e in entries[-n:]:
                print(f"  [{e['mode']}:{e['direction']}] {e['content'][:60]}")
        return entries
    store_fn.__doc__ = "Inspect stored context. store() shows session, store('query') searches."
    return store_fn
```

Keep changes minimal. Do not restructure the existing if/elif mode dispatch.
  </action>
  <verify>uv run ruff check bae/repl/shell.py bae/repl/bash.py && uv run pytest tests/repl/ -x</verify>
  <done>shell.py creates SessionStore, records all I/O, exposes store() in namespace, closes on exit. bash.py returns output tuple.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for store recording across all modes</name>
  <files>tests/repl/test_store_integration.py</files>
  <action>
Create `tests/repl/test_store_integration.py` with integration tests that verify the store records correctly when called through the shell's mode handlers.

These tests do NOT launch a full REPL -- they instantiate CortexShell components and call store.record() in the same patterns the shell uses. Use `tmp_path` for the store database.

Tests to write:

1. `test_py_mode_records_input_and_output` -- Create a SessionStore with tmp_path db. Record a PY input and expr_result output. Verify `session_entries()` has 2 entries with correct mode, channel, direction, content.

2. `test_bash_mode_records_stdout_and_stderr` -- Record BASH stdout and stderr entries. Verify they appear as separate entries with correct channels ("stdout", "stderr") and metadata.

3. `test_nl_mode_records_stub` -- Record NL input and stub output. Verify entries exist.

4. `test_store_inspector_prints_session` -- Create store, record 3 entries, call `make_store_inspector(store)()` and capture stdout. Verify it prints session ID and entry count.

5. `test_store_inspector_search` -- Record entries including one with "hello world". Call `store_fn("hello")` and verify it returns matching entries.

6. `test_dispatch_bash_returns_tuple` -- Call `dispatch_bash("echo hello")` and verify it returns a `(stdout, stderr)` tuple with stdout containing "hello".

7. `test_dispatch_bash_cd_returns_empty` -- Call `dispatch_bash("cd /tmp")` and verify it returns `("", "")`.

8. `test_cross_session_persistence` -- Create two SessionStore instances on the same db file (different sessions). Record entries in each. Close both. Open a third SessionStore on the same file. Verify `sessions()` returns 3 sessions and `recent()` returns entries from all.

Run: `uv run pytest tests/repl/test_store_integration.py -v` -- all pass.
  </action>
  <verify>uv run pytest tests/repl/test_store_integration.py -v && uv run pytest tests/ -x</verify>
  <done>8 integration tests pass, full test suite passes with no regressions</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/repl/ -v` -- all store + integration tests pass
2. `uv run pytest tests/ -x` -- full suite passes
3. `uv run ruff check bae/repl/` -- no lint errors
4. Verify store() is in the namespace by checking shell.py source
</verification>

<success_criteria>
- Every REPL input and output is automatically recorded to the session store
- Bash stdout/stderr recorded as separate entries
- store() callable prints session entries, store("query") searches
- Store closes cleanly on shutdown
- Cross-session persistence verified (same .bae/store.db, multiple sessions)
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/15-session-store/15-02-SUMMARY.md`
</output>
