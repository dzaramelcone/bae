---
phase: 17-namespace
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [bae/repl/exec.py, tests/repl/test_namespace.py]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "ns(MyNode) shows fields with dep/recall/plain classification for Node subclasses defined in the REPL"
    - "Graph creation from REPL-defined Node subclasses works (get_type_hints resolves Annotated/Dep/Recall)"
    - "lm.fill and compiler work with REPL-defined classes (all get_type_hints call sites resolve correctly)"
  artifacts:
    - path: "bae/repl/exec.py"
      provides: "_ensure_cortex_module function and call in async_exec"
      contains: "_ensure_cortex_module"
    - path: "tests/repl/test_namespace.py"
      provides: "Test that ns() works with REPL-simulated classes"
      contains: "cortex_module"
  key_links:
    - from: "bae/repl/exec.py"
      to: "sys.modules['<cortex>']"
      via: "_ensure_cortex_module registering module before compile()"
      pattern: "sys\\.modules\\[.*cortex.*\\]"
---

<objective>
Fix NameError when inspecting REPL-defined Node subclasses with ns().

Classes defined in the REPL get `__module__='<cortex>'` from `compile(tree, '<cortex>', 'exec')`.
When `get_type_hints()` is called on these classes, Python looks up `<cortex>` in
`sys.modules` to resolve string annotations. Since `<cortex>` is not registered,
`get_type_hints()` fails with `NameError: name 'Annotated' is not defined`.

Fix: Register `<cortex>` as a module in `sys.modules` with the REPL namespace as its
`__dict__`, so all `get_type_hints()` calls across bae (resolver.py, graph.py, lm.py,
compiler.py) resolve correctly for REPL-defined classes. Zero changes to production code.

Purpose: Close UAT gap -- ns(MyNode) must work for REPL-defined Node subclasses.
Output: Patched exec.py, updated tests.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-namespace/17-01-SUMMARY.md
@.planning/phases/17-namespace/17-02-SUMMARY.md
@.planning/phases/17-namespace/17-UAT.md
@.planning/debug/ns-annotated-nameerror-repl.md
@.planning/debug/fix-options-analysis.md
@bae/repl/exec.py
@bae/repl/namespace.py
@tests/repl/test_namespace.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register cortex module in sys.modules for REPL annotation resolution</name>
  <files>bae/repl/exec.py</files>
  <action>
Add `_ensure_cortex_module(namespace)` function to exec.py. This function:
1. Checks if `<cortex>` is already in `sys.modules`
2. If not, creates a `types.ModuleType('<cortex>')` and registers it in `sys.modules`
3. Updates the module's `__dict__` with the current namespace contents via `update()`

Call `_ensure_cortex_module(namespace)` at the top of `async_exec()`, BEFORE `compile()`.
This must happen on every exec call because the REPL namespace grows as the user defines
new names -- the module dict must stay in sync.

Implementation (add before async_exec):
```python
def _ensure_cortex_module(namespace: dict) -> None:
    """Register <cortex> as a module so get_type_hints resolves REPL-defined classes."""
    mod = sys.modules.get('<cortex>')
    if mod is None:
        mod = types.ModuleType('<cortex>')
        sys.modules['<cortex>'] = mod
    mod.__dict__.update(namespace)
```

Then in async_exec, add this line before `compiled = compile(...)`:
```python
_ensure_cortex_module(namespace)
```

Note: `sys` and `types` are already imported in exec.py. No new imports needed.
  </action>
  <verify>
`uv run python -m pytest tests/repl/ -q` -- all existing 114 tests still pass (zero regressions).
  </verify>
  <done>
_ensure_cortex_module exists in exec.py. Called before compile() in async_exec. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test proving ns() works with REPL-simulated Node subclass</name>
  <files>tests/repl/test_namespace.py</files>
  <action>
Add a test that simulates the exact UAT failure scenario: a Node subclass defined in
REPL-like conditions (with `__module__='<cortex>'`) inspected via `ns()`.

The test must:
1. Call `async_exec()` with code that defines a Node subclass using `Annotated[str, Dep()]`
   fields, using a namespace from `seed()`. This is what the REPL does -- it calls
   `async_exec(code, self.namespace)` and the class gets `__module__='<cortex>'`.
2. Extract the defined class from the namespace.
3. Call the NsInspector on that class.
4. Assert the output contains field information (field name, "dep" kind) without NameError.

```python
@pytest.mark.asyncio
async def test_inspect_repl_defined_node_class(capsys):
    """ns(NodeClass) works for classes defined via async_exec (REPL simulation).

    Classes defined in the REPL get __module__='<cortex>' from compile().
    _ensure_cortex_module registers <cortex> in sys.modules so
    get_type_hints() can resolve Annotated/Dep/Recall annotations.
    """
    from bae.repl.exec import async_exec

    ns = seed()
    # Define a Node subclass as the REPL would -- via async_exec
    code = textwrap.dedent("""\
        class TestNode(Node):
            query: str
            info: Annotated[str, Dep()]

            async def __call__(self) -> None: ...
    """)
    await async_exec(code, ns)

    test_cls = ns["TestNode"]
    assert test_cls.__module__ == "<cortex>"

    # ns(TestNode) must not crash -- it calls classify_fields + get_type_hints
    inspector = ns["ns"]
    inspector(test_cls)
    output = capsys.readouterr().out

    assert "TestNode(Node)" in output
    assert "query" in output
    assert "plain" in output
    assert "info" in output
    assert "dep" in output
```

Add the necessary import at the top of the test file: `import textwrap` (if not already present).
Also add `import pytest` for the asyncio marker (already imported).

Ensure `pytest-asyncio` is available (it should be -- check pyproject.toml or just run).
If the test collection requires `asyncio_mode = "auto"`, use the `@pytest.mark.asyncio` decorator.
  </action>
  <verify>
`uv run python -m pytest tests/repl/test_namespace.py::test_inspect_repl_defined_node_class -v` -- passes.
`uv run python -m pytest tests/repl/ -q` -- all tests pass including the new one (115 total).
  </verify>
  <done>
New test proves ns() works on REPL-defined Node subclasses. 115/115 REPL tests pass.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -m pytest tests/repl/ -q` -- 115 tests pass, zero regressions
2. Manually verify: `uv run python -c "import sys; from bae.repl.exec import async_exec; from bae.repl.namespace import seed; import asyncio; ns = seed(); asyncio.run(async_exec('class T(__import__(\"bae\").Node):\n  x: __import__(\"typing\").Annotated[str, __import__(\"bae\").Dep()]\n  async def __call__(self) -> None: ...', ns)); print(ns['T'].__module__)"` prints `<cortex>` and `<cortex>` is in sys.modules
</verification>

<success_criteria>
- _ensure_cortex_module function exists in bae/repl/exec.py
- Called before compile() in async_exec on every invocation
- sys.modules['<cortex>'] contains REPL namespace contents after exec
- ns(REPLDefinedNodeClass) prints field info without NameError
- All 115 REPL tests pass (114 existing + 1 new)
</success_criteria>

<output>
After completion, create `.planning/phases/17-namespace/17-03-SUMMARY.md`
</output>
