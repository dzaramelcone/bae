---
phase: 17-namespace
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - bae/repl/shell.py
  - tests/repl/test_namespace_integration.py
autonomous: true

must_haves:
  truths:
    - "Node, Graph, Dep, Recall are available in the REPL namespace without importing"
    - "After executing an expression, _ holds the result"
    - "After running a graph, _trace holds the trace list"
    - "Calling ns() in the REPL prints namespace contents"
    - "_trace is set even when graph execution raises an error (partial trace from exception)"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "Shell using seed() for namespace init and _trace capture after graph runs"
      contains: "from bae.repl.namespace import seed"
    - path: "tests/repl/test_namespace_integration.py"
      provides: "Integration tests for namespace in shell context"
      min_lines: 30
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/namespace.py"
      via: "seed() call in __init__"
      pattern: "seed\\(\\)"
    - from: "bae/repl/shell.py"
      to: "namespace['_trace']"
      via: "assignment after channel_arun returns"
      pattern: "_trace.*=.*trace"
---

<objective>
Wire namespace.py into the shell: replace inline namespace dict with seed(), capture _trace after graph runs, and verify the full integration works.

Purpose: Connects the tested namespace module to the live REPL. After this plan, all four success criteria from the roadmap are satisfied.
Output: Modified `bae/repl/shell.py`, `tests/repl/test_namespace_integration.py`
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-namespace/17-RESEARCH.md
@.planning/phases/17-namespace/17-01-SUMMARY.md
@bae/repl/shell.py
@bae/repl/namespace.py
@bae/repl/exec.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire seed() into shell and capture _trace</name>
  <files>bae/repl/shell.py</files>
  <action>
    1. Add import: `from bae.repl.namespace import seed`
    2. Remove direct `import asyncio` and `import os` from shell.py (seed() handles these now). Keep any other stdlib imports that shell.py uses for its own logic (asyncio is still needed for `asyncio.Task` type hint and `asyncio.gather` in _shutdown, so keep it).
    3. In `CortexShell.__init__`, replace the inline namespace dict:
       ```python
       # OLD:
       self.namespace: dict = {"asyncio": asyncio, "os": os, "__builtins__": __builtins__}
       # NEW:
       self.namespace: dict = seed()
       ```
    4. Keep the existing `self.namespace["store"] = self.store` and `self.namespace["channels"] = self.router` lines after seed() -- these add runtime objects that seed() cannot know about.
    5. In the GRAPH mode handler (the `elif self.mode == Mode.GRAPH:` block), capture `_trace` after `channel_arun` returns. Also capture partial trace on error:
       ```python
       elif self.mode == Mode.GRAPH:
           graph = self.namespace.get("graph")
           if graph:
               try:
                   result = await channel_arun(graph, text, self.router)
               except Exception as exc:
                   trace = getattr(exc, "trace", None)
                   if trace:
                       self.namespace["_trace"] = trace
                   raise
               if result and result.trace:
                   self.namespace["_trace"] = result.trace
           else:
               stub = "(Graph mode stub) Not yet implemented."
               self.router.write("graph", stub, mode="GRAPH")
       ```
       Note: the `raise` in the except block will be caught by the outer try/except in the run() loop. The existing traceback formatting in PY mode doesn't apply to GRAPH mode. For GRAPH mode errors, add a try/except around the whole GRAPH block that routes the traceback through the graph channel, matching the pattern used in PY mode:
       ```python
       elif self.mode == Mode.GRAPH:
           graph = self.namespace.get("graph")
           if graph:
               try:
                   result = await channel_arun(graph, text, self.router)
                   if result and result.trace:
                       self.namespace["_trace"] = result.trace
               except Exception as exc:
                   trace = getattr(exc, "trace", None)
                   if trace:
                       self.namespace["_trace"] = trace
                   tb = traceback.format_exc()
                   self.router.write("graph", tb.rstrip("\n"), mode="GRAPH", metadata={"type": "error"})
           else:
               stub = "(Graph mode stub) Not yet implemented."
               self.router.write("graph", stub, mode="GRAPH")
       ```
  </action>
  <verify>
    ```bash
    cd /Users/dzaramelcone/lab/bae && python -c "from bae.repl.shell import CortexShell; s = CortexShell(); assert 'Node' in s.namespace; assert 'Graph' in s.namespace; assert 'Dep' in s.namespace; assert 'Recall' in s.namespace; assert 'ns' in s.namespace; assert callable(s.namespace['ns']); print('OK: namespace seeded with bae types + ns')"
    ```
  </verify>
  <done>CortexShell namespace contains Node, Graph, Dep, Recall, ns, store, channels. GRAPH mode captures _trace on success and on error.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for namespace wiring</name>
  <files>tests/repl/test_namespace_integration.py</files>
  <action>
    Create integration tests that verify:

    1. **Shell namespace contains bae types** -- instantiate CortexShell, assert Node/Graph/Dep/Recall/ns/store/channels all present in namespace.

    2. **_ capture works via async_exec** -- call async_exec("42", namespace) and assert namespace["_"] == 42. (This already works from Phase 14, but verify it in the namespace context.)

    3. **_trace capture on successful graph run** -- create a minimal 2-node test graph (StartNode -> TerminalNode), put it in namespace as "graph", call channel_arun directly with a mock router, assert namespace["_trace"] is the trace list.

    4. **_trace capture on error** -- create a graph that raises BaeError with a .trace attribute, call channel_arun, assert _trace was captured from the exception.

    5. **ns() callable in namespace** -- call ns() (the NsInspector from namespace), capture stdout, assert it lists "Node", "Graph" etc.

    Use the test patterns from test_channels.py: MagicMock for store, real objects where possible. Use capsys or a StringIO redirect for capturing ns() print output.

    For graph tests, define minimal Node subclasses inline in the test file:
    ```python
    class Start(Node):
        msg: str
        async def __call__(self) -> End | None:
            return End(result=self.msg)

    class End(Node):
        result: str
        async def __call__(self) -> None:
            ...
    ```
  </action>
  <verify>
    ```bash
    cd /Users/dzaramelcone/lab/bae && python -m pytest tests/repl/test_namespace_integration.py -v
    ```
  </verify>
  <done>All integration tests pass. Namespace seeding, _ capture, _trace capture, and ns() callable all verified in a shell-like context.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/dzaramelcone/lab/bae && python -m pytest tests/repl/ -v
```
All REPL tests pass (test_exec, test_store, test_channels, test_namespace, test_namespace_integration, test_store_integration).

```bash
cd /Users/dzaramelcone/lab/bae && python -m pytest --tb=short
```
Full test suite passes.
</verification>

<success_criteria>
- CortexShell.__init__ uses seed() instead of inline dict
- Node, Graph, Dep, Recall available in namespace without import (NS-01)
- _ holds last expression result (NS-02, already worked, now verified)
- _trace holds last graph trace after successful run (NS-02)
- _trace holds partial trace after failed graph run (NS-02)
- ns() is callable in namespace and lists objects (NS-03)
- Full REPL test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/17-namespace/17-02-SUMMARY.md`
</output>
