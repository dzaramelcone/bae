---
phase: 17-namespace
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/repl/namespace.py
  - tests/repl/test_namespace.py
autonomous: true

must_haves:
  truths:
    - "seed() returns a dict containing Node, Graph, Dep, Recall, and other bae types"
    - "NsInspector() with no args prints all namespace objects with types and one-line summaries"
    - "NsInspector(graph) prints topology: nodes, edges, terminals"
    - "NsInspector(NodeClass) prints fields with type, kind (dep/recall/plain), and successors"
    - "NsInspector(node_instance) prints class fields plus current field values"
    - "Typing ns without parens shows a helpful repr string"
    - "ns() skips keys starting with _ so __builtins__ doesn't flood the output"
  artifacts:
    - path: "bae/repl/namespace.py"
      provides: "seed() function and NsInspector callable class"
      exports: ["seed", "NsInspector"]
    - path: "tests/repl/test_namespace.py"
      provides: "Unit tests for seed and NsInspector"
      min_lines: 80
  key_links:
    - from: "bae/repl/namespace.py"
      to: "bae"
      via: "import bae.Node, bae.Graph, bae.Dep, bae.Recall etc"
      pattern: "import bae"
    - from: "bae/repl/namespace.py"
      to: "bae.resolver.classify_fields"
      via: "import for Node field classification in _inspect_node_class"
      pattern: "classify_fields"
---

<objective>
Create `bae/repl/namespace.py` with a `seed()` function that builds the initial REPL namespace dict (NS-01) and an `NsInspector` callable class that implements `ns()` for listing and `ns(obj)` for introspection (NS-03, NS-04).

Purpose: All namespace logic lives in one testable module. TDD ensures the output formatting and dispatch work correctly before wiring into the shell.
Output: `bae/repl/namespace.py`, `tests/repl/test_namespace.py`
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-namespace/17-RESEARCH.md
@bae/__init__.py
@bae/repl/shell.py
@bae/graph.py
@bae/node.py
@bae/resolver.py
@bae/markers.py
@bae/result.py
@tests/repl/test_channels.py
</context>

<feature>
  <name>Namespace seeding and introspection</name>
  <files>bae/repl/namespace.py, tests/repl/test_namespace.py</files>
  <behavior>
    seed() -> dict containing:
      - "Node": bae.Node, "Graph": bae.Graph, "Dep": bae.Dep, "Recall": bae.Recall
      - "GraphResult": bae.GraphResult, "LM": bae.LM, "NodeConfig": bae.NodeConfig
      - "Annotated": typing.Annotated
      - "asyncio": asyncio, "os": os, "__builtins__": __builtins__
      - "ns": NsInspector instance (bound to the returned dict)

    NsInspector.__repr__() -> "ns() -- inspect namespace. ns(obj) -- inspect object."

    NsInspector(None) / ns() -> prints column-aligned table of all non-underscore namespace entries:
      Each line: "  {name}  {type_label}  {summary}"
      type_label: "class" for types, type(obj).__name__ for instances
      Skips keys starting with "_"

    NsInspector(graph_instance) / ns(graph) -> prints:
      "Graph(start={StartName})"
      "  Nodes: {count}"
      "    {NodeName} -> {Succ1}, {Succ2}"  (or "(terminal)" if no successors)
      "  Terminals: {Term1}, {Term2}"

    NsInspector(NodeSubclass) / ns(MyNode) -> prints:
      "{ClassName}(Node)"
      "  {first line of docstring}" (if docstring exists)
      "  Successors: {S1} | {S2}" (if any)
      "  Terminal: yes/no"
      "  Fields:"
      "    {name}  {type}  {kind}" (kind = dep/recall/plain from classify_fields)
      For dep fields, append "  Dep({fn_name})"
      For recall fields, append "  Recall()"

    NsInspector(node_instance) / ns(my_node) -> same as class inspection plus:
      "  Values:"
      "    {name} = {repr(value)}" for each field with a value

    NsInspector(other_obj) / ns(x) -> prints:
      "{type(x).__name__}: {repr(x)}" (truncated to 200 chars)
  </behavior>
  <implementation>
    Use plain print() inside all NsInspector methods so output flows through async_exec stdout capture and routes through the [py] channel correctly. Do NOT use print_formatted_text (bypasses capture).

    Use bae.resolver.classify_fields() for Node field classification -- do not reimplement.
    Use textwrap.shorten() for truncating long repr strings.
    Use inspect.isclass() for distinguishing classes from instances.

    The NsInspector.__init__ takes the namespace dict reference. seed() creates the dict, creates the NsInspector with that dict, and inserts it as "ns" before returning.

    For _one_liner(obj) summary helper:
      - type -> first line of __doc__ or class name
      - module -> module name
      - SessionStore -> "Session persistence ({count} entries)" using len(obj)
      - ChannelRouter -> "{N} channels ({M} visible)"
      - NsInspector -> "ns() -- inspect namespace"
      - callable -> qualname or repr
      - else -> truncated repr

    Sort items alphabetically in _list_all. Column-align name and type columns.
  </implementation>
</feature>

<verification>
```bash
cd /Users/dzaramelcone/lab/bae && python -m pytest tests/repl/test_namespace.py -v
```
All tests pass. No import errors from namespace.py.
</verification>

<success_criteria>
- seed() returns dict with all required bae types (Node, Graph, Dep, Recall + extras)
- NsInspector dispatches correctly: no-arg lists, Graph shows topology, Node shows fields, instance shows values
- All output uses print() not print_formatted_text
- Tests cover each dispatch path with assertions on printed output
- classify_fields() reused from bae.resolver, not reimplemented
</success_criteria>

<output>
After completion, create `.planning/phases/17-namespace/17-01-SUMMARY.md`
</output>
