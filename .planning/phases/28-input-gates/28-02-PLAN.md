---
phase: 28-input-gates
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - bae/repl/engine.py
  - bae/repl/graph_commands.py
  - tests/repl/test_engine.py
  - tests/repl/test_graph_commands.py
autonomous: true

must_haves:
  truths:
    - "When a graph node has Gate-annotated fields, execution suspends until user provides values"
    - "The engine transitions GraphRun to WAITING when gates are pending and back to RUNNING when resolved"
    - "`input <gate_id> <value>` in GRAPH mode resolves a pending gate with type coercion"
    - "Gate creation emits an inline notification through the graph channel showing what input is needed"
    - "Multiple gate fields on one node all suspend concurrently via asyncio.gather"
  artifacts:
    - path: "bae/repl/engine.py"
      provides: "Gate-aware execution in _execute"
      contains: "WAITING"
    - path: "bae/repl/graph_commands.py"
      provides: "input command handler"
      contains: "_cmd_input"
  key_links:
    - from: "bae/repl/engine.py"
      to: "bae/resolver.py"
      via: "classify_fields to detect gate fields before resolve_fields"
      pattern: "classify_fields"
    - from: "bae/repl/engine.py"
      to: "bae/markers.py"
      via: "Gate marker import for metadata extraction"
    - from: "bae/repl/graph_commands.py"
      to: "bae/repl/engine.py"
      via: "engine.get_pending_gate + engine.resolve_gate"
    - from: "bae/repl/graph_commands.py"
      to: "bae/repl/shell.py"
      via: "_make_notify checks shell.shush_gates before emitting"
      pattern: "shush_gates"
---

<objective>
Wire gate execution into the engine's _execute loop and add the `input` command to GRAPH mode.

Purpose: This is the core suspension mechanism. When the engine encounters a node with Gate-annotated fields during execution, it creates InputGates (Futures), transitions to WAITING, and awaits the Futures. The `input` command lets Dzara resolve gates from GRAPH mode with type coercion.

Output: End-to-end gate suspension and resolution. A graph with Gate fields pauses, Dzara sees the notification, types `input g1.0 yes`, and the graph resumes.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/28-input-gates/28-RESEARCH.md
@.planning/phases/28-input-gates/28-01-SUMMARY.md

@bae/repl/engine.py
@bae/repl/graph_commands.py
@bae/graph.py
@bae/resolver.py
@bae/markers.py
@tests/repl/test_engine.py
@tests/repl/test_graph_commands.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Engine gate interception in _execute</name>
  <files>bae/repl/engine.py, tests/repl/test_engine.py</files>
  <action>
The engine must intercept gate fields during graph execution. The approach: wrap `Graph.arun()` with a gate-aware layer that pre-scans each node for gate fields, creates Futures, and injects resolved gate values.

**Implementation approach -- gate-aware resolve_fields wrapper:**

The engine cannot easily hook into `Graph.arun()`'s per-node loop from outside. Instead, use the `dep_cache` injection mechanism:

1. Add a `_gate_resolve_hook` callable that the engine injects into dep_cache with a sentinel key `GATE_HOOK_KEY = object()`.

2. In `bae/resolver.py`, extend `resolve_fields()`:
   - After classifying fields, check for any "gate" fields.
   - If gate fields exist AND `dep_cache.get(GATE_HOOK_KEY)` is not None, call the hook: `gate_values = await dep_cache[GATE_HOOK_KEY](node_cls, gate_fields_info)`.
   - The hook returns a dict of `{field_name: value}` for gate fields.
   - Include gate values in the returned resolved dict alongside dep and recall values.
   - If no hook is present (e.g. running outside cortex), gate fields are simply not resolved (they remain as plain fields for the LM -- which is wrong but graceful degradation).

3. In `bae/repl/engine.py`, in `_execute()`:
   - Define `GATE_HOOK_KEY` as a module-level sentinel.
   - Create an async gate hook function that:
     a. Receives `(node_cls, gate_fields)` where gate_fields is a list of `(field_name, field_type, description)` tuples.
     b. For each gate field, calls `self.create_gate(run.run_id, field_name, field_type, description, node_cls.__name__)`.
     c. Transitions `run.state` to `GraphState.WAITING`.
     d. Emits notification via the `_notify` callback (passed to _execute or stored on self).
     e. Awaits all gate Futures concurrently: `results = await asyncio.gather(*[g.future for g in gates])`.
     f. Transitions `run.state` back to `GraphState.RUNNING`.
     g. Returns `{gate.field_name: result for gate, result in zip(gates, results)}`.
   - Inject the hook into dep_cache: `dep_cache[GATE_HOOK_KEY] = gate_hook`.

4. Update `resolve_fields()` in `bae/resolver.py` to handle gate fields:
   - Import `GATE_HOOK_KEY` from engine would create circular import. Instead, define `GATE_HOOK_KEY` in resolver.py (alongside `LM_KEY`) and import it in engine.py.
   - After building dep_fields and recall_fields dicts, also build a `gate_fields` list of `(field_name, base_type, gate_description)` for each gate-classified field.
   - Extract the Gate marker's description from metadata.
   - If gate_fields is non-empty and `GATE_HOOK_KEY` in dep_cache, await the hook and merge results into the resolved dict.

5. Add a `_notify` parameter to `GraphRegistry.submit()` and `_execute()` -- an optional async callback `(str) -> None` that the engine calls when gates are created. The callback receives a formatted notification string. If not provided, no notification is emitted (tests can omit it).

**Tests in `tests/repl/test_engine.py`:**
- `test_gate_hook_creates_gates`: Mock graph with a Gate field, verify InputGates are created and engine transitions to WAITING.
- `test_gate_hook_resumes_on_resolve`: Create a gate via the hook, resolve it from another task, verify graph resumes and gate value is used.
- `test_multiple_gate_fields_concurrent`: Node with 2 gate fields, both Futures created, resolve independently, graph resumes when both resolved.
- `test_gate_cancel_during_waiting`: Cancel a graph while WAITING, verify CancelledError and gate cleanup.

For test mocking: create a minimal Node subclass with Gate fields. Use a MockLM that returns a simple terminal node. The test submits the graph, waits briefly for WAITING state, resolves the gate, and verifies the result.
  </action>
  <verify>
`uv run pytest tests/repl/test_engine.py -x -q` passes. `uv run pytest tests/test_resolver.py -x -q` passes (no resolver regressions).
  </verify>
  <done>Engine intercepts gate fields during graph execution via dep_cache hook. Graph transitions to WAITING when gates pending, resumes to RUNNING when resolved. Gate values flow into node construction. Cancellation cleans up pending gates.</done>
</task>

<task type="auto">
  <name>Task 2: GRAPH mode input command with type coercion and notification</name>
  <files>bae/repl/graph_commands.py, bae/repl/engine.py, tests/repl/test_graph_commands.py</files>
  <action>
1. In `bae/repl/graph_commands.py`:

   a. Add `"input": _cmd_input` to the handlers dict in `dispatch_graph()`.

   b. Implement `_cmd_input(arg, shell)`:
   ```python
   async def _cmd_input(arg: str, shell) -> None:
       """Resolve a pending input gate: input <gate_id> <value>."""
       parts = arg.strip().split(None, 1)
       if len(parts) < 2:
           shell.router.write("graph", "usage: input <id> <value>", mode="GRAPH")
           return

       gate_id, raw_value = parts
       gate = shell.engine.get_pending_gate(gate_id)
       if gate is None:
           shell.router.write("graph", f"no pending gate {gate_id}", mode="GRAPH")
           return

       from pydantic import TypeAdapter
       try:
           adapter = TypeAdapter(gate.field_type)
           value = adapter.validate_python(raw_value)
       except Exception as e:
           type_name = getattr(gate.field_type, '__name__', str(gate.field_type))
           shell.router.write(
               "graph",
               f"invalid value for {gate.field_name} ({type_name}): {e}",
               mode="GRAPH",
           )
           return

       shell.engine.resolve_gate(gate_id, value)
       shell.router.write(
           "graph", f"resolved {gate_id}: {gate.field_name} = {value!r}",
           mode="GRAPH",
           metadata={"type": "lifecycle", "run_id": gate.run_id},
       )
   ```

   c. Add `"gates": _cmd_gates` to the handlers dict -- shows all pending gates with their schema:
   ```python
   async def _cmd_gates(arg: str, shell) -> None:
       """Show all pending input gates."""
       gates = list(shell.engine._pending_gates.values())
       if not gates:
           shell.router.write("graph", "(no pending gates)", mode="GRAPH")
           return
       lines = []
       for g in gates:
           lines.append(f"  {g.gate_id}  {g.node_type}.{g.schema_display}")
       shell.router.write("graph", "\n".join(lines), mode="GRAPH")
   ```

2. In `bae/repl/engine.py`, update `GraphRegistry.submit()` to accept and store a `notify` callback:
   - Add `notify` parameter: `def submit(self, graph, tm, *, lm=None, notify=None, **kwargs)`.
   - Pass `notify` through to `_execute`.
   - In the gate hook inside `_execute`, when gates are created, call `notify` with a formatted string showing the pending gate schema. Example: `"[g1.0] ConfirmDeploy.approved: bool (\"Deploy to prod?\")"`.
   - If `notify` is None, skip notification.

3. In `bae/repl/graph_commands.py`, in `_cmd_run`, pass a notify callback when submitting:
   ```python
   def _make_notify(shell):
       def notify(msg):
           if not getattr(shell, 'shush_gates', False):
               shell.router.write(
                   "graph", msg, mode="GRAPH",
                   metadata={"type": "gate"},
               )
       return notify
   ```
   The `getattr` with default is defensive: `shush_gates` is added by Plan 28-03 on CortexShell. If Plan 02 executes before Plan 03, the attribute won't exist yet, so `getattr` defaults to False (notifications enabled). When Plan 03 adds `shush_gates = False` to CortexShell and the user toggles it to True, the notify callback will suppress inline gate notifications.

   Pass `notify=_make_notify(shell)` to `shell.engine.submit(...)` and use it in `submit_coro` as well (add notify param there too).

4. **Tests in `tests/repl/test_graph_commands.py`:**
   - `test_input_resolves_gate`: Create a pending gate on the engine, run `input g1.0 true`, verify gate resolved and router received confirmation message.
   - `test_input_no_args`: Run `input` with no args, verify usage message.
   - `test_input_invalid_gate_id`: Run `input bad.id true`, verify "no pending gate" message.
   - `test_input_invalid_type`: Create a gate with field_type=int, run `input g1.0 abc`, verify error message about invalid value.
   - `test_gates_command_empty`: Run `gates` with no pending gates, verify "(no pending gates)" message.
   - `test_gates_command_shows_pending`: Create pending gates, run `gates`, verify output includes gate IDs and schema.
  </action>
  <verify>
`uv run pytest tests/repl/test_graph_commands.py -x -q` passes. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` passes.
  </verify>
  <done>`input <id> <value>` command resolves pending gates with Pydantic type coercion. `gates` command shows all pending gates with schema. Gate creation emits inline notification showing what input is needed. All tests pass.</done>
</task>

</tasks>

<verification>
1. A graph with `Annotated[bool, Gate(description="Approve?")]` pauses at that node
2. `list` shows the graph in WAITING state while paused
3. `gates` shows pending gate with field name, type, and description
4. `input g1.0 yes` resolves the gate and graph resumes
5. Invalid type input shows error with expected type
6. Cancelling a waiting graph cleans up pending gates
7. Full test suite passes: `uv run pytest tests/ -x -q --ignore=tests/test_integration.py`
</verification>

<success_criteria>
End-to-end gate suspension and resolution works: graph pauses at Gate fields, user resolves via `input` command, graph resumes. Gate notifications appear inline. All error paths handled (bad gate ID, bad type, cancel during wait).
</success_criteria>

<output>
After completion, create `.planning/phases/28-input-gates/28-02-SUMMARY.md`
</output>
