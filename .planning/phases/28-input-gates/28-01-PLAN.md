---
phase: 28-input-gates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/markers.py
  - bae/resolver.py
  - bae/lm.py
  - bae/__init__.py
  - bae/repl/engine.py
  - tests/test_resolver.py
  - tests/repl/test_engine.py
autonomous: true

must_haves:
  truths:
    - "Gate marker classifies as 'gate' in classify_fields(), separate from dep/recall/plain"
    - "LLM never tries to fill gate-annotated fields (excluded from plain model)"
    - "InputGate wraps an asyncio.Future with schema metadata (field name, type, description)"
    - "GraphState.WAITING exists for graphs suspended at input gates"
    - "GraphRegistry can create, query, resolve, and clean up gates by run_id"
  artifacts:
    - path: "bae/markers.py"
      provides: "Gate dataclass marker"
      contains: "class Gate"
    - path: "bae/resolver.py"
      provides: "Gate classification in classify_fields"
      contains: "isinstance(m, Gate)"
    - path: "bae/lm.py"
      provides: "Gate exclusion from plain model"
    - path: "bae/repl/engine.py"
      provides: "InputGate, WAITING state, gate registry methods"
      contains: "class InputGate"
    - path: "bae/__init__.py"
      provides: "Gate export"
      contains: "Gate"
  key_links:
    - from: "bae/resolver.py"
      to: "bae/markers.py"
      via: "import Gate, classify as 'gate'"
      pattern: "isinstance.*Gate"
    - from: "bae/lm.py"
      to: "bae/resolver.py"
      via: "classify_fields excludes gate from plain"
      pattern: "plain"
    - from: "bae/repl/engine.py"
      to: "bae/markers.py"
      via: "Gate import for InputGate schema extraction"
---

<objective>
Add the Gate marker to bae's annotation system and build the InputGate runtime infrastructure in the engine.

Purpose: Gate is the fourth field marker (alongside Dep, Recall, Effect). It declares that a node field requires human input during graph execution. The resolver must classify it correctly so the LLM never fills it. The engine needs InputGate (Future wrapper with schema) and a gate registry to manage pending gates.

Output: Gate marker, resolver/LM integration, InputGate dataclass, WAITING state, gate registry on GraphRegistry.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-input-gates/28-RESEARCH.md

@bae/markers.py
@bae/resolver.py
@bae/lm.py
@bae/__init__.py
@bae/repl/engine.py
@tests/test_resolver.py
@tests/repl/test_engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gate marker with resolver and LM integration</name>
  <files>bae/markers.py, bae/resolver.py, bae/lm.py, bae/__init__.py, tests/test_resolver.py</files>
  <action>
1. In `bae/markers.py`, add a `Gate` dataclass (frozen=True) with a single `description: str = ""` field. Follow the exact style of `Dep`, `Recall`, `Effect`. Docstring should explain it marks fields requiring human input during graph execution and that execution suspends until the user provides a value.

2. In `bae/resolver.py`:
   - Import `Gate` from `bae.markers` (add to existing import).
   - In `classify_fields()`, add a check for `isinstance(m, Gate)` in the metadata loop, returning `"gate"`. Place it after the Recall check, before the `if not classified` fallback. Same pattern as Dep/Recall checks.
   - In `recall_from_trace()`, extend the infrastructure-skip check: change `any(isinstance(m, (Dep, Recall)) for m in metadata)` to include `Gate`: `any(isinstance(m, (Dep, Gate, Recall)) for m in metadata)`.

3. In `bae/lm.py`, in `_build_plain_model()`: the existing check `if fields.get(name, "plain") == "plain"` already excludes non-plain fields. Since classify_fields now returns "gate" for gate fields, they're automatically excluded. Verify this is the case -- no code change needed if the condition checks for equality with "plain".

4. In `bae/__init__.py`, add `Gate` to the imports from `bae.markers` and to `__all__`.

5. In `tests/test_resolver.py`, add tests:
   - `test_classify_gate_field`: A Node with `Annotated[bool, Gate(description="Approve?")]` classifies as "gate".
   - `test_gate_excluded_from_plain_model`: `_build_plain_model` on a Node with a gate field does NOT include the gate field in the generated model.
   - `test_recall_skips_gate_fields`: `recall_from_trace` skips gate-annotated fields when searching.
   - `test_gate_and_plain_coexist`: A Node with both gate and plain fields -- classify_fields returns "gate" for the gate field and "plain" for the plain field.
  </action>
  <verify>
`uv run pytest tests/test_resolver.py -x -q` passes. Verify that `from bae import Gate` works. Verify `classify_fields` returns "gate" for gate-annotated fields.
  </verify>
  <done>Gate marker exists, resolver classifies gate fields correctly, LLM plain model excludes gate fields, recall_from_trace skips gate fields, all tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: InputGate dataclass with WAITING state and gate registry</name>
  <files>bae/repl/engine.py, tests/repl/test_engine.py</files>
  <action>
1. In `bae/repl/engine.py`:

   a. Add `WAITING = "waiting"` to `GraphState` enum, between RUNNING and DONE.

   b. Add `InputGate` dataclass:
   ```python
   @dataclass
   class InputGate:
       gate_id: str           # e.g. "g1.0" (run_id.field_index)
       run_id: str            # which GraphRun this belongs to
       field_name: str        # Pydantic field name
       field_type: type       # target type for value coercion
       description: str       # from Gate marker or Field(description=...)
       node_type: str         # which node class requested this gate
       future: asyncio.Future = field(default_factory=lambda: asyncio.get_event_loop().create_future())

       @property
       def schema_display(self) -> str:
           type_name = getattr(self.field_type, '__name__', str(self.field_type))
           if self.description:
               return f"{self.field_name}: {type_name} (\"{self.description}\")"
           return f"{self.field_name}: {type_name}"
   ```

   c. Add gate registry state to `GraphRegistry.__init__`:
   - `self._pending_gates: dict[str, InputGate] = {}` -- keyed by gate_id
   - `self._gate_counter: int = 0` -- monotonic counter for unique gate IDs within a run

   d. Add gate lifecycle methods to `GraphRegistry`:
   - `create_gate(run_id, field_name, field_type, description, node_type) -> InputGate`: Creates InputGate with gate_id `f"{run_id}.{self._gate_counter}"`, increments counter, registers in `_pending_gates`, returns it.
   - `resolve_gate(gate_id, value) -> bool`: Looks up gate in `_pending_gates`, sets `future.set_result(value)`, removes from `_pending_gates`, returns True. Returns False if not found or already resolved.
   - `get_pending_gate(gate_id) -> InputGate | None`: Lookup by gate_id.
   - `pending_gate_count() -> int`: Returns `len(self._pending_gates)`.
   - `pending_gates_for_run(run_id) -> list[InputGate]`: Filter pending gates by run_id.
   - `cancel_gates(run_id) -> None`: Cancel all pending Futures for a run_id and remove from registry. Use `future.cancel()` for each.

   e. In `GraphRegistry._execute`, in the `except asyncio.CancelledError` block, call `self.cancel_gates(run.run_id)` before re-raising. Same for `_wrap_coro`.

   f. Update `GraphRegistry.active()` to include WAITING state: `return [r for r in self._runs.values() if r.state in (GraphState.RUNNING, GraphState.WAITING)]`.

2. In `tests/repl/test_engine.py`, add tests:
   - `test_waiting_state_exists`: Verify GraphState.WAITING.value == "waiting".
   - `test_create_gate`: Create a gate, verify gate_id format, field_name, field_type, description, node_type.
   - `test_resolve_gate`: Create gate, resolve with value, verify future.result() returns value, gate removed from pending.
   - `test_resolve_gate_not_found`: Resolve non-existent gate returns False.
   - `test_pending_gate_count`: Create 2 gates, count is 2, resolve 1, count is 1.
   - `test_pending_gates_for_run`: Create gates for different runs, filter by run_id.
   - `test_cancel_gates`: Create gates for a run, cancel_gates, verify futures are cancelled, gates removed.
   - `test_schema_display`: Verify InputGate.schema_display formatting with and without description.
   - `test_active_includes_waiting`: A run in WAITING state appears in active().
  </action>
  <verify>
`uv run pytest tests/repl/test_engine.py -x -q` passes. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` passes (no regressions).
  </verify>
  <done>InputGate dataclass exists with schema_display property, GraphState.WAITING exists, GraphRegistry has full gate lifecycle methods (create/resolve/query/cancel), cancel on graph cancellation cleans up gates, all tests pass.</done>
</task>

</tasks>

<verification>
1. `from bae import Gate` succeeds
2. `classify_fields` returns "gate" for `Annotated[bool, Gate()]` fields
3. `_build_plain_model` excludes gate fields
4. `GraphState.WAITING` exists
5. `InputGate` has gate_id, future, schema_display
6. `GraphRegistry.create_gate/resolve_gate/cancel_gates` work correctly
7. Full test suite passes: `uv run pytest tests/ -x -q --ignore=tests/test_integration.py`
</verification>

<success_criteria>
Gate marker integrated into bae's annotation system (markers, resolver, LM exclusion). InputGate runtime object and gate registry on GraphRegistry ready for engine interception (plan 02) and shell integration (plan 03).
</success_criteria>

<output>
After completion, create `.planning/phases/28-input-gates/28-01-SUMMARY.md`
</output>
