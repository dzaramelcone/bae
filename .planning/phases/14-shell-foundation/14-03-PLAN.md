---
phase: 14-shell-foundation
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified: [bae/repl/exec.py, tests/repl/test_exec.py]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Expression result (e.g. `1 + 1`) is captured in _ and returned"
    - "Statements with no expression tail (e.g. `for _ in range(20): print(_)`) return None"
    - "Await expressions return their result"
    - "Code that does not touch _ does not produce spurious output"
  artifacts:
    - path: "bae/repl/exec.py"
      provides: "Sentinel-guarded expression capture"
      contains: "_EXPR_CAPTURED"
    - path: "tests/repl/test_exec.py"
      provides: "Regression tests for async_exec expression capture"
      min_lines: 30
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/exec.py"
      via: "async_exec return value printed only when not None"
      pattern: "result is not None"
---

<objective>
Fix spurious output from async_exec when user code sets `_` as a loop variable or otherwise without expression capture.

Purpose: UAT test 3 failed -- `for _ in range(20): print(_)` prints `19` at the end because `async_exec` unconditionally returns `namespace.get('_')` even when no expression-capture AST rewrite occurred.

Output: Fixed `exec.py` with sentinel guard + regression tests in `tests/repl/test_exec.py`
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-shell-foundation/14-01-SUMMARY.md

@bae/repl/exec.py
@bae/repl/shell.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for expression capture behavior</name>
  <files>tests/repl/__init__.py, tests/repl/test_exec.py</files>
  <action>
Create `tests/repl/__init__.py` (empty) and `tests/repl/test_exec.py` with pytest-asyncio tests for `async_exec`:

1. **test_expr_returns_value** -- `async_exec("1 + 1", ns)` returns `2`
2. **test_assignment_returns_none** -- `async_exec("x = 42", ns)` returns `None`
3. **test_for_loop_with_underscore_returns_none** -- `async_exec("for _ in range(20): pass", ns)` returns `None` (THIS IS THE BUG -- currently returns `19`)
4. **test_for_loop_with_print_returns_none** -- `async_exec("for _ in range(5): print(_)", ns)` returns `None` (captures stdout, asserts "0\n1\n2\n3\n4" in output, no trailing `4` repr)
5. **test_await_expr_returns_value** -- `async_exec("await asyncio.sleep(0) or 'done'", ns)` returns `'done'` (ns must include asyncio)
6. **test_multiline_last_expr** -- `async_exec("x = 10\nx + 5", ns)` returns `15`
7. **test_multiline_last_statement** -- `async_exec("x = 10\ny = 20", ns)` returns `None`

Use `@pytest.mark.asyncio` decorator. Each test creates a fresh namespace dict (seed with `asyncio` for the await test).

Run tests: `pytest tests/repl/test_exec.py -v`. Tests 3 and 4 MUST FAIL (red phase).

Commit: `test(14-03): add failing tests for async_exec expression capture`
  </action>
  <verify>pytest tests/repl/test_exec.py -v shows tests 3 and 4 FAILING, tests 1, 2, 5, 6, 7 passing</verify>
  <done>Seven tests exist, two fail on the known bug (for-loop underscore leaking)</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Fix async_exec with sentinel-guarded return</name>
  <files>bae/repl/exec.py</files>
  <action>
In `bae/repl/exec.py`, fix the unconditional `namespace.get('_')` return:

1. Add a module-level sentinel: `_EXPR_CAPTURED = object()`
2. Before the AST rewrite block (line 15), initialize: `namespace['__expr_captured__'] = False`
3. Inside the `if tree.body and isinstance(tree.body[-1], ast.Expr):` block, after rewriting the last statement to assign to `_`, ALSO inject an assignment: `__expr_captured__ = True`. Build this as `ast.Assign(targets=[ast.Name(id='__expr_captured__', ctx=ast.Store())], value=ast.Constant(value=True))` and append it to `tree.body`.
4. After execution (line 30), change the return to:
   ```python
   if namespace.get('__expr_captured__'):
       return namespace.get('_')
   return None
   ```
5. Clean up: `namespace.pop('__expr_captured__', None)` before returning (keep namespace clean).

Do NOT change shell.py -- the existing `if result is not None: print(repr(result))` logic is correct once exec.py stops leaking values.

Run: `pytest tests/repl/test_exec.py -v`. ALL tests must pass.

Commit: `fix(14-03): guard async_exec return with expression-capture sentinel`
  </action>
  <verify>pytest tests/repl/test_exec.py -v -- all 7 tests pass (green)</verify>
  <done>async_exec returns expression results only when the last statement was an expression; loop variables and assignments return None</done>
</task>

</tasks>

<verification>
1. `pytest tests/repl/test_exec.py -v` -- all 7 tests pass
2. Manual smoke test: launch `bae`, switch to PY mode, run `for _ in range(20): print(_)` -- should print 0-19 with NO trailing `19` repr line
3. Manual smoke test: in PY mode, run `1 + 1` -- should print `2`
4. Manual smoke test: in PY mode, run `x = 42` -- should print nothing
</verification>

<success_criteria>
- All 7 regression tests pass
- `for _ in range(N)` loops do not produce spurious output
- Expression capture (`1 + 1` -> `2`) still works
- No behavioral regression in shell.py (it was correct, only exec.py needed fixing)
</success_criteria>

<output>
After completion, create `.planning/phases/14-shell-foundation/14-03-SUMMARY.md`
</output>
