---
phase: 14-shell-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/__init__.py
  - bae/repl/shell.py
  - bae/repl/modes.py
  - bae/repl/exec.py
  - bae/cli.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Running `bae` with no arguments launches cortex REPL and shows a colored prompt"
    - "User can switch modes with Shift+Tab and sees mode change in prompt color and status bar"
    - "In Py mode, user can type `1 + 1` and see `2`; can type `await asyncio.sleep(0)` and it executes"
    - "Enter submits input, Escape+Enter inserts newline in all modes"
    - "NL and Graph modes show stub messages when input is entered"
  artifacts:
    - path: "bae/repl/__init__.py"
      provides: "launch() entry point for cortex"
      contains: "def launch"
    - path: "bae/repl/shell.py"
      provides: "CortexShell class with async REPL loop"
      contains: "class CortexShell"
    - path: "bae/repl/modes.py"
      provides: "Mode enum and per-mode config (color, lexer)"
      contains: "class Mode"
    - path: "bae/repl/exec.py"
      provides: "async_exec with PyCF_ALLOW_TOP_LEVEL_AWAIT"
      contains: "PyCF_ALLOW_TOP_LEVEL_AWAIT"
  key_links:
    - from: "bae/cli.py"
      to: "bae/repl/__init__.py"
      via: "typer callback invokes launch()"
      pattern: "from bae\\.repl import launch"
    - from: "bae/repl/shell.py"
      to: "bae/repl/exec.py"
      via: "Py mode dispatches to async_exec()"
      pattern: "async_exec"
    - from: "bae/repl/shell.py"
      to: "bae/repl/modes.py"
      via: "Shell uses Mode enum for prompt color and toolbar"
      pattern: "Mode"
---

<objective>
Create the cortex REPL skeleton with mode switching, Python execution, and `bae` entry point.

Purpose: Deliver the core REPL experience -- launch cortex, see colored prompt with status bar, switch between four modes, execute Python code with top-level await. NL and Graph modes are stubs. This is the foundation all Phase 14 plans build on.

Output: `bae/repl/` package with shell, modes, exec modules; modified CLI entry point.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-shell-foundation/14-RESEARCH.md
@.planning/phases/14-shell-foundation/14-CONTEXT.md
@bae/cli.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create REPL package with modes, shell, and Python execution</name>
  <files>bae/repl/__init__.py, bae/repl/shell.py, bae/repl/modes.py, bae/repl/exec.py</files>
  <action>
Create `bae/repl/` package with four modules:

**bae/repl/modes.py** -- Mode enum and per-mode configuration:
- `Mode` enum with values: `NL`, `PY`, `GRAPH`, `BASH`
- `MODE_COLORS` dict mapping Mode -> hex color string:
  - NL: `#87d7ff` (blue), PY: `#87ff87` (green), GRAPH: `#ffaf87` (orange), BASH: `#d7afff` (purple)
- `MODE_NAMES` dict mapping Mode -> display name (e.g., `"NL"`, `"PY"`, `"GRAPH"`, `"BASH"`)
- Default mode: `Mode.NL`

**bae/repl/exec.py** -- Async Python execution engine:
- `async def async_exec(code: str, namespace: dict) -> object | None` function
- Use `ast.parse(code, mode="exec")` to parse
- If last statement is `ast.Expr`, rewrite to `ast.Assign` targeting `_` to capture expression results
- Compile with `flags=ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`
- Execute via `types.FunctionType(compiled, namespace)` -- call the function, await if result is a coroutine
- Return `namespace.get("_")`
- Source file is `<cortex>` for tracebacks

**bae/repl/shell.py** -- CortexShell class:
- `class CortexShell` with `__init__` and `async run(self)` method
- Instance state: `self.mode` (Mode.NL default), `self.namespace` (dict seeded with `asyncio`, `os`, `__builtins__`), `self.tasks` (set of asyncio.Task, empty for now)
- PromptSession configured with:
  - `message`: callable returning `[("fg:{mode_color}", "> ")]` based on current mode
  - `lexer`: `DynamicLexer` -- returns `PygmentsLexer(PythonLexer)` in PY mode, `None` otherwise
  - `multiline=True` for newline support
  - `bottom_toolbar`: callable returning formatted text with mode name (bold) + cwd (tilde-shortened)
  - `style`: Style.from_dict with toolbar styling (dark bg, white mode text, muted cwd)
  - `key_bindings`: KeyBindings instance with:
    - `s-tab`: cycle through modes (NL -> PY -> GRAPH -> BASH -> NL), invalidate app
    - `enter`: `validate_and_handle()` (submit)
    - `escape` then `enter`: `insert_text("\n")` (newline)
- Main loop in `run()`:
  - Wrap with `patch_stdout()` context
  - `while True` calling `await self.session.prompt_async()`
  - Skip empty input
  - Mode dispatch:
    - PY: call `async_exec(text, self.namespace)`, print `repr(result)` if result is not None; catch `KeyboardInterrupt` (pass), catch `Exception` (traceback.print_exc())
    - NL: print stub message `"(NL mode stub) {text}"` + `"NL mode coming in Phase 18."`
    - GRAPH: print stub message `"(Graph mode stub) Not yet implemented."`
    - BASH: print stub message `"(Bash mode coming in Plan 02.)"` (placeholder -- Plan 02 wires real bash)
  - Catch `KeyboardInterrupt` from `prompt_async()`: exit (return)
  - Catch `EOFError` from `prompt_async()`: call shutdown, exit

**bae/repl/__init__.py** -- Entry point:
- Module docstring: `"""Cortex: async REPL with mode switching."""`
- `def launch() -> None` function that calls `asyncio.run(CortexShell().run())`
- Import `CortexShell` from shell, `Mode` from modes

Match existing bae code style: absolute imports, snake_case, type hints, compact functions, 100 char line length.
  </action>
  <verify>
Run: `python -c "from bae.repl import launch; print('import ok')"` -- should print "import ok"
Run: `python -c "from bae.repl.exec import async_exec; import asyncio; ns = {}; asyncio.run(async_exec('1 + 1', ns)); print(ns.get('_'))"` -- should print `2`
Run: `python -c "from bae.repl.exec import async_exec; import asyncio; ns = {'asyncio': asyncio}; asyncio.run(async_exec('await asyncio.sleep(0)', ns)); print('await ok')"` -- should print "await ok"
  </verify>
  <done>bae/repl/ package exists with shell.py (CortexShell), modes.py (Mode enum + colors), exec.py (async_exec with PyCF_ALLOW_TOP_LEVEL_AWAIT), __init__.py (launch entry point). Python execution works for sync and await expressions.</done>
</task>

<task type="auto">
  <name>Task 2: Wire cortex launch into bae CLI entry point</name>
  <files>bae/cli.py, pyproject.toml</files>
  <action>
**bae/cli.py:**
- Change `app = typer.Typer(... no_args_is_help=True)` to `app = typer.Typer(... invoke_without_command=True)`
- Add a callback to the app that launches cortex when no subcommand is given:

```python
@app.callback(invoke_without_command=True)
def cortex(ctx: typer.Context):
    """Launch cortex REPL."""
    if ctx.invoked_subcommand is None:
        from bae.repl import launch
        launch()
```

- Remove or adjust the existing help string to reflect the new behavior
- Keep all existing commands (`graph show`, `graph export`, `graph mermaid`, `run`) working unchanged

**pyproject.toml:**
- Add `prompt-toolkit>=3.0.50` and `pygments>=2.19` to `dependencies`
- Keep all existing dependencies

Test that subcommands still work: `bae graph mermaid --help` should show help, not launch cortex.
  </action>
  <verify>
Run: `bae graph mermaid --help` -- should show mermaid command help (not launch cortex)
Run: `bae run --help` -- should show run command help
Run: `python -c "from bae.cli import app"` -- should import without error
  </verify>
  <done>`bae` with no arguments launches cortex REPL. `bae graph show`, `bae run`, etc. continue working as before. prompt-toolkit and pygments added as dependencies.</done>
</task>

</tasks>

<verification>
1. `python -c "from bae.repl.modes import Mode; print(list(Mode))"` -- prints all four modes
2. `python -c "from bae.repl.exec import async_exec; import asyncio; ns = {}; asyncio.run(async_exec('x = 42', ns)); print(ns['x'])"` -- prints 42
3. `python -c "from bae.repl.shell import CortexShell; print('shell ok')"` -- imports without error
4. `bae graph mermaid --help` -- existing subcommands still work
5. Interactive: run `bae`, verify colored prompt appears, Shift+Tab changes mode, type `1+1` in Py mode and see `2`, Ctrl-C exits
</verification>

<success_criteria>
- `bae` with no args launches cortex with colored `> ` prompt and bottom status bar showing mode + cwd
- Shift+Tab cycles NL -> PY -> GRAPH -> BASH -> NL with prompt color change and toolbar update
- In PY mode: `1 + 1` returns `2`, `await asyncio.sleep(0)` executes, `x = 42` sets variable in namespace
- Enter submits, Escape+Enter inserts newline (multiline editing works)
- NL and Graph modes show stub messages
- Ctrl-C at prompt exits, Ctrl-D at prompt exits
- Existing CLI commands (`bae graph show`, `bae run`) still work
</success_criteria>

<output>
After completion, create `.planning/phases/14-shell-foundation/14-01-SUMMARY.md`
</output>
