---
phase: 14-shell-foundation
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - bae/repl/bash.py
  - bae/repl/complete.py
  - bae/repl/shell.py
autonomous: true

must_haves:
  truths:
    - "In Bash mode, `ls` shows directory contents and `echo hello` prints hello"
    - "In Bash mode, `cd /tmp` changes the working directory (visible in status bar and affects all modes)"
    - "In Bash mode, stderr appears in red, stdout appears plain"
    - "In Py mode, tab completion suggests namespace objects (e.g., typing `as` then Tab shows `asyncio`)"
    - "Ctrl-C with nothing running exits immediately; Ctrl-D with nothing running exits silently"
    - "Ctrl-D with tasks running prints `cancelled N tasks` summary before exiting"
    - "Ctrl-C during Py mode code execution raises KeyboardInterrupt in code, returns to prompt (does not exit)"
  artifacts:
    - path: "bae/repl/bash.py"
      provides: "Bash subprocess dispatch with cd special-casing"
      contains: "async def dispatch_bash"
    - path: "bae/repl/complete.py"
      provides: "NamespaceCompleter wrapping rlcompleter"
      contains: "class NamespaceCompleter"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/bash.py"
      via: "Bash mode dispatches to dispatch_bash()"
      pattern: "dispatch_bash"
    - from: "bae/repl/shell.py"
      to: "bae/repl/complete.py"
      via: "DynamicCompleter returns NamespaceCompleter in PY mode"
      pattern: "NamespaceCompleter"
---

<objective>
Add bash mode execution, tab completion, and lifecycle management to the cortex REPL.

Purpose: Complete the Phase 14 feature set -- bash commands work with cd special-casing, Py mode has tab completion on namespace objects, and shutdown/interrupt behavior matches the spec. After this plan, all Phase 14 success criteria are met.

Output: `bae/repl/bash.py`, `bae/repl/complete.py`, updated `bae/repl/shell.py`.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-shell-foundation/14-RESEARCH.md
@.planning/phases/14-shell-foundation/14-CONTEXT.md
@.planning/phases/14-shell-foundation/14-01-SUMMARY.md
@bae/repl/shell.py
@bae/repl/modes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bash dispatcher and namespace completer</name>
  <files>bae/repl/bash.py, bae/repl/complete.py</files>
  <action>
**bae/repl/bash.py** -- Bash subprocess dispatch:
- Module docstring explaining bash mode executes commands via subprocess, cd special-cased
- `async def dispatch_bash(cmd: str) -> None` function:
  - Strip input; return on empty
  - Check if command is `cd` (bare `cd` or starts with `cd `):
    - Parse target: strip the `cd ` prefix, default to `~` if empty, expand `~` via `os.path.expanduser`
    - Call `os.chdir(target)`
    - On `FileNotFoundError` or `PermissionError`: print error in red using `print_formatted_text(FormattedText([("fg:red", msg)]))`
    - Return (do not spawn subprocess)
  - For all non-cd commands: `asyncio.create_subprocess_shell()` with:
    - `stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE`
    - `cwd=os.getcwd()` (inherit REPL's cwd)
  - `await proc.communicate()` to get stdout/stderr
  - Print stdout plain (decoded, `end=""`)
  - Print stderr in red via `print_formatted_text(FormattedText([("fg:red", text)]))`

**bae/repl/complete.py** -- Namespace tab completer:
- Module docstring explaining the completer wraps rlcompleter for namespace-aware completion
- `class NamespaceCompleter(Completer)` from prompt_toolkit:
  - `__init__(self, namespace: dict)`: store namespace ref, create `rlcompleter.Completer(namespace)`
  - `get_completions(self, document, complete_event)` method:
    - Get word before cursor via `document.get_word_before_cursor(WORD=True)`
    - If word contains `.`, include the dot-prefixed part (rlcompleter handles dotted names)
    - Iterate `self._completer.complete(text, i)` for i=0,1,2... until None
    - Yield `Completion(match, start_position=-len(text))` for each match
  - The rlcompleter.Completer instance holds a reference to the namespace dict, so it sees live updates
  - Per the specific ideas: the `Completer` ABC from prompt_toolkit IS the provider interface for future LSP

Match existing bae style: absolute imports, type hints, compact functions.
  </action>
  <verify>
Run: `python -c "from bae.repl.bash import dispatch_bash; print('bash ok')"` -- should import
Run: `python -c "from bae.repl.complete import NamespaceCompleter; print('complete ok')"` -- should import
Run: `python -c "
import asyncio, os
from bae.repl.complete import NamespaceCompleter
from prompt_toolkit.document import Document
c = NamespaceCompleter({'asyncio': asyncio, 'os': os})
doc = Document('asyn', cursor_position=4)
results = list(c.get_completions(doc, None))
print([r.text for r in results])
"` -- should include `asyncio` in output
  </verify>
  <done>bash.py dispatches commands via async subprocess with cd special-casing and red stderr. complete.py provides NamespaceCompleter wrapping rlcompleter with the Completer provider interface.</done>
</task>

<task type="auto">
  <name>Task 2: Wire bash, completion, and lifecycle into shell</name>
  <files>bae/repl/shell.py</files>
  <action>
Update `CortexShell` in `bae/repl/shell.py` to wire in the new modules:

**Bash mode dispatch:**
- Import `dispatch_bash` from `bae.repl.bash`
- Replace the bash stub in the mode dispatch with: `await dispatch_bash(text)`

**Tab completion:**
- Import `NamespaceCompleter` from `bae.repl.complete`
- Create `self.completer = NamespaceCompleter(self.namespace)` in `__init__`
- Add `DynamicCompleter` to PromptSession: returns `self.completer` when mode is PY, `None` otherwise

**Lifecycle -- shutdown (Ctrl-D):**
- On `EOFError` from `prompt_async()`:
  - If `self.tasks` is empty: return silently (clean exit)
  - If `self.tasks` has running tasks:
    - Cancel each task with `task.cancel()`
    - `await asyncio.gather(*self.tasks, return_exceptions=True)`
    - Count cancelled (results that are `CancelledError`)
    - Print `f"cancelled {n} tasks"` if n > 0
    - Return

**Lifecycle -- interrupt (Ctrl-C):**
- On `KeyboardInterrupt` from `prompt_async()`:
  - If `self.tasks` is empty: return immediately (exit)
  - (Future Phase 19 will add task kill menu here; for now, exit regardless)
- During Py mode execution: `KeyboardInterrupt` is caught in the existing try/except, prints nothing, returns to prompt. This is already in Plan 01's handler -- verify it works correctly. The key behavior: Ctrl-C during `await long_operation()` should cancel the operation and return to the prompt, NOT exit the REPL.

**Syntax highlighting:**
- Verify `DynamicLexer` from Plan 01 returns `PygmentsLexer(PythonLexer)` in PY mode. If not already done, ensure it works.

Do NOT change mode cycling, prompt colors, toolbar, or entry point -- those are from Plan 01.
  </action>
  <verify>
Interactive test sequence:
1. Run `bae`
2. Press Shift+Tab until in BASH mode (purple prompt, status bar shows BASH)
3. Type `echo hello` -- should print "hello"
4. Type `ls` -- should show directory listing
5. Type `cd /tmp` -- status bar should update to show /tmp
6. Type `pwd` -- should print /tmp
7. Type `cd -` or `cd ~` -- navigate back
8. Press Shift+Tab to PY mode
9. Type `as` then Tab -- should show `asyncio` in completions
10. Type `1 + 1` -- should print `2`
11. Press Ctrl-C -- should exit
12. Run `bae` again, press Ctrl-D -- should exit silently

Run: `ruff check bae/repl/` -- no lint errors
  </verify>
  <done>Bash mode executes subprocess commands with cd special-casing. Tab completion works in Py mode on namespace objects. Ctrl-C exits when idle. Ctrl-D exits silently when no tasks, prints cancellation summary when tasks running. All Phase 14 features are operational.</done>
</task>

</tasks>

<verification>
1. `bae` launches cortex, shows colored prompt and status bar
2. Shift+Tab cycles through all 4 modes with color + toolbar changes
3. PY mode: `1 + 1` returns 2, `await asyncio.sleep(0)` works, syntax highlighting visible, tab completion works
4. BASH mode: `echo hello` prints hello, `ls` lists files, `cd /tmp` changes cwd (status bar updates), stderr from `ls /nonexistent` appears in red
5. NL mode: shows stub message
6. GRAPH mode: shows stub message
7. Ctrl-C exits when idle
8. Ctrl-D exits silently when no tasks running
9. Escape+Enter inserts newline in any mode
10. `ruff check bae/repl/` passes
</verification>

<success_criteria>
- All Phase 14 success criteria from ROADMAP.md are met:
  1. `bae` launches cortex; `await asyncio.sleep(1)` executes in Py mode
  2. Shift+Tab cycles modes; prompt color and status bar indicate active mode
  3. Py mode has syntax highlighting, multiline editing, tab completion
  4. Bash mode executes shell commands with output
  5. Ctrl-C exits when idle; Ctrl-D exits with graceful shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/14-shell-foundation/14-02-SUMMARY.md`
</output>
