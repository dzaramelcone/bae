---
phase: 33-task-resourcespace
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/spaces/tasks/models.py
  - bae/repl/spaces/tasks/view.py
  - bae/repl/spaces/tasks/service.py
  - bae/repl/tools.py
  - tests/test_task_store.py
  - tests/test_task_resource.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Task IDs are short base36 strings (e.g. '1', 'a', '1z') not 36-char UUIDs"
    - "read() listing shows task IDs so users can reference tasks in done(), update(), read(id)"
    - "update('id', status='in_progress') works with positional task_id and keyword fields"
  artifacts:
    - path: "bae/repl/spaces/tasks/models.py"
      provides: "INTEGER AUTOINCREMENT PK with base36 encode/decode"
      contains: "INTEGER PRIMARY KEY AUTOINCREMENT"
    - path: "bae/repl/spaces/tasks/view.py"
      provides: "Task ID shown in format_task_row"
      contains: "task.*id"
    - path: "bae/repl/tools.py"
      provides: "VAR_KEYWORD params skipped in _build_validator"
      contains: "VAR_KEYWORD"
  key_links:
    - from: "bae/repl/spaces/tasks/models.py"
      to: "bae/repl/spaces/tasks/service.py"
      via: "service calls store.create/get/update with integer IDs, displays base36"
      pattern: "to_base36|from_base36"
    - from: "bae/repl/spaces/tasks/view.py"
      to: "format_task_row"
      via: "ID column prepended to row output"
      pattern: "task.*id"
---

<objective>
Close 3 UAT gaps from phase 33: (1) replace UUID task IDs with short base36 INTEGER-backed IDs, (2) show IDs in task listing, (3) fix _build_validator to handle **kwargs parameters.

Purpose: Task IDs are currently 36-char UUIDs that waste tokens and are unfriendly. The listing omits IDs entirely so users cannot reference tasks. The pydantic validator chokes on **kwargs signatures.
Output: Fixed models.py with INTEGER PK + base36, view.py showing IDs, tools.py handling VAR_KEYWORD.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-task-resourcespace/33-01-SUMMARY.md
@.planning/phases/33-task-resourcespace/33-02-SUMMARY.md
@.planning/phases/33-task-resourcespace/33-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace UUID IDs with base36-encoded INTEGER AUTOINCREMENT</name>
  <files>
    bae/repl/spaces/tasks/models.py
    bae/repl/spaces/tasks/service.py
    bae/repl/spaces/tasks/view.py
    tests/test_task_store.py
    tests/test_task_resource.py
  </files>
  <action>
**models.py — Schema and ID generation:**

1. Add `_B36 = "0123456789abcdefghijklmnopqrstuvwxyz"` alphabet constant and two utility functions at module level:
   - `def to_base36(n: int) -> str` — encode a positive integer to base36 string. Handle n==0 as "0".
   - `def from_base36(s: str) -> int` — decode a base36 string to integer. Raise ValueError on invalid chars.

2. Change SCHEMA: Replace `id TEXT PRIMARY KEY` with `id INTEGER PRIMARY KEY AUTOINCREMENT` on the tasks table. All FK references (`task_tags.task_id`, `task_dependencies.task_id`, `task_dependencies.blocked_by`, `task_audit.task_id`, and `tasks.parent_id`) change from TEXT to INTEGER. The FTS5 `content_rowid=rowid` can stay as-is since INTEGER PRIMARY KEY IS the rowid in SQLite (they alias).

3. In `create()`: Remove `task_id = str(uuid.uuid7())`. Remove `import uuid`. Instead, omit `id` from the INSERT (let AUTOINCREMENT generate it). After INSERT+commit, get the id via `self._conn.execute("SELECT last_insert_rowid()").fetchone()[0]`. Return `self.get(to_base36(row_id))`.

4. In `get()`: Accept string ID (base36). Decode with `from_base36(task_id)` to get the integer. Query by integer. Raise ValueError if decode fails or not found. In the returned dict, replace `d["id"]` with `to_base36(d["id"])` so external callers always see base36 strings.

5. In `_task_to_dict()`: Convert `d["id"]` to base36 string: `d["id"] = to_base36(d["id"])`. Also convert `d["parent_id"]` to base36 if not None: `if d.get("parent_id"): d["parent_id"] = to_base36(d["parent_id"])`.

6. In `update()`, `mark_done()`, `cancel()`: These call `self.get(task_id)` which accepts base36. For SQL queries that use the ID directly, decode with `from_base36(task_id)` before passing to SQL. Same for `add_tag()`, `remove_tag()`, `add_dependency()`, `remove_dependency()`.

7. In `_audit()`: Accept integer task_id for internal use (since audit is called from methods that already decoded).

8. In `search()`: The JOIN `t.rowid = fts.rowid` works because INTEGER PRIMARY KEY IS rowid. `_task_to_dict` handles the base36 conversion.

9. In `_has_path()`: Cycle detection uses integer IDs internally. Convert the initial from_id and to_id with `from_base36()`.

**service.py — Update add() response:**

The `add()` method's response `f"Created task {task['id']}: {title}"` already uses the dict's `id` field, which will now be base36 from `_task_to_dict`. No change needed. Same for `done()` and `update()` — they use `task['id']` from dicts.

However, `read()` calls `self._store.get(target)` where `target` is the user-supplied ID string. Since `get()` now does `from_base36()`, this works if the user passes base36. Add a try/except around `from_base36` in `get()` that raises a clear ValueError on invalid base36 input.

**view.py — Show ID in listing:**

In `format_task_row()`: Prepend the task ID to the row output. Change the parts list to: `parts = [task["id"], status, priority, title]`. This makes the format: `id | status | priority | title | tags`.

**Tests — Update for base36 IDs:**

In both test files, task IDs are now short base36 strings (e.g., "1", "2", "3"). Update assertions:
- `assert task["id"]` still works (truthy string).
- Anywhere comparing IDs or checking format, expect short alphanumeric strings.
- The `test_get_raises_for_missing` test should use a clearly invalid base36 string like "zzzzzz" (valid base36 but nonexistent) rather than "nonexistent-id" (which would fail base36 decode).
- In test_task_resource.py, `test_read_bad_target` should also use a valid-but-nonexistent base36 ID.

Run `uv run pytest tests/test_task_store.py tests/test_task_resource.py -x -q` after changes.
  </action>
  <verify>
`uv run pytest tests/test_task_store.py tests/test_task_resource.py -x -q` — all pass. Spot check: create a task in a temp store and confirm its ID is a short base36 string (e.g., "1"), not a UUID.
  </verify>
  <done>
Task IDs are short base36 strings backed by INTEGER AUTOINCREMENT. All CRUD, search, audit, dependencies work with base36 IDs. Task listing rows show the ID as the first column. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix _build_validator to handle **kwargs parameters</name>
  <files>
    bae/repl/tools.py
    tests/test_task_resource.py
  </files>
  <action>
**tools.py — Skip VAR_KEYWORD in _build_validator:**

In `_build_validator()`, inside the parameter loop (`for pname, param in sig.parameters.items()`), add a check after the `self` skip:

```python
if param.kind == inspect.Parameter.VAR_KEYWORD:
    continue
```

Also skip `VAR_POSITIONAL` (`*args`) for safety:

```python
if param.kind in (inspect.Parameter.VAR_KEYWORD, inspect.Parameter.VAR_POSITIONAL):
    continue
```

When a VAR_KEYWORD parameter was found, the created pydantic model needs `model_config = ConfigDict(extra="allow")` so that extra keyword arguments pass through validation. After the loop, check if any param had `kind == VAR_KEYWORD` and if so, pass `__config__=type("Config", (), {"extra": "allow"})` to `create_model`. Actually, the cleaner way: use `model_config` parameter of `create_model`:

```python
has_var_keyword = any(
    p.kind == inspect.Parameter.VAR_KEYWORD
    for p in sig.parameters.values()
)
config = {"extra": "allow"} if has_var_keyword else {}
model = create_model(f"{method.__name__}_Params", __config__=type("C", (), config), **fields)
```

Wait — `create_model` in pydantic v2 doesn't take `__config__` the same way. The correct approach for pydantic v2 is:

```python
from pydantic import ConfigDict

# After building fields dict:
if has_var_keyword:
    model = create_model(
        f"{method.__name__}_Params",
        __config__=ConfigDict(extra="allow"),
        **fields,
    )
else:
    model = create_model(f"{method.__name__}_Params", **fields)
```

Actually, check pydantic v2 `create_model` docs. The `__config__` kwarg should accept a ConfigDict. If that doesn't work, the alternative is to create the model class dynamically with `model_config` attribute. Research the actual pydantic v2 API before implementing — do NOT guess. The key behavior: `update(task_id, status='in_progress')` must pass validation where `task_id` is a known param and `status` is an extra kwarg.

**Also in _validate_tool_params:** When the method has VAR_KEYWORD, the validated model will contain the extra fields. The current code pops the first param and passes rest as kwargs — this should work naturally since pydantic's `model_dump()` will include extra fields when `extra="allow"`.

**Test — Add regression test:**

In `tests/test_task_resource.py`, add a test in `TestUpdate`:

```python
def test_update_positional_id_keyword_status(self, rs):
    """Regression: update('id', status='in_progress') must work."""
    rs.add("Positional test", MAJOR_BODY, priority="1.0.0")
    tasks = rs._store.list_active()
    task_id = tasks[0]["id"]
    result = rs.update(task_id, status="in_progress")
    assert "Updated" in result
```

This test exercises the service-level `update()` which uses `**kwargs`. The _build_validator fix ensures the ToolRouter dispatch path also works (ToolRouter calls _build_validator on the method). Add a ToolRouter-level test too:

```python
def test_dispatch_update_with_kwargs(self, registry_ns):
    """Regression: ToolRouter dispatches update with kwargs correctly."""
    reg, ns, rs = registry_ns
    reg.navigate("tasks")
    rs.add("Dispatch test", MAJOR_BODY, priority="1.0.0")
    tasks = rs._store.list_active()
    task_id = tasks[0]["id"]
    from bae.repl.tools import ToolRouter
    router = ToolRouter(reg)
    result = router.dispatch("update", task_id, status="in_progress")
    assert "Updated" in result
```

Run `uv run pytest tests/test_task_store.py tests/test_task_resource.py -x -q` after changes.
  </action>
  <verify>
`uv run pytest tests/test_task_store.py tests/test_task_resource.py -x -q` — all pass including new regression tests. Then run full suite: `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` to confirm no breakage.
  </verify>
  <done>
`update(task_id, status='in_progress')` works via both direct service call and ToolRouter dispatch. VAR_KEYWORD params are skipped in validator field building. Extra kwargs pass through with pydantic extra="allow".
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` — full suite green
2. Manual spot check in Python: create TaskStore, add a task, confirm ID is short base36 (e.g., "1")
3. Confirm `format_task_row` output includes ID as first column
4. Confirm `update("1", status="in_progress")` works through ToolRouter
</verification>

<success_criteria>
- Task IDs are base36-encoded integers (e.g., "1", "a", "1z"), not 36-char UUIDs
- `read()` listing shows IDs in each row so users can reference tasks
- `update(task_id, status='in_progress')` works with positional ID + keyword fields via ToolRouter
- All existing tests pass (updated for new ID format)
- New regression tests for kwargs handling pass
</success_criteria>

<output>
After completion, create `.planning/phases/33-task-resourcespace/33-03-SUMMARY.md`
</output>
