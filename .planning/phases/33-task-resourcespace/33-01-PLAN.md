---
phase: 33-task-resourcespace
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/spaces/tasks/__init__.py
  - bae/repl/spaces/tasks/models.py
  - bae/repl/spaces/view.py
  - tests/test_task_store.py
autonomous: true

must_haves:
  truths:
    - "TaskStore creates SQLite database with tasks, tags, dependencies, and audit tables"
    - "TaskStore CRUD operations persist tasks with title, body, status, priority, tags, and timestamps"
    - "FTS5 search returns tasks matching title or body text"
    - "Custom tool names (add, done, update, search) are cleaned up when navigating away from a resourcespace"
  artifacts:
    - path: "bae/repl/spaces/tasks/models.py"
      provides: "TaskStore class with SQLite schema, CRUD, FTS5 search, audit log"
      contains: "class TaskStore"
    - path: "bae/repl/spaces/tasks/__init__.py"
      provides: "Package init exporting TaskResourcespace"
    - path: "tests/test_task_store.py"
      provides: "Unit tests for TaskStore CRUD, FTS5, priority ordering, lifecycle"
  key_links:
    - from: "bae/repl/spaces/tasks/models.py"
      to: "sqlite3"
      via: "WAL-mode connection with row_factory"
      pattern: "sqlite3\\.connect"
    - from: "bae/repl/spaces/view.py"
      to: "_put_tools cleanup"
      via: "_prev_custom tracking set"
      pattern: "_prev_custom"
---

<objective>
Build the TaskStore data layer and fix the registry's custom tool cleanup.

Purpose: TaskStore provides all SQLite persistence — schema creation, CRUD operations, FTS5
full-text search, priority heap ordering, tag management, dependency tracking, and audit logging.
The registry fix ensures custom tool names (add, done, update, search) don't leak into the
namespace when navigating away from the task resourcespace.

Output: `bae/repl/spaces/tasks/models.py` with TaskStore class, `tests/test_task_store.py`
with comprehensive unit tests, and patched `_put_tools` in `view.py`.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-task-resourcespace/33-RESEARCH.md
@bae/repl/store.py
@bae/repl/spaces/view.py
@bae/repl/spaces/source/models.py
@tests/test_resource.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build TaskStore data layer with SQLite schema and CRUD</name>
  <files>bae/repl/spaces/tasks/__init__.py, bae/repl/spaces/tasks/models.py</files>
  <action>
Create `bae/repl/spaces/tasks/` package.

`__init__.py`: Empty for now (will export TaskResourcespace after plan 33-02).

`models.py`: Create `TaskStore` class following the `SessionStore` pattern in `bae/repl/store.py`.

**Schema** (from RESEARCH.md):
- `tasks` table: id (TEXT PK, uuid7), title (TEXT NOT NULL), body (TEXT NOT NULL DEFAULT ''),
  status (TEXT CHECK open/in_progress/blocked/done/cancelled), priority_major/minor/patch (INTEGER),
  parent_id (TEXT FK self), creator (TEXT CHECK agent/user), user_gated (INTEGER DEFAULT 0),
  created_at/updated_at (REAL), metadata (TEXT DEFAULT '{}')
- `task_tags` junction table: task_id + tag (composite PK)
- `task_dependencies`: task_id + blocked_by (composite PK)
- `task_audit`: id (AUTOINCREMENT), task_id, timestamp, field, old_value, new_value, changed_by
- `tasks_fts` FTS5 virtual table: title + body, content=tasks, content_rowid=rowid, tokenize='porter unicode61'
- Triggers: AFTER INSERT, AFTER DELETE, AFTER UPDATE on tasks for FTS sync
- Indexes: status, priority (major/minor/patch), parent_id

**TaskStore class methods:**
- `__init__(self, db_path: Path)`: Create parent dirs, connect with WAL mode + row_factory=sqlite3.Row, run schema
- `create(self, title, body, priority, creator, parent_id, user_gated, metadata) -> dict`: Insert task, return as dict. Generate id with uuid.uuid7(). Set created_at/updated_at to time.time(). For major tasks (minor=0, patch=0), validate body contains required structured sections: `<assumptions>`, `<reasoning`, `<background_research>`, `<acceptance_criteria`. For minor tasks (minor>0), validate parent exists with matching major number. Return task as dict.
- `get(self, task_id: str) -> dict`: Fetch single task by id with tags joined. Raise ValueError if not found.
- `list_active(self, status_filter=None, tag_filter=None, priority_filter=None) -> list[dict]`: Default listing — in_progress + blocked first, then open, ordered by priority. Filter params optional. tag_filter supports list of tags (AND semantics by default).
- `list_all(self, include_done=False) -> list[dict]`: All tasks including done/cancelled if flag set.
- `update(self, task_id, **fields) -> dict`: Update allowed fields (title, body, status, priority_*, tags, user_gated, metadata). Log each field change in task_audit. Update updated_at. For status changes, enforce lifecycle rules: done/cancelled are final (raise ValueError if trying to reopen). Return updated task.
- `mark_done(self, task_id, changed_by='agent') -> dict`: Transition to 'done'. If major task, self-verify (return info about whether minor subtasks are done). Log audit. If user_gated, return flag indicating user confirmation needed.
- `cancel(self, task_id, changed_by='agent') -> dict`: Transition to 'cancelled'. Log audit.
- `add_tag(self, task_id, tag) -> str`: Add tag to junction table. Return tag name.
- `remove_tag(self, task_id, tag) -> str`: Remove tag. Return tag name.
- `all_tags(self) -> set[str]`: Distinct tags across all tasks.
- `add_dependency(self, task_id, blocked_by_id) -> None`: Add dependency with cycle detection (DFS from blocked_by_id checking for task_id). Set task status to 'blocked' if it was 'open'.
- `remove_dependency(self, task_id, blocked_by_id) -> None`: Remove dependency. If no remaining blockers and status is 'blocked', transition to 'open'.
- `search(self, query: str) -> list[dict]`: FTS5 search on title+body. Return matching tasks with BM25 rank ordering. Join tags.
- `status_counts(self) -> dict[str, int]`: Count by status for display.
- `stale_tasks(self, days=14) -> list[dict]`: Tasks with updated_at older than N days, status in (open, in_progress).
- `outstanding_count(self) -> int`: Count of open + in_progress + blocked tasks (for homespace display).
- `_audit(self, task_id, field, old, new, changed_by)`: Internal audit log helper.
- `_task_to_dict(self, row) -> dict`: Convert sqlite3.Row to dict with tags list.

Use `uuid.uuid7()` for IDs (matches store.py). Use `time.time()` for timestamps.
Priority tuple stored as three INTEGER columns — heapq-compatible `(major, minor, patch)`.
  </action>
  <verify>
    `uv run python -c "from bae.repl.spaces.tasks.models import TaskStore; print('import ok')"`
  </verify>
  <done>TaskStore class exists with all CRUD methods, SQLite schema with FTS5, triggers, and indexes.</done>
</task>

<task type="auto">
  <name>Task 2: Fix custom tool name cleanup in ResourceRegistry._put_tools</name>
  <files>bae/repl/spaces/view.py</files>
  <action>
The current `_put_tools()` only removes names in `_TOOL_NAMES` (read/write/edit/glob/grep). Custom
tool names like `add`, `done`, `search`, `update` injected by task resourcespace will persist in
the namespace after navigating away.

Fix by adding a `_prev_custom: set[str]` field on `ResourceRegistry.__init__` (default empty set).

In `_put_tools()`:
1. Before injecting new tools, pop all names in `_prev_custom` from namespace (same pattern as `_TOOL_NAMES` cleanup)
2. Clear `_prev_custom`
3. After injecting tools from `current.tools()`, identify which names are NOT in `_TOOL_NAMES` and add them to `_prev_custom`

This is a minimal change — 5-6 lines added. No protocol modification needed.

Existing tests in `test_resource.py` should still pass. The change is backward-compatible since
resourcespaces returning only standard tool names (like source) will have an empty `_prev_custom`.
  </action>
  <verify>
    `uv run pytest tests/test_resource.py -x -q` — all existing tests pass.
    Manual check: create a StubSpace with custom tool names, navigate to it, navigate away, verify custom names removed from namespace.
  </verify>
  <done>Custom tool names are cleaned from namespace on navigation. `_prev_custom` tracking set works.</done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for TaskStore</name>
  <files>tests/test_task_store.py</files>
  <action>
Create `tests/test_task_store.py` with comprehensive tests for TaskStore. Use `tmp_path` fixture
for SQLite database (no persistent state between tests).

Test groups:

**Schema and initialization:**
- TaskStore creates database file and all tables
- WAL mode enabled

**CRUD basics:**
- create() returns dict with all fields populated including uuid7 id and timestamps
- get() retrieves task by id with tags
- get() raises ValueError for nonexistent id
- list_active() returns in_progress + blocked + open tasks (not done/cancelled)
- list_active() orders: in_progress first, then blocked, then open, each group by priority

**Priority and hierarchy:**
- Tasks sort by (major, minor, patch) ascending
- Minor task creation validates parent exists
- Minor task creation fails if no matching major task
- Major task body must contain required structured sections

**Lifecycle:**
- Status transitions: open -> in_progress -> done
- open -> blocked (via dependency)
- done/cancelled are final — update raises ValueError on reopen attempt
- mark_done() returns user_gated flag when task is user-gated
- cancel() transitions to cancelled

**Tags:**
- add_tag/remove_tag work
- all_tags returns distinct tags across tasks
- list_active with tag_filter returns only matching tasks

**Dependencies:**
- add_dependency sets status to blocked
- remove_dependency with no remaining blockers sets status back to open
- Cycle detection raises ValueError

**FTS search:**
- search() finds tasks by title text
- search() finds tasks by body text
- search() returns results ordered by BM25 rank
- search() returns empty list for no matches

**Audit:**
- Status changes logged in task_audit
- Field updates logged in task_audit

**Counts:**
- status_counts returns correct counts per status
- outstanding_count returns sum of open + in_progress + blocked
- stale_tasks returns tasks with no activity for N days

**Custom tool cleanup (view.py change):**
- Add test to test_resource.py: StubSpace with custom tool `{"add": lambda: None}`, navigate in,
  verify "add" in namespace, navigate to different space, verify "add" NOT in namespace.

All tests must produce pristine output — no warnings, no uncaptured errors.
  </action>
  <verify>
    `uv run pytest tests/test_task_store.py tests/test_resource.py -x -q` — all tests pass with clean output.
  </verify>
  <done>All TaskStore operations tested. Custom tool cleanup tested. Zero failures, pristine output.</done>
</task>

</tasks>

<verification>
1. `uv run python -c "from bae.repl.spaces.tasks.models import TaskStore; print('ok')"` — imports clean
2. `uv run pytest tests/test_task_store.py -x -q` — all TaskStore tests pass
3. `uv run pytest tests/test_resource.py -x -q` — existing + new custom tool cleanup tests pass
4. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` — full suite passes
</verification>

<success_criteria>
- TaskStore creates SQLite DB with all 4 tables + FTS5 + triggers + indexes
- All CRUD operations work: create, get, list, update, mark_done, cancel
- FTS5 search finds tasks by title and body text
- Priority ordering works as heapq-compatible tuples
- Status lifecycle enforced (done/cancelled are final)
- Dependency cycle detection prevents deadlocks
- Audit trail logs all status and field changes
- Custom tool names cleaned from namespace on navigation away
- All tests pass with pristine output
</success_criteria>

<output>
After completion, create `.planning/phases/33-task-resourcespace/33-01-SUMMARY.md`
</output>
