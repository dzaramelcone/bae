---
phase: 33-task-resourcespace
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - bae/repl/spaces/tasks/__init__.py
  - bae/repl/spaces/tasks/view.py
  - bae/repl/spaces/tasks/service.py
  - bae/repl/shell.py
  - bae/repl/spaces/view.py
  - tests/test_task_resource.py
autonomous: true

must_haves:
  truths:
    - "Agent calls tasks() and enters task resourcespace with status summary and functions table"
    - "Agent can create tasks with add() including structured sections for major tasks"
    - "Agent can list and read tasks with read(), filtering by status/tag/priority"
    - "Agent can update task fields with update() and mark tasks done with done()"
    - "Agent can search tasks via FTS with search()"
    - "Homespace entry shows outstanding task count"
  artifacts:
    - path: "bae/repl/spaces/tasks/service.py"
      provides: "TaskResourcespace class with CRUD tools and FTS search"
      contains: "class TaskResourcespace"
    - path: "bae/repl/spaces/tasks/view.py"
      provides: "Display formatting for task listing and detail views"
    - path: "bae/repl/spaces/tasks/__init__.py"
      provides: "Package init exporting TaskResourcespace"
      contains: "TaskResourcespace"
    - path: "tests/test_task_resource.py"
      provides: "Integration tests for task resourcespace protocol and tools"
  key_links:
    - from: "bae/repl/spaces/tasks/service.py"
      to: "bae/repl/spaces/tasks/models.py"
      via: "TaskStore instance"
      pattern: "TaskStore"
    - from: "bae/repl/spaces/tasks/service.py"
      to: "bae/repl/spaces/view.py"
      via: "Resourcespace protocol + ResourceError"
      pattern: "Resourcespace|ResourceError"
    - from: "bae/repl/shell.py"
      to: "bae/repl/spaces/tasks/service.py"
      via: "Registration and ResourceHandle"
      pattern: "TaskResourcespace|tasks"
    - from: "bae/repl/spaces/view.py"
      to: "bae/repl/spaces/tasks/service.py"
      via: "outstanding_count in _build_orientation"
      pattern: "outstanding_count"
---

<objective>
Build the TaskResourcespace service, view, and wire it into shell registration and homespace.

Purpose: This plan makes tasks a fully navigable resourcespace. The agent can enter tasks(),
see status counts and a functions table, create/read/update/search tasks using tool verbs,
and see the outstanding task count on the homespace entry display.

Output: Complete task resourcespace with service.py, view.py, shell registration, homespace
integration, and integration tests.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-task-resourcespace/33-RESEARCH.md
@.planning/phases/33-task-resourcespace/33-01-SUMMARY.md
@bae/repl/spaces/view.py
@bae/repl/spaces/source/service.py
@bae/repl/shell.py
@bae/repl/spaces/tasks/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskResourcespace service and view layer</name>
  <files>bae/repl/spaces/tasks/service.py, bae/repl/spaces/tasks/view.py, bae/repl/spaces/tasks/__init__.py</files>
  <action>
**`view.py`**: Display formatting functions (stateless, pure string output).

- `format_task_row(task: dict) -> str`: One-line format for listing — `status | priority | title | tags`.
  Status uses short labels: `OPEN`, `PROG`, `BLKD`, `DONE`, `CNCL`.
  Priority as `major.minor.patch`. Tags comma-separated. Truncate title if needed.
- `format_task_detail(task: dict) -> str`: Full task detail view — all fields, body content,
  tags, dependencies, audit history. Show structured sections if present in body.
- `format_task_list(tasks: list[dict], header: str = "") -> str`: Header + rows via format_task_row.
  Show count. Empty state message if no tasks.
- `format_search_results(tasks: list[dict], query: str) -> str`: Search header + results with
  rank indication.

**`service.py`**: `TaskResourcespace` class implementing `Resourcespace` protocol.

Follow `SourceResourcespace` pattern exactly: import from `bae.repl.spaces.view` for protocol
types, delegate storage to `TaskStore` from models.

```python
class TaskResourcespace:
    name = "tasks"
    description = "Persistent task management with priority and search"

    def __init__(self, db_path: Path) -> None:
        self._store = TaskStore(db_path)
```

**Protocol methods:**
- `enter() -> str`: Status counts (open/in_progress/blocked), stale task warning if any (14 days),
  description text. NO functions table here — the registry's `_entry_display` renders it from
  `supported_tools()` and `tools()`.
- `nav() -> str`: Simple — tasks has no subresources. Return empty string.
- `read(target: str = "") -> str`: If target is empty, list active tasks via `format_task_list`.
  If target looks like a task ID (uuid), show detail via `format_task_detail`. Support filter
  params as colon-separated: `read("status:blocked")`, `read("tag:urgent")`, `read("priority:1")`.
  Use `ResourceError` with hints for bad targets.
- `supported_tools() -> set[str]`: Return `{"read", "add", "done", "update", "search"}`.
- `children() -> dict`: Empty dict — no subresources.
- `tools() -> dict[str, Callable]`: Return `{"read": self.read, "add": self.add, "done": self.done, "update": self.update, "search": self.search}`.

**Custom tool methods:**
- `add(title: str, body: str = "", priority: str = "0.0.0", creator: str = "agent", parent: str = "", tags: str = "") -> str`:
  Parse priority string "major.minor.patch" into tuple. Parse tags as comma-separated.
  If tags contain new tags (not in all_tags), include light friction note in response listing existing tags.
  Call `_store.create()`. Return formatted confirmation with task ID.
  For major tasks, validate body has required structured sections.
  For minor tasks (minor > 0), resolve parent from priority major.
- `done(task_id: str) -> str`: Call `_store.mark_done()`. If user_gated, return message asking
  user to confirm. If major task, check if all minors are done and report.
  Return formatted confirmation.
- `update(task_id: str, **kwargs) -> str`: Update fields via `_store.update()`.
  Accept: status, priority, title, body, tags (comma-separated to add), user_gated.
  Return formatted confirmation showing changed fields.
- `search(query: str) -> str`: Call `_store.search()`. Return formatted search results.
  If no results, return message with hints.

**`__init__.py`**: Export TaskResourcespace:
```python
from bae.repl.spaces.tasks.service import TaskResourcespace
__all__ = ["TaskResourcespace"]
```

All errors use `ResourceError` with navigation hints (e.g., `hints=["tasks() to see all tasks", "search('keyword') to find tasks"]`).
  </action>
  <verify>
    `uv run python -c "from bae.repl.spaces.tasks import TaskResourcespace; print('import ok')"`
    `uv run python -c "from bae.repl.spaces.tasks.view import format_task_row; print('ok')"`
  </verify>
  <done>TaskResourcespace implements full Resourcespace protocol with add/done/update/search tools. View layer formats tasks for display.</done>
</task>

<task type="auto">
  <name>Task 2: Register task resourcespace in shell and add homespace count</name>
  <files>bae/repl/shell.py, bae/repl/spaces/view.py</files>
  <action>
**shell.py** — Register TaskResourcespace alongside SourceResourcespace in `CortexShell.__init__`:

After the existing source registration block (lines ~241-243), add:
```python
from bae.repl.spaces.tasks import TaskResourcespace

task_rs = TaskResourcespace(Path.cwd() / ".bae" / "tasks.db")
self.registry.register(task_rs)
self.namespace["tasks"] = ResourceHandle("tasks", self.registry)
```

Import `TaskResourcespace` at top of file alongside `SourceResourcespace`.

**view.py** — Add outstanding task count to `_build_orientation()`:

In `_build_orientation()`, after the resourcespaces listing, check if "tasks" is in `self._spaces`.
If so, call `self._spaces["tasks"].outstanding_count()` (add this method to TaskResourcespace — it
delegates to `self._store.outstanding_count()`). If count > 0, append a line like:
`"Tasks: {count} outstanding"` after the resourcespaces block.

The `outstanding_count()` method is NOT part of the Resourcespace protocol — it's a concrete
method on TaskResourcespace. The registry accesses it directly since it holds the concrete instance.
Use a hasattr check or duck-type test to avoid coupling view.py to TaskResourcespace:

```python
if self._spaces:
    for name, space in sorted(self._spaces.items()):
        lines.append(f"  {name}() -- {space.description}")
    # Task count if available
    task_space = self._spaces.get("tasks")
    if task_space and hasattr(task_space, "outstanding_count"):
        count = task_space.outstanding_count()
        if count:
            lines.append(f"\nTasks: {count} outstanding")
```

This keeps view.py protocol-clean — no import of TaskResourcespace needed.
  </action>
  <verify>
    `uv run python -c "from bae.repl.shell import CortexShell; print('import ok')"`
    `uv run pytest tests/test_resource.py -x -q` — existing tests still pass
  </verify>
  <done>tasks() is a navigable resourcespace. Homespace shows outstanding task count. Shell registration complete.</done>
</task>

<task type="auto">
  <name>Task 3: Write integration tests for task resourcespace</name>
  <files>tests/test_task_resource.py</files>
  <action>
Create `tests/test_task_resource.py` with integration tests verifying the full resourcespace
protocol and tool behavior. Use `tmp_path` for database.

**Protocol conformance:**
- TaskResourcespace is isinstance of Resourcespace protocol
- name is "tasks", description is non-empty
- supported_tools includes read, add, done, update, search
- children returns empty dict
- tools returns dict with all 5 tool callables

**Entry display:**
- enter() shows status counts
- enter() shows stale warning when stale tasks exist
- enter() with no tasks shows zero counts

**Navigation (via ResourceRegistry):**
- Create registry with namespace dict, register TaskResourcespace
- Navigate to tasks() — returns NavResult with breadcrumb + functions table
- Verify tool names injected into namespace (read, add, done, update, search)
- Navigate away (home) — verify custom tools removed from namespace

**Tool integration:**
- add() creates task, returns confirmation with ID
- add() with major task enforces structured sections in body
- add() with minor task links to parent
- add() with new tag shows friction note
- read() with no args lists active tasks
- read(task_id) shows task detail
- read("status:blocked") filters by status
- read("tag:someTag") filters by tag
- done(task_id) marks task complete
- done() on user_gated task returns confirmation-needed message
- update(task_id, status="in_progress") transitions status
- update() on done task raises ResourceError
- search("keyword") returns matching tasks
- search("nonexistent") returns empty with hints

**Homespace count:**
- _build_orientation() includes "Tasks: N outstanding" when tasks exist
- _build_orientation() omits task line when count is 0

**Persistence:**
- Create TaskResourcespace with db_path, add task, create NEW TaskResourcespace with same db_path — task persists

All tests must produce pristine output. Capture any expected error output and validate it.
  </action>
  <verify>
    `uv run pytest tests/test_task_resource.py -x -q` — all tests pass
    `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` — full suite passes
  </verify>
  <done>All 8 requirements (TSK-01 through TSK-08) verified through tests. Full suite passes with pristine output.</done>
</task>

</tasks>

<verification>
1. `uv run python -c "from bae.repl.spaces.tasks import TaskResourcespace; t = TaskResourcespace('/tmp/test.db'); print(t.enter())"` — shows status counts
2. `uv run pytest tests/test_task_resource.py -x -q` — all integration tests pass
3. `uv run pytest tests/test_resource.py -x -q` — existing tests still pass (no regression)
4. `uv run pytest tests/ -x -q --ignore=tests/test_integration.py` — full suite green
5. Verify requirements coverage:
   - TSK-01: tasks() navigates into resourcespace (test: navigation via registry)
   - TSK-02: add() creates tasks (test: add tool)
   - TSK-03: read() lists and reads tasks (test: read tool)
   - TSK-04: update() changes fields (test: update tool)
   - TSK-05: done() marks complete (test: done tool)
   - TSK-06: search() FTS query (test: search tool)
   - TSK-07: Persistence across sessions (test: two instances same db)
   - TSK-08: Homespace count (test: _build_orientation)
</verification>

<success_criteria>
- tasks() enters resourcespace showing status summary and functions table
- add() creates tasks with title, body, priority, tags, structured sections
- read() lists active tasks and reads individual task details with filtering
- update() changes status, priority, tags, and other fields
- done() marks tasks complete with lifecycle enforcement
- search() returns FTS-ranked results
- Homespace shows "Tasks: N outstanding" when tasks exist
- All 8 requirements (TSK-01 through TSK-08) satisfied
- Full test suite passes with pristine output
</success_criteria>

<output>
After completion, create `.planning/phases/33-task-resourcespace/33-02-SUMMARY.md`
</output>
