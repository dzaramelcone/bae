---
phase: 01-signature-generation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/markers.py
  - bae/compiler.py
  - tests/test_compiler.py
autonomous: true

must_haves:
  truths:
    - "node_to_signature(NodeClass) returns a valid dspy.Signature subclass"
    - "Signature instruction equals the Node class name (e.g., 'AnalyzeUserIntent')"
    - "Annotated fields become InputFields with their descriptions"
    - "Unannotated fields are excluded from the Signature"
    - "Return type hint becomes the OutputField"
  artifacts:
    - path: "bae/markers.py"
      provides: "Context annotation marker"
      contains: "class Context"
    - path: "bae/compiler.py"
      provides: "node_to_signature() function returning dspy.Signature"
      contains: "make_signature"
    - path: "tests/test_compiler.py"
      provides: "TDD tests for signature generation"
      min_lines: 50
  key_links:
    - from: "bae/compiler.py"
      to: "dspy.make_signature"
      via: "function call"
      pattern: "make_signature\\("
    - from: "bae/compiler.py"
      to: "bae/markers.py"
      via: "import"
      pattern: "from bae.markers import"
    - from: "bae/compiler.py"
      to: "get_type_hints"
      via: "function call"
      pattern: "get_type_hints.*include_extras.*True"
---

<objective>
Implement `node_to_signature()` to convert bae Node classes into valid DSPy Signature classes through TDD.

Purpose: This is the core Phase 1 deliverable. DSPy Signatures are the bridge between bae's type-driven nodes and DSPy's prompt compilation. Getting this right enables Phase 2's DSPy integration.

Output: Working `node_to_signature()` function with full test coverage, plus the `Context` annotation marker.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-signature-generation/01-CONTEXT.md
@.planning/phases/01-signature-generation/01-RESEARCH.md

# Source files to modify
@bae/compiler.py
@bae/node.py

# Test patterns to follow
@tests/test_node.py
</context>

<feature>
  <name>node_to_signature: Convert Node classes to DSPy Signatures</name>

  <files>
    bae/markers.py (new)
    bae/compiler.py (modify)
    tests/test_compiler.py (new)
  </files>

  <behavior>
## Expected Behavior

Given a Node subclass with annotated fields, `node_to_signature()` returns a dspy.Signature class.

### Test Cases

**Case 1: Class name becomes instruction**
```python
class AnalyzeUserIntent(Node):
    pass

sig = node_to_signature(AnalyzeUserIntent)
assert sig.instructions == "AnalyzeUserIntent"
```

**Case 2: Annotated field becomes InputField**
```python
class ProcessRequest(Node):
    request: Annotated[str, Context(description="The user's request")]

sig = node_to_signature(ProcessRequest)
assert "request" in sig.input_fields
assert sig.input_fields["request"].json_schema_extra["desc"] == "The user's request"
```

**Case 3: Unannotated field excluded**
```python
class ProcessRequest(Node):
    request: Annotated[str, Context(description="The user's request")]
    internal_counter: int = 0  # No Annotated wrapper

sig = node_to_signature(ProcessRequest)
assert "request" in sig.input_fields
assert "internal_counter" not in sig.input_fields
```

**Case 4: Multiple annotated fields**
```python
class ChatNode(Node):
    history: Annotated[str, Context(description="Chat history")]
    user_input: Annotated[str, Context(description="Current user message")]

sig = node_to_signature(ChatNode)
assert "history" in sig.input_fields
assert "user_input" in sig.input_fields
```

**Case 5: Return type becomes OutputField**
```python
class Decider(Node):
    def __call__(self, lm) -> Response | None:
        ...

sig = node_to_signature(Decider)
assert "output" in sig.output_fields
# Note: Output type handling - for Phase 1, use str as output type
# Union handling deferred to Phase 2
```

**Case 6: Node with no annotated fields**
```python
class EmptyNode(Node):
    internal: int = 0

sig = node_to_signature(EmptyNode)
assert len(sig.input_fields) == 0  # Valid - no inputs
assert "output" in sig.output_fields
```

**Case 7: Result is valid dspy.Signature subclass**
```python
sig = node_to_signature(SomeNode)
assert issubclass(sig, dspy.Signature)
```
  </behavior>

  <implementation>
## Implementation Guide

### Step 1: Create Context marker (bae/markers.py)

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Context:
    """Marker for Node fields that should become DSPy InputFields.

    Usage:
        class MyNode(Node):
            data: Annotated[str, Context(description="The data to process")]
    """
    description: str
```

### Step 2: Implement node_to_signature (bae/compiler.py)

Replace the existing stub with:

```python
from typing import Annotated, get_type_hints, get_origin, get_args
import dspy
from bae.markers import Context
from bae.node import Node

def node_to_signature(node_cls: type[Node]) -> type[dspy.Signature]:
    """Convert a Node class to a DSPy Signature.

    - Class name becomes instruction text
    - Annotated[type, Context(description="...")] fields become InputFields
    - Unannotated fields are excluded (internal state)
    - Return type becomes OutputField (str for Phase 1)
    """
    fields = {}

    # Extract annotated fields
    hints = get_type_hints(node_cls, include_extras=True)
    for name, hint in hints.items():
        if get_origin(hint) is Annotated:
            args = get_args(hint)
            base_type = args[0]
            metadata = args[1:]

            for meta in metadata:
                if isinstance(meta, Context):
                    fields[name] = (base_type, dspy.InputField(desc=meta.description))
                    break

    # Output field (str for Phase 1 - union handling in Phase 2)
    fields["output"] = (str, dspy.OutputField())

    # Class name as instruction
    instruction = node_cls.__name__

    return dspy.make_signature(fields, instruction)
```

### Key Implementation Notes

1. **Use get_type_hints with include_extras=True** - This preserves the Annotated wrapper
2. **Check get_origin(hint) is Annotated** - Identifies wrapped types
3. **Look for Context marker in metadata** - Only our marker, not other annotations
4. **Use dspy.InputField/OutputField** - Not raw pydantic.Field (DSPy needs __dspy_field_type)
5. **Use dspy.make_signature()** - Handles all metaclass complexity
6. **Output is str for now** - Union type handling deferred to Phase 2

### What NOT to do

- Don't parse docstrings (LOCKED DECISION: class name only)
- Don't try to handle union return types specially (Phase 2)
- Don't use pydantic.Field directly (must use dspy.InputField/OutputField)
- Don't include unannotated fields
  </implementation>
</feature>

<verification>
After TDD cycle completes:

```bash
# Run the new tests
pytest tests/test_compiler.py -v

# Run all tests to ensure no regressions
pytest tests/ -v

# Verify import works
python -c "from bae.compiler import node_to_signature; from bae.markers import Context; print('OK')"
```

All tests should pass. No regressions in existing tests.
</verification>

<success_criteria>
Requirements covered:
- [x] SIG-01: Node class name becomes Signature instruction
- [x] SIG-02: Node fields become InputFields (via Annotated + Context marker)
- [x] SIG-03: Dep fields become InputFields (same pattern - if annotated, they're included)
- [x] SIG-04: Return type hint becomes OutputField (str for Phase 1)
- [x] SIG-05: N/A - docstring support explicitly excluded per CONTEXT.md decision

Phase 1 is complete when:
1. `node_to_signature()` returns valid dspy.Signature subclass
2. All 7 test cases pass
3. No regressions in existing tests
4. Context marker is importable from bae.markers
</success_criteria>

<output>
After completion, create `.planning/phases/01-signature-generation/01-01-SUMMARY.md` using the summary template.

Include:
- What was built (node_to_signature, Context marker)
- Test coverage achieved
- Any implementation decisions made
- Deferred items (union return type handling -> Phase 2)
</output>
