---
phase: 13-fix-nested-fill
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/lm.py
  - bae/dspy_backend.py
  - tests/test_fill_helpers.py
  - tests/test_fill_protocol.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "validate_plain_fields() returns nested BaseModel instances, not dicts"
    - "ClaudeCLIBackend.fill() returns nodes with nested model instances"
    - "PydanticAIBackend.fill() returns nodes with nested model instances"
    - "DSPyBackend.fill() returns nodes with nested model instances"
    - "E2E test_anticipate_has_llm_filled_vibe passes (anticipate.vibe is VibeCheck)"
    - "Full test suite passes with 0 regressions"
  artifacts:
    - path: "bae/lm.py"
      provides: "Fixed validate_plain_fields + PydanticAIBackend.fill"
      contains: "getattr(validated, name) for name in validated.model_fields"
    - path: "bae/dspy_backend.py"
      provides: "Fixed DSPyBackend.fill with validation"
      contains: "validate_plain_fields"
    - path: "tests/test_fill_helpers.py"
      provides: "Updated test_nested_model_validated + new preservation test"
      contains: "isinstance(result[\"vibe\"], VibeCheck)"
    - path: "tests/test_fill_protocol.py"
      provides: "Fill integration test for nested model preservation"
      contains: "isinstance.*VibeCheck"
  key_links:
    - from: "bae/lm.py:validate_plain_fields"
      to: "bae/lm.py:ClaudeCLIBackend.fill"
      via: "validated dict with model instances passed to model_construct"
      pattern: "validate_plain_fields.*model_construct"
    - from: "bae/lm.py:PydanticAIBackend.fill"
      to: "target.model_construct"
      via: "getattr extraction instead of model_dump"
      pattern: "getattr.*model_fields"
    - from: "bae/dspy_backend.py:DSPyBackend.fill"
      to: "bae/lm.py:validate_plain_fields"
      via: "raw DSPy output validated before model_construct"
      pattern: "validate_plain_fields.*model_construct"
---

<objective>
Fix nested Pydantic model construction in all three fill() backends so nested BaseModel fields (e.g., `vibe: VibeCheck`) are proper model instances, not raw dicts.

Purpose: Close MIG-03 gap -- `test_anticipate_has_llm_filled_vibe` E2E test fails because `fill()` returns raw dicts instead of nested VibeCheck model instances. Root cause: `model_dump()` destroys validated instances before `model_construct()` receives them.

Output: Fixed `validate_plain_fields()`, three fixed `fill()` methods, updated tests, 0 regressions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-fix-nested-fill/13-RESEARCH.md
@bae/lm.py
@bae/dspy_backend.py
@tests/test_fill_helpers.py
@tests/test_fill_protocol.py
@tests/test_ootd_e2e.py
@examples/ootd.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for nested model preservation</name>
  <files>
    tests/test_fill_helpers.py
    tests/test_fill_protocol.py
  </files>
  <action>
    Write failing tests FIRST that encode the correct behavior (nested model instances, not dicts).

    In `tests/test_fill_helpers.py`:

    1. Update `test_nested_model_validated` (line 182) -- change the assertion from dict access to isinstance check:
       ```python
       def test_nested_model_validated(self):
           """Nested BaseModel plain fields are preserved as model instances."""
           from bae.lm import validate_plain_fields
           raw = {"vibe": {"mood": "happy", "style": "casual"}}
           result = validate_plain_fields(raw, MixedNode)
           assert isinstance(result["vibe"], VibeCheck)
           assert result["vibe"].mood == "happy"
           assert result["vibe"].style == "casual"
       ```

    2. Add a new test `test_nested_model_preserves_instance_type` in TestValidatePlainFields:
       ```python
       def test_nested_model_preserves_instance_type(self):
           """validate_plain_fields preserves nested model instances, not raw dicts."""
           from bae.lm import validate_plain_fields
           raw = {"vibe": {"mood": "chill", "style": "relaxed"}}
           result = validate_plain_fields(raw, MixedNode)
           # Must be VibeCheck, NOT dict
           assert not isinstance(result["vibe"], dict)
           assert isinstance(result["vibe"], VibeCheck)
       ```

    In `tests/test_fill_protocol.py`:

    3. Add a test class `TestFillNestedModelPreservation` with a test that the CapturingLM pattern (which already exists in the file) is used to verify that when ClaudeCLIBackend.fill() is called with mock data containing a nested model dict, the result has a proper model instance:
       ```python
       class TestFillNestedModelPreservation:
           """fill() returns nodes with nested BaseModel instances, not raw dicts."""

           async def test_cli_fill_preserves_nested_model(self):
               """ClaudeCLIBackend.fill() produces VibeCheck instance, not dict."""
               from examples.ootd import AnticipateUsersDay, VibeCheck, WeatherResult, CalendarResult, GeoLocation

               backend = ClaudeCLIBackend()
               resolved = {
                   "weather": WeatherResult(name="Seattle", conditions=[], temp=72.0,
                       feels_like=70.0, temp_min=65.0, temp_max=75.0, humidity=60,
                       wind_speed=5.0, clouds=50, visibility=10000),
                   "schedule": CalendarResult(events=[]),
                   "location": GeoLocation(name="Seattle", lat=47.6, lon=-122.3,
                       country="US", state="WA"),
               }

               async def mock_cli(prompt, schema):
                   return {"vibe": {"mood": "groggy", "communication_style": "casual", "context_cues": "just woke up"}}

               with patch.object(backend, "_run_cli_json", side_effect=mock_cli):
                   result = await backend.fill(AnticipateUsersDay, resolved, "AnticipateUsersDay")

               assert isinstance(result, AnticipateUsersDay)
               assert isinstance(result.vibe, VibeCheck)
               assert result.vibe.mood == "groggy"

           async def test_pydanticai_fill_preserves_nested_model(self):
               """PydanticAIBackend.fill() produces VibeCheck instance, not dict."""
               from unittest.mock import MagicMock
               from tests.test_fill_helpers import MixedNode, VibeCheck, Weather, Location

               backend = PydanticAIBackend()
               resolved = {
                   "weather": Weather(temp=72.0, conditions="sunny"),
                   "location": Location(name="Seattle", lat=47.6, lon=-122.3),
               }

               # Mock the agent to return a plain model with VibeCheck
               mock_result = MagicMock()
               plain_output = MagicMock(spec=BaseModel)
               plain_output.model_fields = {"vibe": None}
               plain_output.vibe = VibeCheck(mood="happy", style="casual")
               type(plain_output).model_fields = property(lambda self: {"vibe": None})
               mock_result.output = plain_output

               with patch.object(backend, "_get_agent") as mock_agent_getter:
                   mock_agent = AsyncMock()
                   mock_agent.run.return_value = mock_result
                   mock_agent_getter.return_value = mock_agent
                   result = await backend.fill(MixedNode, resolved, "MixedNode")

               assert isinstance(result.vibe, VibeCheck)
               assert result.vibe.mood == "happy"
       ```

       Note: The PydanticAI test is tricky to mock cleanly. If mocking is too complex, focus on the CLI test and the validate_plain_fields tests -- those cover the core behavior. The PydanticAI backend fix is mechanically identical (replace model_dump with getattr loop).

    Run tests: `python -m pytest tests/test_fill_helpers.py::TestValidatePlainFields::test_nested_model_validated tests/test_fill_helpers.py::TestValidatePlainFields::test_nested_model_preserves_instance_type -x -v`

    These MUST FAIL (red phase). The test_nested_model_validated will fail because validate_plain_fields currently returns model_dump() output (dicts). Commit the failing tests.
  </action>
  <verify>
    `python -m pytest tests/test_fill_helpers.py::TestValidatePlainFields::test_nested_model_validated tests/test_fill_helpers.py::TestValidatePlainFields::test_nested_model_preserves_instance_type -x -v` -- both tests FAIL.

    `python -m pytest tests/test_fill_protocol.py::TestFillNestedModelPreservation -x -v` -- test(s) FAIL.
  </verify>
  <done>
    Failing tests exist that assert: (a) validate_plain_fields returns VibeCheck instances not dicts, (b) ClaudeCLIBackend.fill returns node with VibeCheck instance. Tests committed.
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Fix validate_plain_fields and all three fill() backends</name>
  <files>
    bae/lm.py
    bae/dspy_backend.py
  </files>
  <action>
    Make the failing tests pass with minimal changes. Three independent fixes:

    **Fix 1: validate_plain_fields() in bae/lm.py (line 98)**

    Replace:
    ```python
    return validated.model_dump()
    ```
    With:
    ```python
    return {name: getattr(validated, name) for name in validated.model_fields}
    ```

    This preserves nested model instances (e.g., VibeCheck) instead of converting them back to dicts. The function still returns `dict[str, Any]` -- the values are just model instances instead of sub-dicts where appropriate.

    **Fix 2: PydanticAIBackend.fill() in bae/lm.py (line 351)**

    Replace:
    ```python
    all_fields.update(plain_output.model_dump())
    ```
    With:
    ```python
    for name in plain_output.model_fields:
        all_fields[name] = getattr(plain_output, name)
    ```

    Same pattern -- getattr preserves nested model instances that model_dump() would destroy.

    **Fix 3: DSPyBackend.fill() in bae/dspy_backend.py (lines 367-374)**

    Replace the current raw-copy approach:
    ```python
    all_fields = dict(resolved)
    for key in result.keys():
        if key not in resolved:
            all_fields[key] = getattr(result, key)
    return target.model_construct(**all_fields)
    ```
    With validation through validate_plain_fields:
    ```python
    from bae.lm import validate_plain_fields

    # Collect raw LM output fields (OutputFields only)
    raw_fields = {}
    for key in result.keys():
        if key not in resolved:
            raw_val = getattr(result, key)
            # DSPy may return JSON strings for complex fields -- parse them
            if isinstance(raw_val, str):
                try:
                    import json
                    raw_val = json.loads(raw_val)
                except (json.JSONDecodeError, ValueError):
                    pass
            raw_fields[key] = raw_val

    # Validate through PlainModel to construct nested model instances
    validated = validate_plain_fields(raw_fields, target)

    all_fields = dict(resolved)
    all_fields.update(validated)
    return target.model_construct(**all_fields)
    ```

    Note: The `json` import already exists at the top of dspy_backend.py. The `validate_plain_fields` import should go at function scope to avoid circular imports (bae.lm imports from bae.resolver, bae.dspy_backend doesn't currently import from bae.lm). Check if a top-level import works first; if circular, use function-scope import.

    Run full test suite after all three fixes.
  </action>
  <verify>
    1. `python -m pytest tests/test_fill_helpers.py -x -v` -- all tests pass including updated test_nested_model_validated
    2. `python -m pytest tests/test_fill_protocol.py -x -v` -- all tests pass including new nested model test
    3. `python -m pytest -x -v` -- full suite passes (344+ tests, 0 failures)
    4. `python -m pytest tests/test_fill_helpers.py::TestValidatePlainFields::test_returns_validated_model_dump -v` -- still passes (function still returns dict, just with model instances as values)
  </verify>
  <done>
    All three fill() backends preserve nested Pydantic model instances. validate_plain_fields returns model instances not dicts. Full test suite green. Committed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify full suite + E2E (if available)</name>
  <files></files>
  <action>
    Final verification pass:

    1. Run full test suite: `python -m pytest -v` -- confirm 344+ pass, 0 fail
    2. If `--run-e2e` is available and API key is set, run: `python -m pytest --run-e2e tests/test_ootd_e2e.py::TestOotdCLI::test_anticipate_has_llm_filled_vibe -v`
       - If E2E isn't available (no API key), note this in the summary. The unit tests cover the code path completely.
    3. Check that no other tests regressed -- pay attention to test_returns_validated_model_dump which tests that the return value is still a dict (it should still pass since dict with model-instance values is still a dict).

    If any test fails, diagnose and fix. The refactor phase (if needed) happens here too -- if the code is clean, skip refactor. Don't refactor for the sake of it.

    No refactor commit needed unless there's obvious cleanup. The fix is already minimal.
  </action>
  <verify>
    `python -m pytest -v` -- 344+ tests pass, 0 failures, 0 regressions
    `python -m pytest --run-e2e tests/test_ootd_e2e.py -v` -- 5/5 E2E pass (if API available)
  </verify>
  <done>
    Full test suite green. E2E test_anticipate_has_llm_filled_vibe passes (if API available). 0 regressions. Phase 13 gap closed.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest -v` -- full suite passes (344+ tests)
2. `python -m pytest tests/test_fill_helpers.py::TestValidatePlainFields -v` -- all validate_plain_fields tests pass
3. `python -m pytest tests/test_fill_protocol.py -v` -- fill protocol tests pass including nested model preservation
4. `python -m pytest --run-e2e tests/test_ootd_e2e.py -v` -- all 5 E2E tests pass (if API key available)
5. `isinstance(result.vibe, VibeCheck)` is True in test_anticipate_has_llm_filled_vibe
</verification>

<success_criteria>
1. validate_plain_fields() preserves nested BaseModel instances (returns VibeCheck, not dict)
2. ClaudeCLIBackend.fill() produces nodes where nested fields are model instances
3. PydanticAIBackend.fill() produces nodes where nested fields are model instances
4. DSPyBackend.fill() validates raw output through PlainModel, producing model instances
5. Full test suite (344+) passes with 0 regressions
6. E2E test_anticipate_has_llm_filled_vibe passes (anticipate.vibe is VibeCheck)
</success_criteria>

<output>
After completion, create `.planning/phases/13-fix-nested-fill/13-01-SUMMARY.md`
</output>
