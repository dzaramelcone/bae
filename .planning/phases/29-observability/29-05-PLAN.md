---
phase: 29-observability
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/resolver.py
  - bae/graph.py
  - bae/repl/engine.py
  - tests/repl/test_engine.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Verbose mode shows per-node lifecycle events (resolve, fill/make, decide, transition)"
    - "Normal mode does not emit transition events"
    - "Event hook follows the established dep_cache sentinel pattern"
  artifacts:
    - path: "bae/resolver.py"
      provides: "EVENT_HOOK_KEY sentinel"
      contains: "EVENT_HOOK_KEY"
    - path: "bae/graph.py"
      provides: "Event emission at strategic points in arun() while-loop"
    - path: "bae/repl/engine.py"
      provides: "Event hook closure injected into dep_cache"
    - path: "tests/repl/test_engine.py"
      provides: "Tests for verbose event emission"
  key_links:
    - from: "bae/repl/engine.py"
      to: "bae/resolver.py"
      via: "EVENT_HOOK_KEY import and dep_cache injection"
      pattern: "EVENT_HOOK_KEY"
    - from: "bae/graph.py"
      to: "bae/resolver.py"
      via: "EVENT_HOOK_KEY import and hook invocation in arun()"
      pattern: "cache.get\\(EVENT_HOOK_KEY\\)"
---

<objective>
Add per-node transition event emission in verbose mode.

Purpose: UAT test 3 reported that --verbose shows no per-node events. OutputPolicy.VERBOSE.should_emit('transition') returns True, but arun() has no mechanism to emit events. The event hook pattern (like GATE_HOOK_KEY and DEP_TIMING_KEY) needs to be extended with EVENT_HOOK_KEY.
Output: Verbose mode emits events at node resolution, fill/make, decide, and transition points.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-observability/29-01-SUMMARY.md
@bae/graph.py
@bae/resolver.py
@bae/repl/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: EVENT_HOOK_KEY sentinel and arun() event emission</name>
  <files>bae/resolver.py, bae/graph.py, bae/repl/engine.py</files>
  <action>
Three files need changes:

**1. bae/resolver.py:** Add `EVENT_HOOK_KEY = object()` sentinel alongside the existing `LM_KEY`, `GATE_HOOK_KEY`, and `DEP_TIMING_KEY` sentinels. This is a one-line addition.

**2. bae/graph.py:** Import `EVENT_HOOK_KEY` from `bae.resolver`. In `arun()`, retrieve the hook from cache at the top of the while-loop setup:
```python
event_hook = cache.get(EVENT_HOOK_KEY)
```

Then emit events at these strategic points in the while-loop body:

a. **After resolve_fields completes (after line 347 "resolved = await resolve_fields(...)") :**
```python
if event_hook:
    event_hook("resolve", current.__class__.__name__, {"fields": len(resolved)})
```

b. **After strategy determination and before/after LM calls:**
- For `strategy[0] == "decide"` (after `choose_type` returns, around line 429):
```python
if event_hook:
    event_hook("decide", current.__class__.__name__, {"chosen": target_type.__name__})
```
- For `strategy[0] == "make"` or after `lm.fill` in the ellipsis branch (around line 438-439):
```python
if event_hook:
    event_hook("fill", target_type.__name__, {})
```
- For `lm.fill` calls in the custom branch (around line 404):
```python
if event_hook:
    event_hook("fill", current.__class__.__name__, {})
```

c. **At the top of each iteration (after the asyncio.sleep(0) yield, before resolve):**
```python
if event_hook:
    event_hook("transition", current.__class__.__name__, {"iter": iters})
```

Keep it minimal -- the hook signature is `(event_type: str, node_name: str, detail: dict)`. The engine closure will format and emit these through notify.

**3. bae/repl/engine.py:** Import `EVENT_HOOK_KEY` from `bae.resolver`. In both `_execute` and `_wrap_coro`, create an event hook closure and inject it into `dep_cache` (for `_execute`) or the contextvar dict (for `_wrap_coro`).

The event hook closure:
```python
def _event_hook(event_type, node_name, detail):
    _emit("transition", f"  {event_type}: {node_name}", {
        "type": "transition", "event": event_type,
        "node": node_name, "run_id": run.run_id, **detail,
    })
```

This uses the existing `_emit` helper which checks `policy.should_emit("transition")`. Since NORMAL policy returns False for "transition" and VERBOSE returns True, events only appear in verbose mode automatically.

In `_execute`, add `EVENT_HOOK_KEY: _event_hook` to the `dep_cache` dict alongside LM_KEY, GATE_HOOK_KEY, and DEP_TIMING_KEY.

In `_wrap_coro`, add `EVENT_HOOK_KEY: _event_hook` to the contextvar dict alongside GATE_HOOK_KEY and DEP_TIMING_KEY.
  </action>
  <verify>uv run pytest tests/ -x -q --ignore=tests/test_integration.py</verify>
  <done>EVENT_HOOK_KEY exists, arun() emits events at strategic points, engine injects hook closure, existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Tests for verbose event emission</name>
  <files>tests/repl/test_engine.py</files>
  <action>
Add tests to the existing engine test file:

1. **test_verbose_emits_transition_events:** Submit a graph with `policy=OutputPolicy.VERBOSE`. Capture all notify calls. After completion, verify that transition-type events were emitted (at least one event with metadata `type: "transition"`). Verify the events contain node names from the graph's trace.

2. **test_normal_suppresses_transition_events:** Submit a graph with `policy=OutputPolicy.NORMAL`. Capture all notify calls. After completion, verify that NO transition-type events were emitted (only start/complete).

Use the existing test graph types (e.g. StressStart -> Middle -> End from 29-03, or simpler existing fixtures). Follow the established pattern of submitting via registry and collecting notify calls.
  </action>
  <verify>uv run pytest tests/repl/test_engine.py -x -q</verify>
  <done>Tests prove verbose mode emits per-node events and normal mode suppresses them.</done>
</task>

</tasks>

<verification>
- uv run pytest tests/ -x -q --ignore=tests/test_integration.py
- Verbose mode test captures transition events with node names
- Normal mode test confirms no transition events
</verification>

<success_criteria>
- EVENT_HOOK_KEY follows the established sentinel pattern (like GATE_HOOK_KEY, DEP_TIMING_KEY)
- arun() emits events at resolve, fill/make, decide, and transition points
- Verbose mode shows per-node lifecycle events
- Normal/Quiet/Silent modes suppress transition events
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/29-observability/29-05-SUMMARY.md`
</output>
