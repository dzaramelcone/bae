---
phase: 04-production-runtime
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - bae/compiler.py
  - bae/__init__.py
  - tests/test_compiler.py
autonomous: true

must_haves:
  truths:
    - "CompiledGraph.run() uses OptimizedLM with loaded predictors"
    - "CompiledGraph.run() returns GraphResult (same as Graph.run())"
    - "OptimizedLM is exported from bae package root"
    - "create_optimized_lm factory function creates OptimizedLM from saved state"
  artifacts:
    - path: "bae/compiler.py"
      provides: "CompiledGraph.run() implementation, create_optimized_lm factory"
      exports: ["CompiledGraph", "create_optimized_lm"]
    - path: "bae/__init__.py"
      provides: "Package exports for OptimizedLM and create_optimized_lm"
      contains: "OptimizedLM"
  key_links:
    - from: "bae/compiler.py"
      to: "bae/optimized_lm.py"
      via: "import and use"
      pattern: "from bae.optimized_lm import OptimizedLM"
    - from: "bae/compiler.py"
      to: "bae/graph.py"
      via: "Graph.run() delegation"
      pattern: "self.graph.run.*lm="
---

<objective>
Wire OptimizedLM into CompiledGraph and export from package, completing the production runtime integration.

Purpose: Enable CompiledGraph to be the production entry point, using optimized predictors automatically. Completes Phase 4 requirements.
Output: Working CompiledGraph.run(), factory function, and package exports.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-production-runtime/04-RESEARCH.md

# Prior plan summary (for OptimizedLM API)
@.planning/phases/04-production-runtime/04-01-SUMMARY.md

# Existing code to modify
@bae/compiler.py
@bae/__init__.py
@bae/graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CompiledGraph.run() and create_optimized_lm factory</name>
  <files>bae/compiler.py</files>
  <action>
    Update bae/compiler.py to:

    1. Implement CompiledGraph.run() method:
       - Create OptimizedLM from self.optimized dict
       - Delegate to self.graph.run() with the OptimizedLM as lm parameter
       - Return GraphResult (same interface as Graph.run())
       - Remove the async keyword (bae is sync-only per PROJECT.md constraints)
       - Remove the NotImplementedError

    2. Add create_optimized_lm() factory function:
       - Takes graph: Graph and compiled_path: str | Path
       - Uses load_optimized() to load predictors for graph.nodes
       - Returns OptimizedLM instance with loaded predictors
       - Useful for users who want OptimizedLM without CompiledGraph

    Implementation for run():
    ```python
    def run(self, start_node: Node, **deps) -> "GraphResult":
        """Run the compiled graph using optimized predictors.

        Creates an OptimizedLM from loaded predictors and delegates
        to Graph.run(). Nodes with optimized predictors use them;
        others fall back to naive prompts.

        Args:
            start_node: The initial node to start execution.
            **deps: External dependencies to inject.

        Returns:
            GraphResult with final node and execution trace.
        """
        from bae.optimized_lm import OptimizedLM
        from bae.result import GraphResult

        lm = OptimizedLM(optimized=self.optimized)
        return self.graph.run(start_node, lm=lm, **deps)
    ```

    Implementation for factory:
    ```python
    def create_optimized_lm(
        graph: Graph,
        compiled_path: str | Path,
    ) -> "OptimizedLM":
        """Create an OptimizedLM with loaded predictors for a graph.

        Convenience factory that loads optimized predictors from disk
        and creates an OptimizedLM ready for production use.

        Args:
            graph: The graph whose nodes need predictors.
            compiled_path: Directory containing compiled predictor JSON files.

        Returns:
            OptimizedLM with loaded predictors for available nodes.
        """
        from bae.optimized_lm import OptimizedLM
        from bae.optimizer import load_optimized

        optimized = load_optimized(list(graph.nodes), Path(compiled_path))
        return OptimizedLM(optimized=optimized)
    ```

    Note: Use lazy imports for OptimizedLM to avoid circular import (same pattern as existing optimizer imports in CompiledGraph methods).
  </action>
  <verify>
    ```bash
    cd /Users/dzaramelcone/lab/bae && python -c "
    from bae.compiler import CompiledGraph, create_optimized_lm
    print('Imports successful')
    "
    ```
  </verify>
  <done>CompiledGraph.run() implemented, create_optimized_lm() exists, no import errors</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for CompiledGraph.run() integration</name>
  <files>tests/test_compiler.py</files>
  <action>
    Add tests to tests/test_compiler.py for:

    1. test_compiled_graph_run_uses_optimized_lm:
       - Create a simple graph with one node
       - Compile it with compile_graph()
       - Manually add an optimized predictor to compiled.optimized
       - Mock the predictor to track calls
       - Call compiled.run() and verify the optimized predictor was used

    2. test_compiled_graph_run_returns_graph_result:
       - Call compiled.run() and verify it returns GraphResult
       - Verify GraphResult has expected attributes (final, trace)

    3. test_create_optimized_lm_loads_predictors:
       - Create temp directory with saved predictor JSON
       - Call create_optimized_lm() with graph and path
       - Verify returned OptimizedLM has predictors in optimized dict

    Note: These tests may need mocking to avoid actual LLM calls. Follow patterns from existing test_compiler.py tests.
  </action>
  <verify>
    ```bash
    cd /Users/dzaramelcone/lab/bae && python -m pytest tests/test_compiler.py -v -k "compiled_graph_run or create_optimized_lm"
    ```
  </verify>
  <done>Tests for CompiledGraph.run() and create_optimized_lm() pass</done>
</task>

<task type="auto">
  <name>Task 3: Export OptimizedLM and create_optimized_lm from package</name>
  <files>bae/__init__.py</files>
  <action>
    Update bae/__init__.py to export:

    1. Add import for OptimizedLM:
       ```python
       from bae.optimized_lm import OptimizedLM
       ```

    2. Add import for create_optimized_lm:
       ```python
       from bae.compiler import create_optimized_lm
       ```
       (alongside existing compile_graph, node_to_signature imports)

    3. Add to __all__ list:
       - "OptimizedLM" in the "# LM backends" section
       - "create_optimized_lm" in the "# Compiler" section

    Final __all__ should include:
    ```python
    # LM backends
    "LM",
    "DSPyBackend",
    "OptimizedLM",  # NEW
    "PydanticAIBackend",
    "ClaudeCLIBackend",
    # Compiler
    "node_to_signature",
    "compile_graph",
    "create_optimized_lm",  # NEW
    ```
  </action>
  <verify>
    ```bash
    cd /Users/dzaramelcone/lab/bae && python -c "
    from bae import OptimizedLM, create_optimized_lm
    print(f'OptimizedLM: {OptimizedLM}')
    print(f'create_optimized_lm: {create_optimized_lm}')
    print('Exports successful')
    "
    ```
  </verify>
  <done>OptimizedLM and create_optimized_lm importable from bae package root</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -v --tb=short

# Verify imports from package
cd /Users/dzaramelcone/lab/bae && python -c "
from bae import (
    OptimizedLM,
    create_optimized_lm,
    compile_graph,
    Graph,
    Node,
)
print('All Phase 4 exports available')
"

# Quick integration check
cd /Users/dzaramelcone/lab/bae && python -c "
from bae import Graph, Node, compile_graph
from bae.markers import Context
from typing import Annotated

class TestNode(Node):
    msg: Annotated[str, Context()]
    def __call__(self, lm): ...

g = Graph(TestNode)
compiled = compile_graph(g)
print(f'CompiledGraph has run method: {hasattr(compiled, \"run\")}')
print(f'CompiledGraph.optimized: {compiled.optimized}')
"
```
</verification>

<success_criteria>
- [ ] CompiledGraph.run() returns GraphResult
- [ ] CompiledGraph.run() uses OptimizedLM internally
- [ ] create_optimized_lm() creates OptimizedLM from saved state
- [ ] OptimizedLM exported from bae package root
- [ ] create_optimized_lm exported from bae package root
- [ ] All existing tests pass (no regressions)
- [ ] New tests for integration pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-production-runtime/04-02-SUMMARY.md`
</output>
