---
phase: 02-dspy-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/markers.py
  - bae/result.py
  - bae/exceptions.py
  - bae/graph.py
  - tests/test_result.py
  - tests/test_bind_validation.py
autonomous: true

must_haves:
  truths:
    - "GraphResult holds final node and execution trace"
    - "Trace is flat list of nodes in execution order"
    - "Bae exceptions wrap original errors as __cause__"
    - "Bind marker exists for node field annotation"
    - "Graph validates type-unique Bind constraint"
  artifacts:
    - path: "bae/markers.py"
      provides: "Bind frozen dataclass marker"
      contains: "class Bind"
    - path: "bae/result.py"
      provides: "GraphResult dataclass"
      exports: ["GraphResult"]
    - path: "bae/exceptions.py"
      provides: "Exception hierarchy"
      exports: ["BaeError", "BaeParseError", "BaeLMError"]
    - path: "tests/test_result.py"
      provides: "GraphResult tests"
      min_lines: 30
    - path: "tests/test_bind_validation.py"
      provides: "Bind validation tests"
      min_lines: 40
  key_links:
    - from: "bae/graph.py"
      to: "bae/markers.py"
      via: "import Bind for validation"
      pattern: "from bae.markers import.*Bind"
    - from: "bae/result.py"
      to: "bae/node.py"
      via: "Node type hint"
      pattern: "from bae.node import Node"
---

<objective>
Create foundation types for Phase 2: GraphResult for execution results, Bind marker for downstream injection, and Bae exception hierarchy. Add Graph validation for type-unique Bind constraint.

Purpose: These types are the foundation for dep injection and execution tracing. GraphResult replaces the current `Node | None` return from Graph.run(). Bind enables nodes to expose values for downstream Dep injection.

Output: New bae/result.py, bae/exceptions.py, extended bae/markers.py, updated bae/graph.py validation
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-dspy-integration/02-CONTEXT.md
@.planning/phases/02-dspy-integration/02-RESEARCH.md

@bae/markers.py
@bae/graph.py
@bae/node.py
@tests/test_graph.py
</context>

<feature>
  <name>Feature 1: GraphResult and Exception Hierarchy</name>
  <files>bae/result.py, bae/exceptions.py, tests/test_result.py</files>
  <behavior>
    GraphResult is a dataclass with:
    - node: Node | None (final node or None if terminated)
    - trace: list[Node] (flat list of nodes in execution order)

    Exception hierarchy:
    - BaeError (base) with original error as __cause__
    - BaeParseError for validation/parse failures
    - BaeLMError for API failures (timeout, rate limit, network)

    Cases:
    - GraphResult(node=SomeNode(), trace=[n1, n2, n3]) -> valid
    - GraphResult(node=None, trace=[n1]) -> valid (terminated)
    - BaeParseError("msg", cause=ValueError("x")) -> e.__cause__ is ValueError
    - BaeLMError("timeout", cause=TimeoutError()) -> e.__cause__ is TimeoutError
  </behavior>
  <implementation>
    Create bae/result.py with GraphResult dataclass.
    Create bae/exceptions.py with BaeError base class that accepts optional cause in __init__ and chains it.
    BaeParseError and BaeLMError inherit from BaeError.
  </implementation>
</feature>

<feature>
  <name>Feature 2: Bind Marker and Type-Unique Validation</name>
  <files>bae/markers.py, bae/graph.py, tests/test_bind_validation.py</files>
  <behavior>
    Bind is a frozen dataclass marker (like Context/Dep) for node fields that should be available to downstream nodes via type matching.

    Graph.validate() checks type-unique constraint:
    - If two nodes in graph have Bind fields of same type -> validation error
    - Single Bind per type across entire graph is valid

    Cases:
    - class A(Node): x: Annotated[str, Bind()] -> valid, binds str
    - class A(Node): x: Annotated[Conn, Bind()], class B(Node): y: Annotated[Conn, Bind()] in same graph -> error
    - class A(Node): x: Annotated[Conn, Bind()], class B(Node): y: Annotated[Cache, Bind()] -> valid (different types)
  </behavior>
  <implementation>
    Add Bind frozen dataclass to markers.py (no description field needed, just empty marker).
    In graph.py validate(), scan all node classes for Bind-annotated fields, collect their types, error if duplicates.
  </implementation>
</feature>

<verification>
All tests pass:
```bash
pytest tests/test_result.py tests/test_bind_validation.py -v
```

Existing tests still pass:
```bash
pytest tests/ -v
```
</verification>

<success_criteria>
- GraphResult dataclass exists with node and trace attributes
- Exception hierarchy chains __cause__ correctly
- Bind marker exists in markers.py
- Graph.validate() returns error for duplicate Bind types
- All tests pass (new and existing)
</success_criteria>

<output>
After completion, create `.planning/phases/02-dspy-integration/02-01-SUMMARY.md`
</output>
