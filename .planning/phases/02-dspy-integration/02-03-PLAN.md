---
phase: 02-dspy-integration
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/dspy_backend.py
  - tests/test_dspy_backend.py
autonomous: true

must_haves:
  truths:
    - "DSPyBackend uses dspy.Predict with generated Signatures"
    - "Parse failures trigger self-correction retry with error hint"
    - "Default 1 retry (2 total attempts) on parse failure"
    - "API failures (timeout, network) retry once then raise BaeLMError"
    - "Pydantic models parse correctly from dspy.Predict output"
  artifacts:
    - path: "bae/dspy_backend.py"
      provides: "DSPyBackend class"
      exports: ["DSPyBackend"]
      min_lines: 100
    - path: "tests/test_dspy_backend.py"
      provides: "DSPyBackend tests"
      min_lines: 100
  key_links:
    - from: "bae/dspy_backend.py"
      to: "bae/compiler.py"
      via: "node_to_signature import"
      pattern: "from bae.compiler import node_to_signature"
    - from: "bae/dspy_backend.py"
      to: "bae/exceptions.py"
      via: "exception imports"
      pattern: "from bae.exceptions import"
---

<objective>
Create DSPyBackend that uses dspy.Predict with generated Signatures. Implements self-correction on parse failures (pass validation error as hint, retry once) and API failure handling (retry once, then raise BaeLMError).

Purpose: This replaces naive prompts with DSPy's structured prediction. The self-correction loop improves reliability without needing optimization.

Output: New bae/dspy_backend.py with DSPyBackend class implementing LM protocol
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-dspy-integration/02-CONTEXT.md
@.planning/phases/02-dspy-integration/02-RESEARCH.md

@bae/compiler.py
@bae/lm.py
@bae/node.py
@tests/test_compiler.py
</context>

<feature>
  <name>Feature 1: DSPyBackend.make() with dspy.Predict</name>
  <files>bae/dspy_backend.py, tests/test_dspy_backend.py</files>
  <behavior>
    DSPyBackend.make(node, target) uses dspy.Predict to produce target type:

    1. Get signature via node_to_signature(target)
    2. Create dspy.Predict(signature)
    3. Build input dict from node fields (Context-annotated) and any Dep values
    4. Call predict(**inputs)
    5. Parse output into target Pydantic model
    6. On parse failure, retry with error hint in signature

    Cases:
    - Valid output -> parse succeeds -> return target instance
    - Invalid output -> AdapterParseError -> retry with hint -> success -> return
    - Invalid output -> retry fails -> raise BaeParseError
  </behavior>
  <implementation>
    DSPyBackend class with make() method.
    Use dspy.Predict(signature).
    Catch litellm.exceptions or pydantic ValidationError on parse.
    On failure, append hint to signature via signature.append("parse_error", InputField(desc=error_msg)).
    Retry with extended signature.
    If retry fails, raise BaeParseError with original error as __cause__.
  </implementation>
</feature>

<feature>
  <name>Feature 2: DSPyBackend.decide() with Two-Step Pattern</name>
  <files>bae/dspy_backend.py, tests/test_dspy_backend.py</files>
  <behavior>
    DSPyBackend.decide(node) handles union return types with two-step:

    1. Create "choice" signature: input is node state, output is choice enum
    2. LLM picks which type to produce
    3. If None chosen -> return None
    4. Otherwise call make(node, chosen_type)

    The two-step pattern is transparent to callers but logged in trace:
    - trace shows "decided: ChosenType" before the filled node

    Cases:
    - Union A | B | None -> step 1 picks B -> step 2 fills B -> return B instance
    - Union A | B | None -> step 1 picks None -> return None
    - Single type A -> bypass choice, just make(A)
  </behavior>
  <implementation>
    In decide(), inspect node's return type hint.
    If union: build choice signature with enum of type names, predict choice, then make.
    If single type: just call make.
    If only None: return None.
  </implementation>
</feature>

<feature>
  <name>Feature 3: API Failure Handling</name>
  <files>bae/dspy_backend.py, tests/test_dspy_backend.py</files>
  <behavior>
    API failures (timeout, rate limit, network errors) handled with single retry:

    1. Catch API exceptions from dspy/litellm
    2. Wait briefly (1 second)
    3. Retry once
    4. If retry fails, raise BaeLMError with original as __cause__

    Cases:
    - Timeout on first try -> retry -> success -> return
    - Timeout on first try -> retry -> timeout again -> BaeLMError
    - Rate limit -> retry -> success -> return
  </behavior>
  <implementation>
    Wrap dspy.Predict calls in try/except.
    Catch litellm exceptions (APIError, Timeout, RateLimitError).
    On catch: time.sleep(1), retry.
    On second failure: raise BaeLMError(str(e), cause=e).
  </implementation>
</feature>

<verification>
All tests pass:
```bash
pytest tests/test_dspy_backend.py -v
```

Existing tests still pass:
```bash
pytest tests/ -v
```
</verification>

<success_criteria>
- DSPyBackend.make() uses dspy.Predict with node_to_signature
- Parse failures trigger self-correction with error hint
- API failures retry once then raise BaeLMError
- DSPyBackend.decide() uses two-step for unions
- All tests pass (new and existing)
</success_criteria>

<output>
After completion, create `.planning/phases/02-dspy-integration/02-03-SUMMARY.md`
</output>
