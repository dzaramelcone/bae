---
phase: 02-dspy-integration
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - bae/graph.py
  - bae/node.py
  - tests/test_auto_routing.py
autonomous: true

must_haves:
  truths:
    - "Graph.run() introspects return type to choose routing strategy"
    - "Union return type triggers decide (pick type, then fill)"
    - "Single return type triggers make directly"
    - "`__call__` body `...` signals automatic routing"
    - "Custom `__call__` logic still works as escape hatch"
  artifacts:
    - path: "bae/graph.py"
      provides: "Auto-routing in run()"
      contains: "_get_routing_strategy"
    - path: "bae/node.py"
      provides: "Body detection helper"
      contains: "_has_ellipsis_body"
    - path: "tests/test_auto_routing.py"
      provides: "Auto-routing tests"
      min_lines: 80
  key_links:
    - from: "bae/graph.py"
      to: "bae/node.py"
      via: "body detection"
      pattern: "_has_ellipsis_body"
    - from: "bae/graph.py"
      to: "bae/result.py"
      via: "GraphResult return"
      pattern: "GraphResult"
---

<objective>
Implement auto-routing in Graph.run() based on return type introspection. Union return types trigger decide (two-step: pick type, then fill), single types trigger make. The `...` body signals automatic routing; custom `__call__` logic is an escape hatch.

Purpose: This removes boilerplate from node definitions. Users define `def __call__(self, lm) -> A | B | None: ...` and Graph handles routing automatically.

Output: Updated bae/graph.py with auto-routing, bae/node.py with body detection helper
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-dspy-integration/02-CONTEXT.md
@.planning/phases/02-dspy-integration/02-RESEARCH.md

# Need GraphResult from 02-01
@.planning/phases/02-dspy-integration/02-01-SUMMARY.md

@bae/graph.py
@bae/node.py
@bae/lm.py
@tests/test_graph.py
</context>

<feature>
  <name>Feature 1: Ellipsis Body Detection</name>
  <files>bae/node.py, tests/test_auto_routing.py</files>
  <behavior>
    Detect if a `__call__` method has body consisting only of `...` (Ellipsis).

    This signals "use automatic routing" vs custom logic.

    Cases:
    - def __call__(self, lm) -> A | B: ... -> True (ellipsis body)
    - def __call__(self, lm) -> A | B: return lm.decide(self) -> False (has logic)
    - def __call__(self, lm) -> A: return lm.make(self, A) -> False (has logic)
    - Base Node.__call__ -> False (has logic)

    Implementation uses AST inspection of the method body.
  </behavior>
  <implementation>
    Add _has_ellipsis_body(method) to node.py that uses ast module to check if method body is single Expr(value=Constant(...)).
  </implementation>
</feature>

<feature>
  <name>Feature 2: Auto-Routing in Graph.run()</name>
  <files>bae/graph.py, tests/test_auto_routing.py</files>
  <behavior>
    Graph.run() determines routing strategy per node:

    1. If node's __call__ has ellipsis body -> automatic routing
    2. Automatic routing logic:
       - Union return type (A | B or A | B | None) -> lm.decide(node)
       - Single type return (A or A | None) -> lm.make(node, A)
       - Pure None return -> return None (terminal)
    3. If node's __call__ has custom logic -> call it directly (escape hatch)

    Cases:
    - class X(Node): def __call__(self, lm) -> A | B: ... -> auto decide
    - class X(Node): def __call__(self, lm) -> A: ... -> auto make(A)
    - class X(Node): def __call__(self, lm) -> A | None: ... -> auto make(A) or None
    - class X(Node): def __call__(self, lm) -> None: ... -> auto return None
    - class X(Node): def __call__(self, lm) -> A | B: return lm.decide(self) -> custom (called directly)
  </behavior>
  <implementation>
    In Graph.run(), before calling node(lm=lm):
    1. Check if node class __call__ has ellipsis body
    2. If yes, inspect return type and call lm.decide or lm.make accordingly
    3. If no, call node(lm=lm) directly (existing behavior)

    Add _get_routing_strategy(node_cls) helper that returns ("decide", types) or ("make", type) or ("terminal",) or ("custom",).
  </implementation>
</feature>

<verification>
All tests pass:
```bash
pytest tests/test_auto_routing.py -v
```

Existing tests still pass:
```bash
pytest tests/ -v
```
</verification>

<success_criteria>
- _has_ellipsis_body correctly detects `...` vs custom logic
- _get_routing_strategy returns correct strategy for each case
- Graph.run() uses auto-routing for ellipsis bodies
- Custom `__call__` logic still works (escape hatch)
- GraphResult returned from Graph.run() with node and trace
- All tests pass (new and existing)
</success_criteria>

<output>
After completion, create `.planning/phases/02-dspy-integration/02-02-SUMMARY.md`
</output>
