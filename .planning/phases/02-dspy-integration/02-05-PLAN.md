---
phase: 02-dspy-integration
plan: 05
type: execute
wave: 4
depends_on: ["02-03", "02-04"]
files_modified:
  - bae/graph.py
  - bae/__init__.py
  - tests/test_integration_dspy.py
autonomous: true

must_haves:
  truths:
    - "DSPyBackend is wired into Graph.run() as the default"
    - "End-to-end graph execution works with DSPy Predict"
    - "Trace shows execution path including decide steps"
    - "All Phase 2 success criteria are met"
  artifacts:
    - path: "bae/graph.py"
      provides: "DSPyBackend integration"
      contains: "DSPyBackend"
    - path: "bae/__init__.py"
      provides: "Public exports"
      exports: ["Graph", "Node", "Context", "Dep", "Bind", "GraphResult", "DSPyBackend"]
    - path: "tests/test_integration_dspy.py"
      provides: "Integration tests"
      min_lines: 50
  key_links:
    - from: "bae/graph.py"
      to: "bae/dspy_backend.py"
      via: "DSPyBackend import"
      pattern: "from bae.dspy_backend import DSPyBackend"
    - from: "bae/graph.py"
      to: "bae/result.py"
      via: "GraphResult return"
      pattern: "return GraphResult"
---

<objective>
Wire DSPyBackend into Graph.run() and verify end-to-end functionality. Export all new types from bae/__init__.py. Create integration test demonstrating complete flow.

Purpose: This ties together all Phase 2 work into a working system. Users can now define nodes with `...` body and get automatic DSPy-powered routing.

Output: Integrated Graph.run() with DSPyBackend, updated exports, integration tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-dspy-integration/02-CONTEXT.md
@.planning/phases/02-dspy-integration/02-RESEARCH.md

# All prior plans
@.planning/phases/02-dspy-integration/02-01-SUMMARY.md
@.planning/phases/02-dspy-integration/02-02-SUMMARY.md
@.planning/phases/02-dspy-integration/02-03-SUMMARY.md
@.planning/phases/02-dspy-integration/02-04-SUMMARY.md

@bae/graph.py
@bae/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DSPyBackend as Default in Graph.run()</name>
  <files>bae/graph.py</files>
  <action>
    Update Graph.run() signature to make lm optional with DSPyBackend as default:

    ```python
    def run(
        self,
        start_node: Node,
        lm: LM | None = None,
        max_steps: int = 100,
        **deps,
    ) -> GraphResult:
    ```

    If lm is None, create DSPyBackend() instance.

    Ensure the return type is GraphResult (not Node | None).

    Keep existing LM backends (PydanticAIBackend, ClaudeCLIBackend) working when explicitly passed.
  </action>
  <verify>
    ```bash
    pytest tests/test_graph.py -v
    ```
    Existing graph tests should still pass (they pass explicit lm).
  </verify>
  <done>
    Graph.run() accepts optional lm, defaults to DSPyBackend, returns GraphResult.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Public Exports</name>
  <files>bae/__init__.py</files>
  <action>
    Update bae/__init__.py to export all Phase 2 types:

    - From bae.node: Node
    - From bae.graph: Graph
    - From bae.markers: Context, Dep, Bind
    - From bae.result: GraphResult
    - From bae.exceptions: BaeError, BaeParseError, BaeLMError
    - From bae.dspy_backend: DSPyBackend
    - From bae.lm: LM, PydanticAIBackend, ClaudeCLIBackend (existing)
    - From bae.compiler: node_to_signature, compile_graph (existing)

    Use explicit imports (not star imports) for clarity.
  </action>
  <verify>
    ```python
    from bae import Graph, Node, Context, Dep, Bind, GraphResult, DSPyBackend, BaeError
    # Should not raise ImportError
    ```
  </verify>
  <done>
    All Phase 2 types importable from bae package root.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Integration Test</name>
  <files>tests/test_integration_dspy.py</files>
  <action>
    Create integration test demonstrating Phase 2 capabilities:

    1. Define a simple graph with auto-routing nodes (`...` body)
    2. Define nodes with Bind/Dep for value flow
    3. Run graph with DSPyBackend (mocked for unit test)
    4. Verify GraphResult contains correct trace
    5. Verify Bind-to-Dep injection worked

    Use a mock for dspy.Predict to avoid real LLM calls in tests.

    Test cases:
    - Auto-routing with union return type (decide path)
    - Auto-routing with single return type (make path)
    - Custom __call__ logic (escape hatch)
    - Bind/Dep value flow between nodes
    - External deps from run() kwargs
  </action>
  <verify>
    ```bash
    pytest tests/test_integration_dspy.py -v
    ```
  </verify>
  <done>
    Integration test passes, demonstrating all Phase 2 features working together.
  </done>
</task>

</tasks>

<verification>
All tests pass:
```bash
pytest tests/ -v
```

Phase 2 success criteria verified:
1. Graph.run() introspects return type: union -> decide, single -> make
2. `__call__` with `...` body uses automatic routing
3. Custom `__call__` logic still works as escape hatch
4. Dep-annotated params are injected via incant
5. dspy.Predict replaces naive prompts for LM calls
6. Pydantic models parse correctly from dspy.Predict output
7. Union return types work with two-step pattern
</verification>

<success_criteria>
- DSPyBackend is default in Graph.run()
- All Phase 2 types exported from bae package
- Integration test demonstrates complete flow
- All existing tests still pass
- Phase 2 success criteria met
</success_criteria>

<output>
After completion, create `.planning/phases/02-dspy-integration/02-05-SUMMARY.md`
</output>
