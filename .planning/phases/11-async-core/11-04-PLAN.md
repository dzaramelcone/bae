---
phase: 11-async-core
plan: 04
type: execute
wave: 3
depends_on: ["11-03"]
files_modified:
  - tests/test_dep_injection.py
  - tests/test_integration.py
  - tests/test_integration_dspy.py
  - tests/test_ootd_e2e.py
autonomous: true

must_haves:
  truths:
    - "Dep injection tests with async graph.run() pass"
    - "Integration tests with PydanticAI/ClaudeCLI backends pass"
    - "Integration tests with DSPy backend pass"
    - "OOTD end-to-end test passes"
    - "Full test suite (323 tests) passes with zero failures"
    - "No test files were deleted or tests removed"
  artifacts:
    - path: "tests/test_dep_injection.py"
      provides: "Async dep injection tests with graph.run()"
      contains: "async def test_"
    - path: "tests/test_integration.py"
      provides: "Async integration tests for PydanticAI/ClaudeCLI backends"
      contains: "async def test_"
    - path: "tests/test_integration_dspy.py"
      provides: "Async integration tests for DSPy backend"
      contains: "async def test_"
    - path: "tests/test_ootd_e2e.py"
      provides: "Async OOTD end-to-end test"
      contains: "async def test_|asyncio.run"
  key_links:
    - from: "tests/test_integration.py"
      to: "bae/graph.py"
      via: "await graph.run() with real backend mocks"
      pattern: "await.*graph\\.run\\("
    - from: "tests/test_ootd_e2e.py"
      to: "bae/graph.py"
      via: "await graph.run() end-to-end"
      pattern: "await.*graph\\.run\\("
---

<objective>
Migrate remaining integration and E2E tests to async and verify the full test suite passes.

Purpose: This is the final plan for Phase 11. With all production code async (Plans 01-03), the remaining integration tests need async conversion. The full test suite must pass at the end — this is the acceptance gate for the entire async core conversion.

Output: All integration/E2E tests passing, full suite green (323 tests, 0 failures).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tests/test_dep_injection.py
@tests/test_integration.py
@tests/test_integration_dspy.py
@tests/test_ootd_e2e.py
@.planning/phases/11-async-core/11-01-SUMMARY.md
@.planning/phases/11-async-core/11-02-SUMMARY.md
@.planning/phases/11-async-core/11-03-SUMMARY.md

These are the last test files that call async methods (graph.run, backend methods) and haven't been converted yet.

test_dep_injection.py has ~8 calls to graph.run(). Even though resolve_dep/resolve_fields stay sync in Phase 11, the tests invoke them indirectly through async graph.run(), so the test functions calling graph.run() must be async with await.

Test files that should NOT need changes (verify they still pass):
- test_compiler.py — tests node_to_signature (sync)
- test_signature_v2.py — tests signature building (sync)
- test_fill_helpers.py — tests _build_plain_model, validate_plain_fields (sync)
- test_resolver.py — tests resolve_fields/resolve_dep directly (sync in Phase 11, not via graph.run)
- test_result.py, test_result_v2.py — tests GraphResult (dataclass, sync)
- test_exceptions.py — tests exception classes (sync)
- test_node_config.py — tests NodeConfig, _wants_lm (sync introspection, no graph.run calls)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate dep injection, integration, and E2E tests to async</name>
  <files>tests/test_dep_injection.py, tests/test_integration.py, tests/test_integration_dspy.py, tests/test_ootd_e2e.py</files>
  <action>
  1. In test_dep_injection.py (~390 lines):
     - Update MockV2LM or similar mock LM classes: make LM protocol methods async.
     - Convert `def test_*` functions that call `graph.run()` to `async def test_*` with `await graph.run()`.
     - Tests that only test resolve_dep/resolve_fields directly (not via graph.run) stay sync.

  3. In test_integration.py (~215 lines):
     - Update any MockLM / mock backend classes: make LM protocol methods async.
     - Convert `def test_*` functions that call `graph.run()` to `async def test_*` with `await graph.run()`.
     - Convert tests that call backend methods directly to async with await.
     - Tests that only test topology (graph construction, validation) stay sync.

  4. In test_integration_dspy.py (~387 lines):
     - Same pattern. This file likely has heavier mocking of dspy.Predict.
     - Mock predictors need AsyncMock for `acall` method.
     - Tests calling `graph.run()`, `backend.make()`, `backend.fill()` etc. become async with await.
     - If there are tests using `dspy.settings.configure()`, those stay sync (configuration, not I/O).

  5. In test_ootd_e2e.py (~83 lines):
     - This is an E2E test that runs the OOTD example graph.
     - It's marked with `@pytest.mark.e2e` and requires `--run-e2e` flag.
     - Convert `def test_*` to `async def test_*`, add `await` before `graph.run()`.
     - If it uses a real backend, ensure the async backend works in the test context.
     - If it mocks backends, update mocks to async.

  6. With `asyncio_mode = "auto"`, no `@pytest.mark.asyncio` decorators needed.
  </action>
  <verify>
  Run dep injection and integration tests (excluding E2E which needs --run-e2e):
  `uv run python -m pytest tests/test_dep_injection.py tests/test_integration.py tests/test_integration_dspy.py -v --tb=short`
  All pass.
  </verify>
  <done>
  test_dep_injection.py, test_integration.py, test_integration_dspy.py, and test_ootd_e2e.py use async test functions. Mock backends have async methods. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Full test suite verification</name>
  <files>tests/</files>
  <action>
  Run the FULL test suite and verify every test passes:

  1. `uv run python -m pytest tests/ -v --tb=long`
  2. Verify test count is still 323 (no tests deleted or lost).
  3. If any tests fail:
     - Diagnose root cause (likely missed await, sync mock, or import issue).
     - Fix the issue.
     - Re-run full suite.
  4. Verify no warnings about "coroutine was never awaited" — this indicates a missed await.
  5. Check that sync test files (test_compiler.py, test_resolver.py, test_fill_helpers.py, etc.) are unchanged and pass.
  </action>
  <verify>
  `uv run python -m pytest tests/ -v --tb=long 2>&1 | tail -20`
  Output shows "323 passed" (or close — some may be skipped for E2E).
  No "coroutine was never awaited" warnings.
  </verify>
  <done>
  Full test suite passes. Test count is preserved (323 collected, E2E skipped without --run-e2e). No async warnings. Phase 11 complete.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -m pytest tests/ -v` — full suite passes
2. `uv run python -m pytest tests/ --collect-only -q 2>&1 | tail -1` — still shows "323 tests collected"
3. `uv run python -m pytest tests/ -v 2>&1 | grep -c "PASSED"` — count matches expected
4. `uv run python -m pytest tests/ -v 2>&1 | grep -i "warning.*coroutine"` — no coroutine warnings
5. `uv run python -c "import bae; import inspect; assert inspect.iscoroutinefunction(bae.Graph.run)"` — final sanity check
</verification>

<success_criteria>
- test_dep_injection.py passes with async graph.run()
- test_integration.py passes with async graph.run()
- test_integration_dspy.py passes with async DSPy backend
- test_ootd_e2e.py passes (when run with --run-e2e)
- Full test suite: 323 tests collected, all pass (minus E2E skips)
- No "coroutine was never awaited" warnings
- No tests deleted
- Phase 11 async core conversion complete
</success_criteria>

<output>
After completion, create `.planning/phases/11-async-core/11-04-SUMMARY.md`
</output>
