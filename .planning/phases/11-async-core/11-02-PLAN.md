---
phase: 11-async-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/dspy_backend.py
  - bae/optimized_lm.py
  - tests/test_dspy_backend.py
  - tests/test_optimized_lm.py
autonomous: true

must_haves:
  truths:
    - "DSPyBackend uses await predictor.acall() instead of predictor()"
    - "DSPyBackend._call_with_retry uses await predictor.acall()"
    - "OptimizedLM.make is async and calls super().make() with await"
    - "All tests in test_dspy_backend.py and test_optimized_lm.py pass"
  artifacts:
    - path: "bae/dspy_backend.py"
      provides: "Async DSPyBackend with native dspy async"
      contains: "async def fill"
    - path: "bae/optimized_lm.py"
      provides: "Async OptimizedLM extending async DSPyBackend"
      contains: "async def make"
    - path: "tests/test_dspy_backend.py"
      provides: "Tests for async DSPyBackend"
      contains: "async def test_"
    - path: "tests/test_optimized_lm.py"
      provides: "Tests for async OptimizedLM"
      contains: "async def test_"
  key_links:
    - from: "bae/dspy_backend.py"
      to: "dspy.Predict"
      via: "await predictor.acall() replaces predictor()"
      pattern: "await.*\\.acall\\("
    - from: "bae/optimized_lm.py"
      to: "bae/dspy_backend.py"
      via: "OptimizedLM inherits async methods from DSPyBackend"
      pattern: "class OptimizedLM\\(DSPyBackend\\)"
---

<objective>
Convert DSPyBackend and OptimizedLM from sync to async using DSPy's native async API.

Purpose: DSPy has native async support via `Predict.acall()`. Converting DSPyBackend to use it means all three LM backends are async, completing the backend layer of the async conversion.

Output: Async DSPyBackend, async OptimizedLM, passing tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@bae/dspy_backend.py
@bae/optimized_lm.py
@tests/test_dspy_backend.py
@tests/test_optimized_lm.py

Requirements: ASYNC-05 (DSPyBackend native async), ASYNC-06 (OptimizedLM async).

DSPy's `Predict` class has `.acall(**kwargs)` which is the async equivalent of `predictor(**kwargs)`. The `acall` method is confirmed available (verified: `hasattr(dspy.Predict('q->a'), 'acall')` returns True).

DSPyBackend has these methods to convert:
- `_call_with_retry(predictor, inputs, error_hint)` — calls `predictor(**inputs)`, change to `await predictor.acall(**inputs)`
- `make(node, target, **deps)` — calls `_call_with_retry`, change to async + await
- `decide(node)` — calls `_predict_choice` and `make`, change to async + await
- `_predict_choice(node, choices, is_terminal)` — calls `predictor(context=...)`, change to `await predictor.acall(context=...)`
- `choose_type(types, context)` — calls `predictor(context=...)`, change to `await predictor.acall(context=...)`
- `fill(target, resolved, instruction, source)` — calls `_call_with_retry`, change to async + await

OptimizedLM extends DSPyBackend, overrides only `make()`. Make it async, use `await self._call_with_retry(...)`.

The `time.sleep(1)` in _call_with_retry should become `await asyncio.sleep(1)`.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert dspy_backend.py and optimized_lm.py to async</name>
  <files>bae/dspy_backend.py, bae/optimized_lm.py</files>
  <action>
  1. In dspy_backend.py:
     - Add `import asyncio` at top.
     - `async def _call_with_retry(self, predictor, inputs, error_hint=None)`:
       - Change `predictor(**inputs)` to `await predictor.acall(**inputs)`
       - Change `time.sleep(1)` to `await asyncio.sleep(1)`
     - `async def make(self, node, target, **deps)`:
       - Change `self._call_with_retry(...)` to `await self._call_with_retry(...)`
     - `async def _predict_choice(self, node, choices, is_terminal)`:
       - Change `predictor(context=context)` to `await predictor.acall(context=context)`
     - `async def decide(self, node)`:
       - Change `self._predict_choice(...)` to `await self._predict_choice(...)`
       - Change `self.make(...)` to `await self.make(...)`
     - `async def choose_type(self, types, context)`:
       - Change `predictor(context=context_str)` to `await predictor.acall(context=context_str)`
     - `async def fill(self, target, resolved, instruction, source=None)`:
       - Change `self._call_with_retry(...)` to `await self._call_with_retry(...)`
     - Remove `import time` if no longer used (it won't be after asyncio.sleep).

  2. In optimized_lm.py:
     - Add `import asyncio` if needed (likely not — no direct asyncio usage, just inherits).
     - `async def make(self, node, target, **deps)`:
       - Change `self._call_with_retry(...)` to `await self._call_with_retry(...)`
     - `_get_predictor_for_target` stays sync (pure dict lookup, no I/O).
     - `get_stats` stays sync (pure dict copy).
  </action>
  <verify>
  `uv run python -c "import inspect; from bae.dspy_backend import DSPyBackend; assert all(inspect.iscoroutinefunction(getattr(DSPyBackend, m)) for m in ('make', 'decide', 'choose_type', 'fill', '_call_with_retry'))"`
  `uv run python -c "import inspect; from bae.optimized_lm import OptimizedLM; assert inspect.iscoroutinefunction(OptimizedLM.make)"`
  </verify>
  <done>
  DSPyBackend uses await predictor.acall(). time.sleep replaced with asyncio.sleep. OptimizedLM.make is async. Both files import cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate test_dspy_backend.py and test_optimized_lm.py to async</name>
  <files>tests/test_dspy_backend.py, tests/test_optimized_lm.py</files>
  <action>
  Mechanical conversion — same pattern as Plan 01 Task 2.

  1. In test_dspy_backend.py (~435 lines):
     - Mock DSPy predictors: The tests likely mock `dspy.Predict` or patch it. Since `acall` is the new call method, update mocks to mock `acall` instead of `__call__`. If using `unittest.mock.patch`, the patched method is now `acall` not `__call__`.
     - IMPORTANT: Check if tests mock `predictor(...)` calls — these become `predictor.acall(...)` calls. The mock setup must use `AsyncMock` for the `acall` method so `await mock.acall(...)` works.
     - Convert all `def test_*` that call backend methods to `async def test_*` with `await`.
     - Tests that only test `_build_inputs`, `_parse_output`, `_get_return_types` stay sync (these are pure computation).

  2. In test_optimized_lm.py (~321 lines):
     - Same pattern. Mock predictors need AsyncMock for acall.
     - Convert `def test_*` that call `make`, `fill`, `decide`, etc. to `async def test_*` with `await`.
     - Tests that only check `_get_predictor_for_target` or `get_stats` stay sync.

  3. Both test files: with `asyncio_mode = "auto"`, no `@pytest.mark.asyncio` decorator needed.
  </action>
  <verify>
  `uv run python -m pytest tests/test_dspy_backend.py tests/test_optimized_lm.py -v --tb=short`
  All tests pass.
  </verify>
  <done>
  test_dspy_backend.py and test_optimized_lm.py use async test functions. Mock predictors use AsyncMock for acall. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "import bae.dspy_backend; import bae.optimized_lm"` — imports without error
2. `uv run python -c "import inspect; from bae.dspy_backend import DSPyBackend; print([m for m in ('make', 'decide', 'choose_type', 'fill') if inspect.iscoroutinefunction(getattr(DSPyBackend, m))])"` — all 4 listed
3. `uv run python -m pytest tests/test_dspy_backend.py tests/test_optimized_lm.py -v` — all tests pass
</verification>

<success_criteria>
- DSPyBackend._call_with_retry uses await predictor.acall()
- DSPyBackend.make/decide/choose_type/fill are async def
- time.sleep replaced with asyncio.sleep in retry logic
- OptimizedLM.make is async def
- test_dspy_backend.py and test_optimized_lm.py pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-async-core/11-02-SUMMARY.md`
</output>
