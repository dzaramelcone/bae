---
phase: 11-async-core
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - bae/node.py
  - bae/graph.py
  - bae/compiler.py
  - bae/cli.py
  - tests/test_node.py
  - tests/test_graph.py
  - tests/test_auto_routing.py
autonomous: true

must_haves:
  truths:
    - "Node.__call__() is async def"
    - "Graph.run() is async def and awaits all LM calls"
    - "CompiledGraph.run() is async def"
    - "CLI run_graph command uses asyncio.run() at the boundary"
    - "All tests in test_node.py, test_graph.py, test_auto_routing.py pass"
  artifacts:
    - path: "bae/node.py"
      provides: "Node with async __call__"
      contains: "async def __call__"
    - path: "bae/graph.py"
      provides: "Graph with async run()"
      contains: "async def run"
    - path: "bae/compiler.py"
      provides: "CompiledGraph with async run()"
      contains: "async def run"
    - path: "bae/cli.py"
      provides: "CLI with asyncio.run() boundary"
      contains: "asyncio.run"
    - path: "tests/test_graph.py"
      provides: "Tests for async Graph.run()"
      contains: "async def test_"
  key_links:
    - from: "bae/graph.py"
      to: "bae/lm.py"
      via: "Graph.run() awaits lm.choose_type() and lm.fill()"
      pattern: "await lm\\.(choose_type|fill)\\("
    - from: "bae/graph.py"
      to: "bae/node.py"
      via: "Graph.run() awaits current(lm) or current() for custom __call__"
      pattern: "await current\\("
    - from: "bae/cli.py"
      to: "bae/graph.py"
      via: "asyncio.run() wraps async graph.run() in sync CLI"
      pattern: "asyncio\\.run\\("
---

<objective>
Convert Node.__call__, Graph.run(), CompiledGraph.run(), and CLI to async, completing the async conversion of all production code.

Purpose: With all backends async (Plans 01+02), the graph execution layer can now become async. Graph.run() awaits LM calls and node.__call__. The CLI is the sync boundary — Typer commands stay sync and use asyncio.run() to invoke the async graph.

Output: Fully async production code, passing node/graph/routing tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@bae/node.py
@bae/graph.py
@bae/compiler.py
@bae/cli.py
@tests/test_node.py
@tests/test_graph.py
@tests/test_auto_routing.py
@.planning/phases/11-async-core/11-01-SUMMARY.md
@.planning/phases/11-async-core/11-02-SUMMARY.md

Requirements: ASYNC-01 (Graph.run async), ASYNC-07 (Node.__call__ async), ASYNC-08 (CLI asyncio.run boundary), ASYNC-09 (CompiledGraph.run async).

Key details for Graph.run() conversion:
- resolve_fields() stays SYNC in Phase 11 (async is Phase 12). Do NOT await it.
- LM method calls must be awaited: `await lm.choose_type(...)`, `await lm.fill(...)`
- Custom __call__ nodes: `await current(lm)` or `await current()`
- The while loop structure stays the same — async doesn't change the loop, just adds await at I/O points.

For cli.py:
- `run_graph` Typer command stays `def run_graph(...)` (sync — Typer doesn't support async commands)
- Wrap the `graph.run()` call with `asyncio.run()`: `result = asyncio.run(graph.run(start_node, lm=lm))`
- Add `import asyncio` at top of cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert node.py, graph.py, compiler.py to async</name>
  <files>bae/node.py, bae/graph.py, bae/compiler.py</files>
  <action>
  1. In node.py:
     - Change `def __call__(self, lm: LM, ...) -> Node | None` to `async def __call__(self, lm: LM, ...) -> Node | None`
     - The body `return lm.decide(self)` becomes `return await lm.decide(self)` (lm.decide is now async)
     - `_has_ellipsis_body` already handles `ast.AsyncFunctionDef` (line 44 in node.py checks for both FunctionDef and AsyncFunctionDef) — no change needed there.
     - `_wants_lm` uses `get_type_hints(method)` which works on async functions — no change needed.
     - `successors()` and `is_terminal()` use `get_type_hints(cls.__call__)` which works on async — no change needed.

  2. In graph.py:
     - `async def run(self, start_node, lm=None, max_iters=10) -> GraphResult`:
       - The default LM import (DSPyBackend) stays the same — just creating an instance, no await needed.
       - resolve_fields() call stays sync (NOT awaited): `resolved = resolve_fields(current.__class__, trace, dep_cache)` — unchanged.
       - LM calls become awaited:
         - `target_type = await lm.choose_type(types_list, context)` (was sync call)
         - `current = await lm.fill(target_type, target_resolved, instruction, source=current)` (was sync call)
       - Custom __call__ becomes awaited:
         - `current = await current(lm)` (was `current = current(lm)`)
         - `current = await current()` (was `current = current()`)
       - The while loop, iteration guard, trace.append, strategy detection — all stay sync.
     - Add `import asyncio` if not already present (may not be needed if no asyncio calls).
     - `_get_routing_strategy`, `_build_context`, `_build_instruction`, `_get_base_type` — all stay sync (pure computation).
     - `_discover`, `validate`, `to_mermaid` — all stay sync (no I/O).

  3. In compiler.py:
     - `async def run(self, start_node)` in CompiledGraph:
       - `return await self.graph.run(start_node, lm=lm)` (was sync call)
     - `node_to_signature`, `compile_graph`, `create_optimized_lm` — stay sync (pure computation).
  </action>
  <verify>
  `uv run python -c "import inspect; from bae.node import Node; assert inspect.iscoroutinefunction(Node.__call__)"`
  `uv run python -c "import inspect; from bae.graph import Graph; assert inspect.iscoroutinefunction(Graph.run)"`
  `uv run python -c "import inspect; from bae.compiler import CompiledGraph; assert inspect.iscoroutinefunction(CompiledGraph.run)"`
  </verify>
  <done>
  Node.__call__ is async. Graph.run() is async and awaits LM calls + custom __call__. CompiledGraph.run() is async. resolve_fields stays sync. All pure-computation functions unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert CLI to asyncio.run() boundary</name>
  <files>bae/cli.py</files>
  <action>
  1. Add `import asyncio` at top.
  2. In `run_graph()` command:
     - The current code has two branches:
       ```python
       result = graph.run(start_node, lm=lm) if lm else graph.run(start_node)
       ```
     - Change to:
       ```python
       if lm:
           result = asyncio.run(graph.run(start_node, lm=lm))
       else:
           result = asyncio.run(graph.run(start_node))
       ```
     - Or more cleanly:
       ```python
       result = asyncio.run(graph.run(start_node, lm=lm))
       ```
       (since lm=None is handled inside graph.run already)
  3. Fix pre-existing bug: `graph._start` should be `graph.start` (lines 243 and 267 reference `graph._start` but Graph stores `self.start`). Fix both references.
  4. The rest of cli.py (graph show, graph export, graph mermaid) stays sync — they don't call graph.run().
  </action>
  <verify>
  `uv run python -c "from bae.cli import app"` — imports without error
  </verify>
  <done>
  CLI run_graph wraps graph.run() with asyncio.run(). Typer commands remain sync. CLI imports cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate test_node.py, test_graph.py, test_auto_routing.py to async</name>
  <files>tests/test_node.py, tests/test_graph.py, tests/test_auto_routing.py</files>
  <action>
  1. In all three files, update MockLM classes to have async methods:
     - `async def make(self, node, target)` — return same values
     - `async def decide(self, node)` — return same values
     - `async def choose_type(self, types, context)` — return same values
     - `async def fill(self, target, resolved, instruction, source=None)` — return same values

  2. In test_node.py (~113 lines):
     - `test_call_with_lm_make` — calls `node(lm)`, change to `await node(lm)`, make test async
     - `test_call_branches_on_condition` — same pattern
     - `test_call_with_lm_decide` — same pattern
     - Tests for `successors()`, `is_terminal()` stay sync (classmethod, no I/O)

  3. In test_graph.py (~177 lines):
     - All tests calling `graph.run(...)` — change to `await graph.run(...)`, make test async
     - Tests for graph construction (`test_nodes`, `test_edges`, etc.) stay sync
     - Tests for `validate()`, `to_mermaid()` stay sync

  4. In test_auto_routing.py (~393 lines):
     - Tests for `_has_ellipsis_body` and `_get_routing_strategy` — stay sync (pure functions)
     - Tests in `TestGraphAutoRouting` class that call `graph.run()` — change to `await graph.run()`, make async
     - Mock backends in auto_routing tests (AutoRoutingMockLM or similar) — make methods async
     - Any tests using unittest.mock.patch on LM methods — update to AsyncMock or async mock functions.

  5. Re-enable any tests that were skipped in Plan 01 Task 2 (test_fill_protocol.py) that depend on async Graph.run(). Go to test_fill_protocol.py, find skip markers added in Plan 01, remove them, make those tests async with `await graph.run()`.

  6. With `asyncio_mode = "auto"`, no decorators needed.
  </action>
  <verify>
  `uv run python -m pytest tests/test_node.py tests/test_graph.py tests/test_auto_routing.py tests/test_fill_protocol.py -v --tb=short`
  All tests pass.
  </verify>
  <done>
  MockLMs in all three test files have async methods. Tests that call node.__call__() or graph.run() are async with await. Pure-logic tests stay sync. Any Plan-01 skipped tests re-enabled. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "import bae"` — full package imports without error
2. `uv run python -m pytest tests/test_node.py tests/test_graph.py tests/test_auto_routing.py -v` — all pass
3. `uv run python -m pytest tests/test_fill_protocol.py -v` — all pass (no more skips)
4. `uv run python -c "import inspect; from bae.graph import Graph; assert inspect.iscoroutinefunction(Graph.run)"` — confirmed async
</verification>

<success_criteria>
- Node.__call__ is async def
- Graph.run() is async def, awaits LM calls and custom __call__
- CompiledGraph.run() is async def
- CLI uses asyncio.run() at boundary
- resolve_fields() is NOT async (Phase 12)
- test_node.py, test_graph.py, test_auto_routing.py, test_fill_protocol.py all pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-async-core/11-03-SUMMARY.md`
</output>
