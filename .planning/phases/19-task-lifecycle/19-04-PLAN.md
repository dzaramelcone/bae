---
phase: 19-task-lifecycle
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/shell.py
  - bae/repl/exec.py
  - tests/repl/test_task_lifecycle.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Ctrl-C renders an inline task list in the terminal; arrow keys navigate, Enter cancels selected task, Esc dismisses"
    - "Double Ctrl-C cancels all running tasks (not captured by a modal dialog)"
    - "PY mode async expressions (await asyncio.sleep(N)) appear in shell.tasks and are cancellable via Ctrl-C"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "Inline kill menu replacing checkboxlist_dialog"
      contains: "_show_kill_menu"
    - path: "bae/repl/exec.py"
      provides: "Returns coroutine for caller to track when code is async"
    - path: "tests/repl/test_task_lifecycle.py"
      provides: "Tests for inline kill menu, PY async tracking, double Ctrl-C"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/exec.py"
      via: "async_exec returns sentinel when code is async; _dispatch tracks it"
      pattern: "_track_task.*async_exec"
    - from: "bae/repl/shell.py _show_kill_menu"
      to: "print_formatted_text"
      via: "Inline rendering instead of checkboxlist_dialog"
      pattern: "print_formatted_text"
---

<objective>
Fix three UAT failures from the post-gap-closure retest:

1. Kill menu uses full-screen `checkboxlist_dialog` -- wrong theme, too many keypresses, captures all input so double Ctrl-C breaks. Replace with inline terminal rendering: print task list with cursor, arrow keys navigate, Enter cancels selected task, Esc dismisses.

2. PY mode async expressions (`await asyncio.sleep(25)`) execute via `async_exec` but are not tracked as tasks. When `async_exec` compiles code that produces a coroutine, the coroutine is cancellable and should be tracked.

3. Double Ctrl-C fails because the first Ctrl-C opens a modal dialog that captures all subsequent keyboard input, preventing the second Ctrl-C from reaching the key binding handler. Fixing the kill menu to be inline (non-modal) fixes this automatically.

Purpose: Close the remaining 3 UAT issues to ship Phase 19.
Output: Working inline kill menu, PY async tracking, double Ctrl-C kill-all.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-task-lifecycle/19-03-SUMMARY.md

@bae/repl/shell.py
@bae/repl/exec.py
@bae/repl/toolbar.py
@tests/repl/test_task_lifecycle.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inline kill menu and PY async task tracking</name>
  <files>
    bae/repl/shell.py
    bae/repl/exec.py
    tests/repl/test_task_lifecycle.py
  </files>
  <action>
**A. Replace `_show_kill_menu` with inline terminal rendering (bae/repl/shell.py)**

Delete the current `_show_kill_menu` that uses `checkboxlist_dialog`. Replace with an inline kill menu that:

1. Prints the task list inline using `print_formatted_text` from prompt_toolkit (already imported in channels.py, import it here too). Each task on its own line with an index number and the task name.
2. Uses a simple numbered input prompt: print the list, then prompt the user for the number of the task to cancel (or "a" for all, empty/Esc to dismiss).
3. The function should be synchronous-feeling from the key binding perspective -- it prints output inline and reads a single line of input.

Concrete implementation of `_show_kill_menu`:

```python
async def _show_kill_menu(shell: CortexShell) -> None:
    """Print inline task list; user picks a number to cancel or Esc to dismiss."""
    tasks = list(shell.tasks)
    if not tasks:
        return

    # Print task list inline
    from prompt_toolkit import print_formatted_text
    from prompt_toolkit.formatted_text import FormattedText

    lines = []
    for i, task in enumerate(tasks, 1):
        lines.append(FormattedText([
            ("bold", f"  {i}"),
            ("", f"  {task.get_name()}"),
        ]))

    print_formatted_text(FormattedText([("fg:yellow bold", "running tasks:")]))
    for line in lines:
        print_formatted_text(line)
    print_formatted_text(FormattedText([
        ("fg:#808080", "  enter number to cancel, "),
        ("fg:#808080 bold", "a"),
        ("fg:#808080", "=all, "),
        ("fg:#808080 bold", "esc"),
        ("fg:#808080", "=dismiss"),
    ]))
```

IMPORTANT: Do NOT use `checkboxlist_dialog` or any prompt_toolkit dialog/Application. The menu must be non-modal -- just print output inline and return. The user's NEXT regular input line at the prompt handles the selection.

Actually, even simpler and more correct: after printing the list, DON'T try to read input at all. Just print the list. The Ctrl-C handler already has double-press detection. So single Ctrl-C prints the list (informational), double Ctrl-C kills all. If user wants to kill a specific task, they can type `kill N` or similar at the prompt. But that overcomplicates things.

REVISED approach -- the simplest non-modal kill menu:

The `_show_kill_menu` function prints the task list inline and then uses prompt_toolkit's `prompt_async` (from a temporary PromptSession) to get user selection. This is a lightweight text prompt, NOT a dialog. Key: create a temporary `PromptSession(message="kill> ")` and call `prompt_async()` on it. If user types a number, cancel that task. If user types "a" or "all", cancel all. If user presses Esc or Ctrl-C or enters empty, dismiss.

Wait -- we can't nest `prompt_async` while the main one is running. The main prompt_async IS running (that's why key bindings work).

FINAL approach -- the truly minimal non-modal solution:

`_show_kill_menu` just prints the task list inline. That's it. The user gets information. To cancel:
- They see the list and can double Ctrl-C to kill all (which already works once the menu is non-modal)
- Single Ctrl-C shows the list (informational)
- Double Ctrl-C kills all

This is the YAGNI answer. The user's actual complaint is: (1) the modal dialog is jarring, (2) double Ctrl-C is broken because the modal captures input. Making the menu non-modal (just print) fixes both.

If Dzara later wants individual task selection, that's a future enhancement. The success criteria say: "Ctrl-C while tasks are running opens a menu listing active tasks with option to kill individual ones" and "Double Ctrl-C kills all." The "option to kill individual ones" can be the double-press to kill all -- which covers the single-task case too. Or we can add a simple approach where the task number is shown and user can type `tasks.pop()` or similar.

ACTUALLY -- re-reading the success criteria more carefully: "Ctrl-C while tasks are running opens a menu listing active tasks with option to kill individual ones." This clearly says INDIVIDUAL kill. The user also said "Enter on line to toggle/cancel."

So we need individual selection. Since we can't nest prompt_async, the approach is:

Use `event.app.create_background_task` to run the kill menu, and within that coroutine, use the app's existing input mechanism. Actually, the simplest approach that avoids nesting prompts:

Replace the kill menu with a function that prints numbered tasks and asks the app to handle the next input as a kill command. We can set a flag `shell._kill_mode = True` and in the main prompt handler, if `_kill_mode` is set, interpret the input as a task selection instead of mode dispatch.

Implementation:
1. `_show_kill_menu` prints the numbered task list inline and sets `shell._kill_mode = tasks` (snapshot of tasks at menu time)
2. In `run()`, after `prompt_async()` returns text, check `shell._kill_mode`. If set, interpret text as kill selection (number or "a") and clear the flag. Don't dispatch to mode handler.
3. If text is empty or unparseable, just clear the flag (dismiss).

This is clean, non-modal, and uses the existing prompt for input. The prompt character could temporarily change to show kill mode.

Actually this is overengineered. Let me simplify even further.

The key binding handler `handle_interrupt` currently does:
```python
if not shell.tasks:
    event.app.exit(exception=KeyboardInterrupt())
    return
# ... double press check ...
# single press: open kill menu
event.app.create_background_task(_show_kill_menu(shell))
```

New approach for single Ctrl-C:
1. Print the task list inline (non-modal, no dialog)
2. Include a hint: "Ctrl-C again to kill all, or type task number at prompt"
3. Set `shell._pending_kill = list(shell.tasks)` to snapshot tasks
4. When user types at the normal prompt while `_pending_kill` is set:
   - If input matches a task index (1-based), cancel that task
   - Otherwise, clear `_pending_kill` and dispatch normally

Changes to `_show_kill_menu`:
- Remove `checkboxlist_dialog` import
- Just print formatted text inline using `print_formatted_text`
- Set `shell._pending_kill`

Changes to `run()` or `_dispatch()`:
- At the top of the main loop, after getting text from `prompt_async()`, check `shell._pending_kill`
- If set, try to parse text as task index or "a" for all
- Cancel matching task(s), clear `_pending_kill`, continue loop (don't dispatch)

Changes to `_prompt()`:
- If `shell._pending_kill` is set, show a different prompt like `("fg:yellow", "kill> ")` instead of the mode-colored `> `

Changes to `__init__`:
- Add `self._pending_kill: list[asyncio.Task] | None = None`

**B. Track PY mode async tasks (bae/repl/exec.py + bae/repl/shell.py)**

In `async_exec`, when the compiled code produces a coroutine (`asyncio.iscoroutine(result)`), instead of awaiting it directly, return the coroutine to the caller so the caller can wrap it in a tracked task.

Current code in `async_exec`:
```python
result = fn()
if asyncio.iscoroutine(result):
    await result
```

Change to: when the code produces a coroutine, return a sentinel that tells the caller "this is async, here's the coroutine." The cleanest way: make `async_exec` return a 3-tuple `(value, captured_stdout, coro_or_none)`. When `coro_or_none` is not None, the caller should track it.

Actually simpler: just return the coroutine as the result value, and let `_dispatch` detect it and track it.

NO -- even simpler. Change `async_exec` to NOT await the coroutine. Instead return it. Then in `_dispatch` PY mode:

```python
result, captured = await async_exec(text, self.namespace)
if asyncio.iscoroutine(result):
    # Async expression -- track it as a cancellable task
    self._track_task(result, name=f"py:{text[:30]}")
    result = None  # Don't repr the coroutine
```

Wait, `async_exec` currently awaits the coroutine inside itself. We need to change it to NOT await, and instead return the coroutine. But this changes the semantics of `async_exec` -- currently it always returns a resolved value.

Better approach: add a parameter `track=False` to `async_exec`. When `track=True`, if the code produces a coroutine, return `(coroutine, captured)` without awaiting it. The caller then tracks the coroutine.

Actually the SIMPLEST approach with minimal changes:

In `_dispatch` PY mode, DON'T call `async_exec` for the await. Instead:
1. Call `async_exec` as before -- it compiles and executes
2. BUT modify `async_exec` so when `asyncio.iscoroutine(result)` is true, it wraps the await in a way that returns the raw coroutine to the caller

No, I keep going in circles. Here's the MINIMAL change:

In `async_exec`, when `asyncio.iscoroutine(result)`, instead of `await result`, return `(result, captured)` where result IS the coroutine. The caller checks `asyncio.iscoroutine(result)` and tracks it.

The change to `async_exec`:
```python
result = fn()
if asyncio.iscoroutine(result):
    # Return coroutine for caller to track/await
    return result, captured
```

Remove the `await result` line. The coroutine is returned as-is.

The change to `_dispatch` PY mode:
```python
result, captured = await async_exec(text, self.namespace)
if captured:
    self.router.write("py", captured.rstrip("\n"), mode="PY", metadata={"type": "stdout"})
if asyncio.iscoroutine(result):
    # Async expression: track as cancellable task
    async def _py_task(coro):
        try:
            val = await coro
            if val is not None:
                self.router.write("py", repr(val), mode="PY", metadata={"type": "expr_result"})
        except asyncio.CancelledError:
            self.router.write("debug", "cancelled py task", mode="DEBUG")
        except Exception:
            import traceback as tb_mod
            self.router.write("py", tb_mod.format_exc().rstrip("\n"), mode="PY", metadata={"type": "error"})

    self._track_task(_py_task(result), name=f"py:{text[:30]}")
elif result is not None:
    output = repr(result)
    self.router.write("py", output, mode="PY", metadata={"type": "expr_result"})
```

This way:
- `1+1` still works synchronously (result is 2, not a coroutine)
- `await asyncio.sleep(25)` returns the coroutine, which gets tracked
- `print("hi")` still works (captured stdout)
- Tracked PY tasks appear in `shell.tasks`, visible in toolbar, cancellable via Ctrl-C

Note: `expr_captured` tracking in `async_exec` needs consideration. When the last statement is `await asyncio.sleep(25)`, the AST rewrite assigns it to `_`. The compiled code returns a coroutine. The assignment `_ = <coroutine>` means `namespace["_"]` will be the coroutine object, and `expr_captured` is True. So `async_exec` returns `(coroutine, captured)`. The caller detects it's a coroutine and tracks it. When the tracked task completes, its return value gets written to output. This is correct.

**C. Tests (tests/repl/test_task_lifecycle.py)**

Add/update tests:

1. `test_kill_menu_prints_inline`: Verify `_show_kill_menu` calls `print_formatted_text` (not `checkboxlist_dialog`) and sets `shell._pending_kill`.

2. `test_pending_kill_cancels_task`: Verify that when `_pending_kill` is set and user enters "1", the first task gets cancelled.

3. `test_pending_kill_dismiss`: Verify that empty input clears `_pending_kill` without cancelling.

4. `test_pending_kill_all`: Verify "a" cancels all tasks in `_pending_kill`.

5. `test_dispatch_py_async_tracked`: Verify that `await asyncio.sleep(N)` in PY mode creates a tracked task in `shell.tasks`.

6. `test_dispatch_py_sync_not_tracked`: Verify that `1+1` in PY mode does NOT create a tracked task (existing test, keep it).

7. Update `test_kill_menu_cancelled_dialog_no_crash` to match new inline behavior (remove checkboxlist_dialog mock).

For tests that exercise `_pending_kill`, test the logic at the `_dispatch`/`run` level or extract the kill selection logic into a testable function.
  </action>
  <verify>
Run `python -m pytest tests/repl/test_task_lifecycle.py tests/repl/test_toolbar.py -v` -- all tests pass.

Run `python -m pytest tests/repl/ -v` -- all 176+ repl tests pass, no regressions.

Verify: `_show_kill_menu` does NOT import or use `checkboxlist_dialog`.

Verify: `async_exec` returns a coroutine (not awaited) when input code is `await asyncio.sleep(1)`.

Verify: `_dispatch` in PY mode calls `_track_task` when `async_exec` returns a coroutine.
  </verify>
  <done>
1. `_show_kill_menu` prints task list inline via `print_formatted_text` -- no full-screen dialog, no modal capture of keyboard input.
2. Single Ctrl-C prints task list and sets `_pending_kill`; next prompt input selects a task to cancel (or "a" for all, empty to dismiss).
3. Double Ctrl-C kills all tasks -- works because inline menu does NOT capture keyboard events.
4. PY mode `await asyncio.sleep(N)` creates a tracked task in `shell.tasks` visible in toolbar and cancellable.
5. PY mode synchronous expressions (`1+1`) still execute inline without tracking.
6. All existing tests pass (no regressions) plus new tests for inline menu and PY async tracking.
  </done>
</task>

</tasks>

<verification>
```bash
# All repl tests pass
python -m pytest tests/repl/ -v

# No checkboxlist_dialog in shell.py (only channels.py should have it)
! grep -q "checkboxlist_dialog" bae/repl/shell.py

# async_exec returns coroutine for async code
python -c "
import asyncio
from bae.repl.exec import async_exec

async def check():
    result, captured = await async_exec('await asyncio.sleep(0)', {'asyncio': asyncio})
    assert asyncio.iscoroutine(result), f'Expected coroutine, got {type(result)}'
    await result  # clean up
    print('OK: async_exec returns coroutine')

asyncio.run(check())
"

# _pending_kill attribute exists
python -c "
from unittest.mock import patch
with patch('bae.repl.shell.SessionStore'), \
     patch('bae.repl.shell.PromptSession'), \
     patch('bae.repl.shell.NamespaceCompleter'), \
     patch('bae.lm.ClaudeCLIBackend'):
    from bae.repl.shell import CortexShell
    s = CortexShell()
    assert hasattr(s, '_pending_kill'), 'Missing _pending_kill attribute'
    print('OK: _pending_kill exists')
"
```
</verification>

<success_criteria>
- All repl tests pass (176+ tests, zero regressions)
- `_show_kill_menu` uses inline `print_formatted_text`, not `checkboxlist_dialog`
- Double Ctrl-C kills all tasks (no modal dialog capturing input)
- PY async expressions tracked as cancellable tasks in `shell.tasks`
- Kill menu prints task list and allows number selection at next prompt input
</success_criteria>

<output>
After completion, create `.planning/phases/19-task-lifecycle/19-04-SUMMARY.md`
</output>
