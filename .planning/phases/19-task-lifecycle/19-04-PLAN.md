---
phase: 19-task-lifecycle
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/repl/shell.py
  - bae/repl/exec.py
  - tests/repl/test_task_lifecycle.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Ctrl-C with running tasks prints an inline task list; user can cancel a task by entering its number at the next prompt"
    - "Double Ctrl-C cancels all running tasks"
    - "PY mode async expressions (await asyncio.sleep(N)) appear in shell.tasks and are cancellable via Ctrl-C"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "Inline kill menu replacing checkboxlist_dialog"
      contains: "_show_kill_menu"
    - path: "bae/repl/exec.py"
      provides: "Returns coroutine for caller to track when code is async"
    - path: "tests/repl/test_task_lifecycle.py"
      provides: "Tests for inline kill menu, PY async tracking, double Ctrl-C"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/exec.py"
      via: "async_exec returns coroutine when code is async; _dispatch tracks it"
      pattern: "_track_task.*async_exec"
    - from: "bae/repl/shell.py _show_kill_menu"
      to: "print_formatted_text"
      via: "Inline rendering instead of checkboxlist_dialog"
      pattern: "print_formatted_text"
---

<objective>
Fix three UAT failures from the post-gap-closure retest:

1. Kill menu uses full-screen `checkboxlist_dialog` -- captures all input so double Ctrl-C breaks. Replace with inline print + typed number selection at the next prompt.

2. PY mode async expressions (`await asyncio.sleep(25)`) execute via `async_exec` but are not tracked as tasks. When `async_exec` compiles code that produces a coroutine, the coroutine is cancellable and should be tracked.

3. Double Ctrl-C fails because the first Ctrl-C opens a modal dialog that captures all subsequent keyboard input. Making the kill menu non-modal (inline print) fixes this automatically.

Purpose: Close the remaining 3 UAT issues to ship Phase 19.
Output: Working inline kill menu, PY async tracking, double Ctrl-C kill-all.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-task-lifecycle/19-03-SUMMARY.md

@bae/repl/shell.py
@bae/repl/exec.py
@bae/repl/toolbar.py
@tests/repl/test_task_lifecycle.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inline kill menu and PY async task tracking</name>
  <files>
    bae/repl/shell.py
    bae/repl/exec.py
    tests/repl/test_task_lifecycle.py
  </files>
  <action>
**A. Replace `_show_kill_menu` with inline print + _pending_kill (bae/repl/shell.py)**

Delete the current `_show_kill_menu` that uses `checkboxlist_dialog`. Replace with a function that prints the task list inline and sets a flag for the next prompt to interpret as kill selection.

1. `_show_kill_menu` prints a numbered task list via `print_formatted_text` (from prompt_toolkit), then sets `shell._pending_kill` to a snapshot of the current tasks:

```python
async def _show_kill_menu(shell: CortexShell) -> None:
    """Print inline task list; next prompt input selects task to cancel."""
    tasks = list(shell.tasks)
    if not tasks:
        return
    from prompt_toolkit import print_formatted_text
    from prompt_toolkit.formatted_text import FormattedText

    print_formatted_text(FormattedText([("fg:yellow bold", "running tasks:")]))
    for i, task in enumerate(tasks, 1):
        print_formatted_text(FormattedText([
            ("bold", f"  {i}"),
            ("", f"  {task.get_name()}"),
        ]))
    print_formatted_text(FormattedText([
        ("fg:#808080", "  enter number to cancel, "),
        ("fg:#808080 bold", "a"),
        ("fg:#808080", "=all, "),
        ("fg:#808080 bold", "enter"),
        ("fg:#808080", "=dismiss"),
    ]))
    shell._pending_kill = tasks
```

Do NOT use `checkboxlist_dialog` or any prompt_toolkit dialog. The menu is non-modal -- it prints output and returns. The user's NEXT regular prompt input handles the selection.

2. Add `self._pending_kill: list[asyncio.Task] | None = None` to `__init__`.

3. In `_prompt()`, when `_pending_kill` is set, show `("fg:yellow", "kill> ")` instead of the normal mode-colored `> `.

4. In `run()`, after `prompt_async()` returns text, check `_pending_kill` BEFORE dispatching:
   - If `_pending_kill` is set and text is a valid 1-based index into the snapshot, cancel that task.
   - If text is `"a"`, cancel all tasks in the snapshot.
   - Any other input (empty, non-matching): dismiss (clear `_pending_kill`, do NOT dispatch).
   - After handling, set `_pending_kill = None` and `continue` the loop (skip dispatch).

**B. Track PY mode async tasks (bae/repl/exec.py + bae/repl/shell.py)**

In `async_exec`, when `asyncio.iscoroutine(result)` is true after executing the compiled code, do NOT await it. Return the raw coroutine as the result value:

```python
result = fn()
if asyncio.iscoroutine(result):
    return result, captured   # caller tracks/awaits
```

In `_dispatch` PY mode, after calling `async_exec`, check if result is a coroutine:

```python
result, captured = await async_exec(text, self.namespace)
if captured:
    self.router.write("py", captured.rstrip("\n"), mode="PY", metadata={"type": "stdout"})
if asyncio.iscoroutine(result):
    async def _py_task(coro):
        try:
            val = await coro
            if val is not None:
                self.router.write("py", repr(val), mode="PY", metadata={"type": "expr_result"})
        except asyncio.CancelledError:
            self.router.write("debug", "cancelled py task", mode="DEBUG")
        except Exception:
            import traceback as tb_mod
            self.router.write("py", tb_mod.format_exc().rstrip("\n"), mode="PY", metadata={"type": "error"})
    self._track_task(_py_task(result), name=f"py:{text[:30]}")
elif result is not None:
    output = repr(result)
    self.router.write("py", output, mode="PY", metadata={"type": "expr_result"})
```

Synchronous expressions (`1+1`) still return resolved values. Async expressions (`await asyncio.sleep(25)`) return coroutines that get tracked.

**C. Tests (tests/repl/test_task_lifecycle.py)**

Add/update tests:

1. `test_kill_menu_prints_inline`: Verify `_show_kill_menu` calls `print_formatted_text` (not `checkboxlist_dialog`) and sets `shell._pending_kill`.
2. `test_pending_kill_cancels_task`: When `_pending_kill` is set and user enters "1", the first task gets cancelled.
3. `test_pending_kill_dismiss`: Empty input clears `_pending_kill` without cancelling.
4. `test_pending_kill_all`: "a" cancels all tasks in `_pending_kill`.
5. `test_dispatch_py_async_tracked`: `await asyncio.sleep(N)` in PY mode creates a tracked task in `shell.tasks`.
6. `test_dispatch_py_sync_not_tracked`: `1+1` in PY mode does NOT create a tracked task (existing test, keep it).
7. Update `test_kill_menu_cancelled_dialog_no_crash` to match new inline behavior (remove checkboxlist_dialog mock).

For `_pending_kill` tests, test the kill selection logic at the `run()` level or extract it into a testable helper.
  </action>
  <verify>
Run `python -m pytest tests/repl/test_task_lifecycle.py tests/repl/test_toolbar.py -v` -- all tests pass.

Run `python -m pytest tests/repl/ -v` -- all 176+ repl tests pass, no regressions.

Verify: `_show_kill_menu` does NOT import or use `checkboxlist_dialog`.

Verify: `async_exec` returns a coroutine (not awaited) when input code is `await asyncio.sleep(1)`.

Verify: `_dispatch` in PY mode calls `_track_task` when `async_exec` returns a coroutine.
  </verify>
  <done>
1. `_show_kill_menu` prints task list inline via `print_formatted_text` -- no full-screen dialog, no modal capture of keyboard input.
2. Single Ctrl-C prints task list and sets `_pending_kill`; next prompt input selects a task to cancel (or "a" for all, empty to dismiss).
3. Double Ctrl-C kills all tasks -- works because inline menu does NOT capture keyboard events.
4. PY mode `await asyncio.sleep(N)` creates a tracked task in `shell.tasks` visible in toolbar and cancellable.
5. PY mode synchronous expressions (`1+1`) still execute inline without tracking.
6. All existing tests pass (no regressions) plus new tests for inline menu and PY async tracking.
  </done>
</task>

</tasks>

<verification>
```bash
# All repl tests pass
python -m pytest tests/repl/ -v

# No checkboxlist_dialog in shell.py (only channels.py should have it)
! grep -q "checkboxlist_dialog" bae/repl/shell.py

# async_exec returns coroutine for async code
python -c "
import asyncio
from bae.repl.exec import async_exec

async def check():
    result, captured = await async_exec('await asyncio.sleep(0)', {'asyncio': asyncio})
    assert asyncio.iscoroutine(result), f'Expected coroutine, got {type(result)}'
    await result  # clean up
    print('OK: async_exec returns coroutine')

asyncio.run(check())
"

# _pending_kill attribute exists
python -c "
from unittest.mock import patch
with patch('bae.repl.shell.SessionStore'), \
     patch('bae.repl.shell.PromptSession'), \
     patch('bae.repl.shell.NamespaceCompleter'), \
     patch('bae.lm.ClaudeCLIBackend'):
    from bae.repl.shell import CortexShell
    s = CortexShell()
    assert hasattr(s, '_pending_kill'), 'Missing _pending_kill attribute'
    print('OK: _pending_kill exists')
"
```
</verification>

<success_criteria>
- All repl tests pass (176+ tests, zero regressions)
- `_show_kill_menu` uses inline `print_formatted_text`, not `checkboxlist_dialog`
- Double Ctrl-C kills all tasks (no modal dialog capturing input)
- PY async expressions tracked as cancellable tasks in `shell.tasks`
- Kill menu prints task list and allows number selection at next prompt input
</success_criteria>

<output>
After completion, create `.planning/phases/19-task-lifecycle/19-04-SUMMARY.md`
</output>
