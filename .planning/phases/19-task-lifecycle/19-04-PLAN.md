---
phase: 19-task-lifecycle
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/repl/tasks.py
  - tests/repl/test_task_manager.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "TaskManager.submit() wraps a coroutine in a TrackedTask with RUNNING state, mode label, and auto-cleanup on completion"
    - "TaskManager.register_process() associates a subprocess.Process with the currently running asyncio.Task"
    - "TaskManager.revoke() sends SIGTERM (graceful) or SIGKILL (non-graceful) to the process group, then cancels the asyncio.Task"
    - "TaskManager.revoke_all() kills all active tasks (SIGKILL for non-graceful)"
    - "TaskManager.active() returns list of TrackedTask in RUNNING state for kill menu and toolbar"
    - "TaskManager.shutdown() gracefully terminates all tasks for Ctrl-D exit"
    - "TrackedTask tracks state transitions: RUNNING -> SUCCESS | FAILURE | REVOKED"
  artifacts:
    - path: "bae/repl/tasks.py"
      provides: "TaskManager class + TrackedTask dataclass + TaskState enum"
      exports: ["TaskManager", "TrackedTask", "TaskState"]
    - path: "tests/repl/test_task_manager.py"
      provides: "Unit tests for TaskManager lifecycle, process association, revoke, revoke_all, shutdown"
  key_links:
    - from: "TaskManager.submit"
      to: "asyncio.create_task"
      via: "Wraps coroutine in asyncio.Task, stores in TrackedTask registry"
      pattern: "asyncio.create_task"
    - from: "TaskManager.revoke"
      to: "os.killpg"
      via: "Kills process group for clean tree cleanup"
      pattern: "os\\.killpg"
---

<objective>
Create the TaskManager module (bae/repl/tasks.py) with TrackedTask dataclass and TaskManager class using TDD.

TaskManager is a central task registry with lifecycle-tracked tasks. It replaces the bare `set[asyncio.Task]` in CortexShell with structured tracking: state machine, process association, and direct process kill (not through CancelledError indirection).

Purpose: Foundation for inline kill menu, process group cleanup, and future worker architecture.
Output: Working, tested TaskManager with submit/register_process/revoke/revoke_all/active/shutdown API.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-task-lifecycle/19-03-SUMMARY.md

@bae/repl/shell.py
@bae/repl/ai.py
@bae/repl/bash.py
</context>

<feature>
  <name>TaskManager with lifecycle tracking and process group management</name>
  <files>bae/repl/tasks.py, tests/repl/test_task_manager.py</files>
  <behavior>
    TaskState enum: RUNNING, SUCCESS, FAILURE, REVOKED

    TrackedTask dataclass:
      - task: asyncio.Task
      - process: subprocess.Process | None (set later via register_process)
      - state: TaskState (starts RUNNING)
      - name: str
      - mode: str (e.g. "nl", "bash", "py", "graph")
      - task_id: int (auto-incrementing from TaskManager)

    TaskManager:
      - submit(coro, *, name, mode) -> TrackedTask
        Creates asyncio.Task, wraps in TrackedTask(state=RUNNING), registers done callback.
        Done callback transitions state to SUCCESS (normal), FAILURE (exception), or REVOKED (CancelledError).
        Returns TrackedTask.

      - register_process(process) -> None
        Finds TrackedTask by current asyncio.Task (asyncio.current_task()), associates process.
        Called from within a running task (ai.py, bash.py) after subprocess is spawned.
        No-op if current task not found in registry (defensive).

      - revoke(task_id, *, graceful=True) -> None
        Finds TrackedTask by ID. If process associated:
          graceful=True: os.killpg(process.pid, SIGTERM) -> wait 2s -> SIGKILL if still alive
          graceful=False: os.killpg(process.pid, SIGKILL) immediately
        Then task.cancel(). State transitions to REVOKED.
        If no process, just task.cancel().

      - revoke_all(*, graceful=False) -> None
        Calls revoke(id, graceful=graceful) for all active tasks.

      - active() -> list[TrackedTask]
        Returns list of TrackedTask where state == RUNNING, ordered by task_id.

      - shutdown() -> None
        revoke_all(graceful=True), then await asyncio.gather(*tasks, return_exceptions=True).

    Process groups:
      - TaskManager does NOT create subprocesses -- it receives them via register_process.
      - The callers (ai.py, bash.py) must pass start_new_session=True when creating subprocesses.
        This is done in plan 19-05 (shell integration), not here.
      - revoke() uses os.killpg() which requires start_new_session=True on the subprocess.
        Falls back to process.kill() if killpg fails (e.g., process already dead).

    Cases:
      submit(coro, name="ai:hello", mode="nl") -> TrackedTask(state=RUNNING, task_id=1)
      active() while task running -> [TrackedTask(state=RUNNING, task_id=1)]
      register_process(proc) from inside running task -> TrackedTask.process = proc
      revoke(1) -> SIGTERM to process group, wait, cancel task -> state=REVOKED
      active() after revoke -> []
      task completes normally -> state=SUCCESS, removed from active()
      task raises exception -> state=FAILURE, removed from active()
  </behavior>
  <implementation>
    Module: bae/repl/tasks.py

    ```python
    from __future__ import annotations

    import asyncio
    import enum
    import os
    import signal
    from dataclasses import dataclass, field
    from subprocess import Process


    class TaskState(enum.Enum):
        RUNNING = "running"
        SUCCESS = "success"
        FAILURE = "failure"
        REVOKED = "revoked"


    @dataclass
    class TrackedTask:
        task: asyncio.Task
        name: str
        mode: str
        task_id: int
        state: TaskState = TaskState.RUNNING
        process: Process | None = None


    class TaskManager:
        def __init__(self) -> None:
            self._tasks: dict[int, TrackedTask] = {}
            self._by_asyncio_task: dict[asyncio.Task, TrackedTask] = {}
            self._next_id = 1

        def submit(self, coro, *, name: str, mode: str) -> TrackedTask:
            task = asyncio.create_task(coro, name=name)
            tt = TrackedTask(task=task, name=name, mode=mode, task_id=self._next_id)
            self._tasks[self._next_id] = tt
            self._by_asyncio_task[task] = tt
            self._next_id += 1
            task.add_done_callback(self._on_done)
            return tt

        def register_process(self, process: Process) -> None:
            current = asyncio.current_task()
            tt = self._by_asyncio_task.get(current)
            if tt is not None:
                tt.process = process

        def revoke(self, task_id: int, *, graceful: bool = True) -> None:
            tt = self._tasks.get(task_id)
            if tt is None or tt.state != TaskState.RUNNING:
                return
            if tt.process and tt.process.returncode is None:
                self._kill_process(tt.process, graceful)
            tt.task.cancel()
            tt.state = TaskState.REVOKED

        def revoke_all(self, *, graceful: bool = False) -> None:
            for task_id in list(self._tasks):
                self.revoke(task_id, graceful=graceful)

        def active(self) -> list[TrackedTask]:
            return sorted(
                [tt for tt in self._tasks.values() if tt.state == TaskState.RUNNING],
                key=lambda tt: tt.task_id,
            )

        async def shutdown(self) -> None:
            self.revoke_all(graceful=True)
            tasks = [tt.task for tt in self._tasks.values()]
            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)

        def _on_done(self, task: asyncio.Task) -> None:
            tt = self._by_asyncio_task.get(task)
            if tt is None or tt.state != TaskState.RUNNING:
                return
            exc = task.exception() if not task.cancelled() else None
            if task.cancelled():
                tt.state = TaskState.REVOKED
            elif exc is not None:
                tt.state = TaskState.FAILURE
            else:
                tt.state = TaskState.SUCCESS

        @staticmethod
        def _kill_process(process: Process, graceful: bool) -> None:
            try:
                pgid = os.getpgid(process.pid)
            except (ProcessLookupError, OSError):
                return
            if graceful:
                try:
                    os.killpg(pgid, signal.SIGTERM)
                except (ProcessLookupError, OSError):
                    pass
            else:
                try:
                    os.killpg(pgid, signal.SIGKILL)
                except (ProcessLookupError, OSError):
                    pass
    ```

    Match existing code style: from __future__ annotations, minimal docstrings, compact.
    Do NOT add SIGTERM->wait->SIGKILL escalation in _kill_process -- revoke is synchronous.
    The graceful wait happens at shutdown() level via gather().
  </implementation>
</feature>

<verification>
```bash
# All task manager tests pass
python -m pytest tests/repl/test_task_manager.py -v

# No regressions in existing repl tests
python -m pytest tests/repl/ -v

# Module imports correctly
python -c "from bae.repl.tasks import TaskManager, TrackedTask, TaskState; print('OK')"
```
</verification>

<success_criteria>
- TaskManager.submit() creates TrackedTask with RUNNING state and auto-incrementing ID
- TaskManager.register_process() associates subprocess with current asyncio.Task
- TaskManager.revoke() kills process group then cancels task, state -> REVOKED
- TaskManager.revoke_all() kills all active tasks
- TaskManager.active() returns only RUNNING tasks sorted by ID
- TaskManager.shutdown() gracefully terminates all and awaits completion
- Done callback transitions state to SUCCESS/FAILURE/REVOKED on task completion
- All tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/19-task-lifecycle/19-04-SUMMARY.md`
</output>
