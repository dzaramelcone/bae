---
phase: 19-task-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - bae/repl/shell.py
  - bae/repl/ai.py
  - bae/repl/bash.py
  - tests/repl/test_task_lifecycle.py
autonomous: true

must_haves:
  truths:
    - "Ctrl-C at the prompt with tasks running opens a kill menu listing active tasks"
    - "Double Ctrl-C within 0.4s kills all running tasks and returns to bare prompt"
    - "Ctrl-C at the prompt with no tasks exits the REPL (REPL-12 preserved)"
    - "KeyboardInterrupt during task execution cancels tracked tasks and returns to prompt"
    - "Cancelled AI subprocess is killed (not orphaned)"
    - "Cancelled bash subprocess is killed (not orphaned)"
    - "Toolbar shows running task count via ToolbarConfig widget"
    - "Toolbar refreshes every second via refresh_interval"
    - "User can register custom toolbar widgets from PY mode via toolbar object in namespace"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "Task tracking, interrupt handler, toolbar integration, dispatch method"
      contains: "_track_task"
    - path: "bae/repl/ai.py"
      provides: "CancelledError subprocess cleanup in AI.__call__"
      contains: "CancelledError"
    - path: "bae/repl/bash.py"
      provides: "CancelledError subprocess cleanup in dispatch_bash"
      contains: "CancelledError"
    - path: "tests/repl/test_task_lifecycle.py"
      provides: "Unit tests for task tracking, interrupt routing, subprocess cleanup"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/toolbar.py"
      via: "ToolbarConfig imported, instantiated, wired to namespace and bottom_toolbar"
      pattern: "from bae\\.repl\\.toolbar import"
    - from: "bae/repl/shell.py"
      to: "bae/repl/ai.py"
      via: "_track_task wraps self.ai() in create_task for NL mode"
      pattern: "_track_task.*self\\.ai"
    - from: "bae/repl/shell.py"
      to: "bae/repl/bash.py"
      via: "_track_task wraps dispatch_bash in create_task for BASH mode"
      pattern: "_track_task.*dispatch_bash"
---

<objective>
Wire task tracking, Ctrl-C interrupt handling, kill menu, subprocess cleanup, and toolbar integration into the cortex shell.

Purpose: REPL-10 (Ctrl-C kill menu), REPL-11 (double Ctrl-C kill all), and REPL-06 (configurable toolbar) complete the task lifecycle. Users gain visibility into running tasks and control to kill them. The toolbar becomes user-extensible.

Output: Modified shell.py, ai.py, bash.py with task lifecycle behavior. test_task_lifecycle.py with unit tests.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-task-lifecycle/19-RESEARCH.md
@.planning/phases/19-task-lifecycle/19-01-SUMMARY.md
@bae/repl/shell.py
@bae/repl/ai.py
@bae/repl/bash.py
@bae/repl/channels.py
@bae/repl/modes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire task tracking, interrupt handler, toolbar, and subprocess cleanup</name>
  <files>bae/repl/shell.py, bae/repl/ai.py, bae/repl/bash.py</files>
  <action>
**bae/repl/shell.py -- Toolbar integration:**

1. Import ToolbarConfig and widget factories from bae.repl.toolbar.
2. In `__init__`: create `self.toolbar = ToolbarConfig()`, register built-in widgets (mode, tasks, cwd), inject into namespace: `self.namespace["toolbar"] = self.toolbar`.
3. Replace `_toolbar()` method: return `self.toolbar.render()`.
4. Add `refresh_interval=1.0` to PromptSession constructor (live-updating toolbar).
5. Add `"toolbar.tasks": "fg:ansiyellow bold"` to the Style dict for task count display.

**bae/repl/shell.py -- Task tracking:**

1. Add `_track_task(self, coro, *, name: str) -> asyncio.Task` method:
   - `task = asyncio.create_task(coro, name=name)`
   - `self.tasks.add(task)`
   - `task.add_done_callback(self.tasks.discard)`
   - return task

2. Extract mode dispatch into `_dispatch(self, text: str) -> None` method. In each async mode (NL, GRAPH, BASH), wrap the coroutine in `_track_task()`:
   - NL: `task = self._track_task(self.ai(text), name=f"ai:{text[:30]}")`
   - GRAPH: `task = self._track_task(channel_arun(graph, text, self.router), name=f"graph:{text[:30]}")`
   - BASH: `task = self._track_task(dispatch_bash(text), name=f"bash:{text[:30]}")`
   - PY mode: NOT tracked (synchronous-ish, can't cancel tight loops). Execute directly.

   Each tracked mode: await the task in try/except CancelledError (log to debug channel, continue). Keep existing exception handling for each mode.

3. Update `run()` to call `self._dispatch(text)` wrapped in try/except KeyboardInterrupt that cancels tracked tasks and returns to prompt (not exits).

**bae/repl/shell.py -- Interrupt handler:**

1. Add `import time` at top.
2. In `_build_key_bindings()`, add Ctrl-C handling:
   - Mutable closure: `_last_sigint = [0.0]`, `DOUBLE_PRESS_THRESHOLD = 0.4`
   - `@kb.add("c-c", eager=True)` and `@kb.add("<sigint>")` on same handler
   - Handler logic:
     a. If `not shell.tasks`: `event.app.exit(exception=KeyboardInterrupt())` -- preserves REPL-12
     b. If elapsed < threshold: kill all tasks (`for task in list(shell.tasks): task.cancel()`), write to debug channel
     c. Else: `event.app.create_background_task(_show_kill_menu(shell))`

3. Add `_show_kill_menu(shell)` async function:
   - Import `checkboxlist_dialog` from prompt_toolkit.shortcuts
   - Build values list from `shell.tasks`: `[(task, task.get_name()) for task in list(shell.tasks)]`
   - Show dialog, cancel selected tasks, write to debug channel
   - Handle empty tasks (return early) and None result (cancelled dialog)

**bae/repl/ai.py -- Subprocess cleanup:**

In `AI.__call__`, add `except asyncio.CancelledError` between the TimeoutError and the returncode check:
```python
except asyncio.CancelledError:
    process.kill()
    await process.wait()
    raise
```

**bae/repl/bash.py -- Subprocess cleanup:**

In `dispatch_bash`, wrap the `proc.communicate()` call:
```python
try:
    raw_out, raw_err = await proc.communicate()
except asyncio.CancelledError:
    proc.kill()
    await proc.wait()
    raise
```
Only applies to the subprocess path (not the cd path, which is synchronous).

Commit: `feat(19-02): wire task tracking, interrupt handler, toolbar, and subprocess cleanup`
  </action>
  <verify>
```bash
python -c "from bae.repl.shell import CortexShell; print('shell imports OK')"
python -c "from bae.repl.ai import AI; print('ai imports OK')"
python -c "from bae.repl.bash import dispatch_bash; print('bash imports OK')"
```
  </verify>
  <done>
- shell.py has _track_task, _dispatch, interrupt handler with kill menu, toolbar via ToolbarConfig
- ai.py kills subprocess on CancelledError
- bash.py kills subprocess on CancelledError
- All modules import cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for task lifecycle and interrupt routing</name>
  <files>tests/repl/test_task_lifecycle.py</files>
  <action>
Create `tests/repl/test_task_lifecycle.py` with these test groups:

**TestTrackTask class:**
- `test_track_task_adds_to_set` -- create shell, call _track_task with a coroutine, assert task in shell.tasks
- `test_track_task_removes_on_completion` -- track a task that completes, await it, assert task no longer in shell.tasks
- `test_track_task_sets_name` -- track with name="test:foo", assert task.get_name() == "test:foo"

**TestInterruptHandler class:**
Use a mock event with `event.app.exit`, `event.app.create_background_task`, `event.app.invalidate`, `event.current_buffer.reset`.

- `test_ctrl_c_no_tasks_exits` -- shell.tasks empty, handler calls event.app.exit with KeyboardInterrupt
- `test_ctrl_c_with_tasks_shows_menu` -- shell.tasks has a task, first press calls create_background_task
- `test_double_ctrl_c_kills_all` -- shell.tasks has 2 tasks, two presses within threshold cancel both tasks

**TestSubprocessCleanup class:**
- `test_ai_kills_process_on_cancel` -- mock create_subprocess_exec, cancel the task, assert process.kill() was called
- `test_bash_kills_process_on_cancel` -- mock create_subprocess_shell, cancel the task, assert proc.kill() was called

**TestShellToolbar class:**
- `test_shell_has_toolbar_in_namespace` -- CortexShell (mocked enough to construct) has self.namespace["toolbar"] as ToolbarConfig
- `test_toolbar_has_builtin_widgets` -- toolbar.widgets contains "mode", "tasks", "cwd"

Use `unittest.mock` (MagicMock, AsyncMock, patch) extensively. Use `pytest.mark.asyncio` for async tests. Match test style from tests/repl/test_channels.py (fixtures, docstrings on every test, clear assertions).

For subprocess cleanup tests: use `asyncio.create_task()` + `task.cancel()` + `await asyncio.sleep(0)` to trigger cancellation.

Commit: `test(19-02): add task lifecycle and interrupt routing tests`
  </action>
  <verify>`pytest tests/repl/test_task_lifecycle.py -v` -- all tests pass with pristine output</verify>
  <done>
- 11+ test cases covering task tracking, interrupt routing, subprocess cleanup, toolbar wiring
- All tests pass
- No unexpected output or warnings
  </done>
</task>

</tasks>

<verification>
```bash
# All new tests pass
pytest tests/repl/test_toolbar.py tests/repl/test_task_lifecycle.py -v

# Existing tests still pass
pytest tests/ -v

# Module imports clean
python -c "from bae.repl.shell import CortexShell; from bae.repl.toolbar import ToolbarConfig; print('all OK')"
```
</verification>

<success_criteria>
- Ctrl-C with tasks running triggers kill menu (key binding wired)
- Double Ctrl-C within 0.4s cancels all tasks (timestamp guard works)
- Ctrl-C with no tasks exits REPL (REPL-12 preserved)
- Cancelled subprocesses are killed (no orphan processes)
- Toolbar renders via ToolbarConfig with mode, tasks, cwd widgets
- toolbar object accessible in namespace for user customization
- All existing tests still pass
- New tests pass with pristine output
</success_criteria>

<output>
After completion, create `.planning/phases/19-task-lifecycle/19-02-SUMMARY.md`
</output>
