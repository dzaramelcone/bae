---
phase: 19-task-lifecycle
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/repl/toolbar.py
  - tests/repl/test_toolbar.py
autonomous: true

must_haves:
  truths:
    - "ToolbarConfig.add() registers a named widget callable"
    - "ToolbarConfig.remove() unregisters a widget by name"
    - "ToolbarConfig.render() returns flat list of style tuples from all widgets in order"
    - "ToolbarConfig.render() catches widget exceptions and shows [name:err] instead of crashing"
    - "ToolbarConfig.widgets property returns ordered widget names"
    - "Built-in widget factories produce correct style tuples"
  artifacts:
    - path: "bae/repl/toolbar.py"
      provides: "ToolbarConfig class + built-in widget factories"
      exports: ["ToolbarConfig", "ToolbarWidget", "make_mode_widget", "make_tasks_widget", "make_cwd_widget"]
    - path: "tests/repl/test_toolbar.py"
      provides: "Unit tests for ToolbarConfig and built-in widgets"
  key_links:
    - from: "bae/repl/toolbar.py"
      to: "bae/repl/modes.py"
      via: "make_mode_widget imports MODE_NAMES"
      pattern: "from bae\\.repl\\.modes import MODE_NAMES"
---

<objective>
TDD the ToolbarConfig class: a user-configurable toolbar with named widgets that return prompt_toolkit style tuples.

Purpose: REPL-06 requires user-configurable prompt content. ToolbarConfig provides the extensible foundation -- users register callable widgets (CPU load, task count, cost accumulator) that render into the bottom toolbar. Built-in widgets cover mode name, running task count, and cwd.

Output: `bae/repl/toolbar.py` with ToolbarConfig + widget factories, `tests/repl/test_toolbar.py` with full unit tests.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-task-lifecycle/19-RESEARCH.md
@bae/repl/modes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for ToolbarConfig</name>
  <files>tests/repl/test_toolbar.py</files>
  <action>
Create `tests/repl/test_toolbar.py` with these test cases:

**TestToolbarConfig class:**
- `test_add_registers_widget` -- add("x", fn), assert "x" in config.widgets
- `test_add_replaces_existing` -- add("x", fn1), add("x", fn2), render should use fn2, order unchanged
- `test_remove_unregisters` -- add("x", fn), remove("x"), assert "x" not in config.widgets
- `test_remove_nonexistent_noop` -- remove("x") should not raise
- `test_render_returns_flat_tuples` -- add two widgets returning [("", "a")] and [("", "b")], render() == [("", "a"), ("", "b")]
- `test_render_preserves_order` -- add("a", ...), add("b", ...), render returns a's tuples before b's
- `test_render_catches_exception` -- add a widget that raises ValueError, render returns [("fg:red", " [name:err] ")] for that widget
- `test_render_empty` -- no widgets, render() == []
- `test_widgets_property` -- add("a", ...), add("b", ...), widgets == ["a", "b"]
- `test_repr` -- repr includes widget names

**TestBuiltinWidgets class:**
- `test_make_mode_widget` -- mock shell with mode=Mode.PY, widget returns [("class:toolbar.mode", " Py ")]
- `test_make_tasks_widget_empty` -- mock shell with tasks=set(), widget returns []
- `test_make_tasks_widget_with_tasks` -- mock shell with 2 tasks, widget returns [("class:toolbar.tasks", " 2 tasks ")]
- `test_make_tasks_widget_singular` -- mock shell with 1 task, widget returns [("class:toolbar.tasks", " 1 task ")]
- `test_make_cwd_widget` -- patch os.getcwd/expanduser, widget returns [("class:toolbar.cwd", " ~/lab/bae ")]

Use MagicMock for shell objects. Use `from types import SimpleNamespace` for lightweight mocks where appropriate.

Run tests -- they MUST fail (RED). Commit: `test(19-01): add failing tests for ToolbarConfig`
  </action>
  <verify>`pytest tests/repl/test_toolbar.py` -- all tests must FAIL with ImportError (module not yet created)</verify>
  <done>Test file exists with 15+ test cases, all failing because bae.repl.toolbar does not exist yet</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement ToolbarConfig and built-in widgets</name>
  <files>bae/repl/toolbar.py</files>
  <action>
Create `bae/repl/toolbar.py`:

**Type alias:**
```python
ToolbarWidget = Callable[[], list[tuple[str, str]]]
```

**ToolbarConfig class:**
- `__init__`: `self._widgets: dict[str, ToolbarWidget] = {}`, `self._order: list[str] = []`
- `add(name, widget)`: if name not in _widgets, append to _order. Always update _widgets[name].
- `remove(name)`: pop from _widgets, remove from _order if present.
- `widgets` property: return list copy of _order.
- `render()`: iterate _order, call each widget in try/except, extend parts list. On exception, append `("fg:red", f" [{name}:err] ")`.
- `__repr__`: show widget names, hint at .add/.remove API.

**Built-in widget factories:**
- `make_mode_widget(shell)`: returns lambda using MODE_NAMES[shell.mode]. Import MODE_NAMES inside the factory to avoid circular import.
- `make_tasks_widget(shell)`: returns closure checking len(shell.tasks). Returns empty list when 0, singular "task" for 1, plural "tasks" for 2+.
- `make_cwd_widget()`: returns closure using os.getcwd() with home-relative path.

Match the code style from the research section (Pattern 4). Use `from __future__ import annotations`. Module docstring explaining the purpose.

Run tests -- all MUST pass (GREEN). Commit: `feat(19-01): implement ToolbarConfig with built-in widgets`
  </action>
  <verify>`pytest tests/repl/test_toolbar.py -v` -- all tests pass</verify>
  <done>ToolbarConfig class exists with add/remove/render/widgets/repr. Three built-in widget factories exist. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
pytest tests/repl/test_toolbar.py -v
python -c "from bae.repl.toolbar import ToolbarConfig, make_mode_widget, make_tasks_widget, make_cwd_widget; print('imports OK')"
```
</verification>

<success_criteria>
- ToolbarConfig is importable with add/remove/render/widgets API
- Built-in widget factories produce correct prompt_toolkit style tuples
- Exception in user widget is caught and displayed as [name:err]
- All tests pass with pristine output
</success_criteria>

<output>
After completion, create `.planning/phases/19-task-lifecycle/19-01-SUMMARY.md`
</output>
