---
phase: 19-task-lifecycle
plan: 05
type: execute
wave: 2
depends_on: [19-04]
files_modified:
  - bae/repl/shell.py
  - bae/repl/ai.py
  - bae/repl/bash.py
  - bae/repl/exec.py
  - bae/repl/toolbar.py
  - tests/repl/test_task_lifecycle.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Ctrl-C with running tasks switches toolbar to a numbered task list ordered by age; pressing a digit key cancels that task"
    - "Ctrl-C while task menu is open cancels all running tasks"
    - "Esc while task menu is open returns to normal toolbar"
    - "Left/Right arrow keys paginate the task list when more than 5 tasks are running"
    - "PY mode async expressions (await asyncio.sleep(N)) appear in TaskManager and are cancellable via Ctrl-C"
    - "Subprocesses spawned with start_new_session=True so os.killpg() kills entire process tree"
    - "shell.tasks set replaced by shell.tm (TaskManager instance)"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "Task menu in toolbar, digit/esc/arrow key bindings, TaskManager wiring, PY async tracking"
      contains: "_task_menu"
    - path: "bae/repl/ai.py"
      provides: "start_new_session=True + tm.register_process()"
    - path: "bae/repl/bash.py"
      provides: "start_new_session=True + tm.register_process()"
    - path: "bae/repl/exec.py"
      provides: "Returns unawaited coroutine for async expressions"
    - path: "bae/repl/toolbar.py"
      provides: "Toolbar renders task menu when _task_menu is True, normal widgets otherwise"
    - path: "tests/repl/test_task_lifecycle.py"
      provides: "Tests for task menu, digit key cancel, pagination, PY async tracking"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/tasks.py"
      via: "shell.tm = TaskManager(), shell.tm.submit() replaces shell._track_task()"
      pattern: "self\\.tm\\.submit"
    - from: "bae/repl/ai.py"
      to: "bae/repl/tasks.py"
      via: "tm.register_process(process) after subprocess spawn"
      pattern: "register_process"
    - from: "bae/repl/bash.py"
      to: "bae/repl/tasks.py"
      via: "tm.register_process(process) after subprocess spawn"
      pattern: "register_process"
    - from: "bae/repl/toolbar.py"
      to: "bae/repl/tasks.py"
      via: "Toolbar renders TaskManager.active() as numbered list in task menu mode"
      pattern: "tm\\.active"
    - from: "bae/repl/shell.py _dispatch PY"
      to: "bae/repl/exec.py async_exec"
      via: "Returns coroutine for async code, tracked via tm.submit()"
      pattern: "iscoroutine.*submit"
---

<objective>
Wire TaskManager into CortexShell and implement the task menu UX:

1. Ctrl-C switches the bottom toolbar from normal widgets to a numbered task list. Digit keys (1-9) cancel the corresponding task. Ctrl-C again kills all. Esc dismisses. Left/Right paginate (5 tasks per page).

2. PY async expressions tracked via TaskManager so they appear in toolbar and task menu.

3. Process groups (start_new_session=True) for clean subprocess tree kill.

Purpose: Close 3 remaining UAT issues and ship Phase 19.
Output: Task menu in toolbar, PY async tracking, process group cleanup, all tests green.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/19-task-lifecycle/19-04-SUMMARY.md

@bae/repl/tasks.py
@bae/repl/shell.py
@bae/repl/ai.py
@bae/repl/bash.py
@bae/repl/exec.py
@bae/repl/toolbar.py
@tests/repl/test_task_lifecycle.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Process groups + TaskManager registration in ai.py and bash.py</name>
  <files>
    bae/repl/ai.py
    bae/repl/bash.py
  </files>
  <action>
**A. Process groups in ai.py**

In `AI.__call__`, add `start_new_session=True` to `asyncio.create_subprocess_exec()`:

```python
process = await asyncio.create_subprocess_exec(
    *cmd,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE,
    env=env,
    start_new_session=True,
)
```

Add `tm` parameter to `AI.__init__`:

```python
def __init__(self, *, lm, router, namespace, tm=None, model=..., timeout=...):
    ...
    self._tm = tm
```

After `create_subprocess_exec`, register:
```python
if self._tm is not None:
    self._tm.register_process(process)
```

**B. Process groups in bash.py**

In `dispatch_bash`, add `start_new_session=True` to `asyncio.create_subprocess_shell()`:

```python
proc = await asyncio.create_subprocess_shell(
    cmd,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE,
    cwd=os.getcwd(),
    start_new_session=True,
)
```

Add `tm` parameter to `dispatch_bash`:

```python
async def dispatch_bash(cmd: str, *, tm=None) -> tuple[str, str]:
```

After `create_subprocess_shell`, register:
```python
if tm is not None:
    tm.register_process(proc)
```

Keep existing CancelledError handlers as safety net.
  </action>
  <verify>
Run `python -m pytest tests/repl/test_task_lifecycle.py -v` -- existing tests pass.

Run `python -c "import inspect; from bae.repl.bash import dispatch_bash; sig = inspect.signature(dispatch_bash); assert 'tm' in sig.parameters; print('OK')"`

Run `python -c "import inspect; from bae.repl.ai import AI; sig = inspect.signature(AI.__init__); assert 'tm' in sig.parameters; print('OK')"`
  </verify>
  <done>
1. ai.py: start_new_session=True + tm.register_process(process).
2. bash.py: start_new_session=True + tm.register_process(proc).
3. Both accept optional tm parameter (None = no registration).
4. Existing CancelledError handlers preserved as safety net.
  </done>
</task>

<task type="auto">
  <name>Task 2: Shell + toolbar integration -- TaskManager wiring, task menu, PY async tracking</name>
  <files>
    bae/repl/shell.py
    bae/repl/exec.py
    bae/repl/toolbar.py
    tests/repl/test_task_lifecycle.py
  </files>
  <action>
**A. Replace shell.tasks with TaskManager (bae/repl/shell.py)**

1. Import: `from bae.repl.tasks import TaskManager`

2. In `__init__`, replace `self.tasks: set[asyncio.Task] = set()` with:
```python
self.tm = TaskManager()
self._task_menu = False
self._task_menu_page = 0
```

3. Pass `tm=self.tm` to AI:
```python
self.ai = AI(lm=ClaudeCLIBackend(), router=self.router, namespace=self.namespace, tm=self.tm)
```

4. Delete `_track_task` method entirely.

5. In `_run_bash`, pass `tm=self.tm`:
```python
stdout, stderr = await dispatch_bash(text, tm=self.tm)
```

6. Update `_dispatch` NL/GRAPH/BASH to use `self.tm.submit()`:
```python
elif self.mode == Mode.NL:
    self.tm.submit(self._run_nl(text), name=f"ai:{text[:30]}", mode="nl")
elif self.mode == Mode.GRAPH:
    self.tm.submit(self._run_graph(text), name=f"graph:{text[:30]}", mode="graph")
elif self.mode == Mode.BASH:
    self.tm.submit(self._run_bash(text), name=f"bash:{text[:30]}", mode="bash")
```

**B. Task menu in toolbar (bae/repl/toolbar.py)**

Add a constant and a rendering function to toolbar.py:

```python
TASKS_PER_PAGE = 5

def render_task_menu(tm, page: int = 0) -> list[tuple[str, str]]:
    """Render numbered task list for the task menu, with pagination."""
    active = tm.active()
    if not active:
        return [("fg:#808080", " no tasks running ")]

    total_pages = (len(active) + TASKS_PER_PAGE - 1) // TASKS_PER_PAGE
    page = min(page, total_pages - 1)
    start = page * TASKS_PER_PAGE
    page_tasks = active[start:start + TASKS_PER_PAGE]

    parts: list[tuple[str, str]] = []
    for i, tt in enumerate(page_tasks, start=1):
        parts.append(("bold fg:ansiyellow", f" {i}"))
        parts.append(("", f" {tt.name} "))

    # Controls line
    parts.append(("fg:#808080", " | "))
    parts.append(("fg:#808080", "#=cancel "))
    parts.append(("fg:#808080 bold", "^C"))
    parts.append(("fg:#808080", "=all "))
    parts.append(("fg:#808080 bold", "esc"))
    parts.append(("fg:#808080", "=back"))

    if total_pages > 1:
        parts.append(("fg:#808080", f" ←/→ {page + 1}/{total_pages}"))

    return parts
```

Update `make_tasks_widget` to query TaskManager:
```python
def make_tasks_widget(shell) -> ToolbarWidget:
    def widget():
        n = len(shell.tm.active())
        if n == 0:
            return []
        return [("class:toolbar.tasks", f" {n} task{'s' if n != 1 else ''} ")]
    return widget
```

**C. Update _toolbar() to switch between modes (bae/repl/shell.py)**

```python
def _toolbar(self):
    if self._task_menu:
        from bae.repl.toolbar import render_task_menu
        return render_task_menu(self.tm, self._task_menu_page)
    return self.toolbar.render()
```

**D. Update key bindings (bae/repl/shell.py)**

Delete the `_show_kill_menu` function entirely.

In `_build_key_bindings`, add a filter and new bindings:

```python
from prompt_toolkit.filters import Condition

task_menu_active = Condition(lambda: shell._task_menu)

@kb.add("c-c", eager=True)
def handle_interrupt(event):
    """Ctrl-C: exit if idle, kill-all if task menu open, open task menu if tasks running."""
    if shell._task_menu:
        # Second Ctrl-C while menu is open: kill all
        shell.tm.revoke_all(graceful=False)
        shell._task_menu = False
        shell._task_menu_page = 0
        shell.router.write("debug", "killed all tasks", mode="DEBUG")
        event.app.invalidate()
        return
    if not shell.tm.active():
        event.app.exit(exception=KeyboardInterrupt())
        return
    # First Ctrl-C with tasks: open task menu
    shell._task_menu = True
    shell._task_menu_page = 0
    event.app.invalidate()

@kb.add("escape", eager=True, filter=task_menu_active)
def dismiss_task_menu(event):
    """Esc: close task menu, return to normal toolbar."""
    shell._task_menu = False
    shell._task_menu_page = 0
    event.app.invalidate()

@kb.add("left", filter=task_menu_active)
def task_menu_prev_page(event):
    """Left arrow: previous page."""
    if shell._task_menu_page > 0:
        shell._task_menu_page -= 1
        event.app.invalidate()

@kb.add("right", filter=task_menu_active)
def task_menu_next_page(event):
    """Right arrow: next page."""
    active = shell.tm.active()
    from bae.repl.toolbar import TASKS_PER_PAGE
    total_pages = (len(active) + TASKS_PER_PAGE - 1) // TASKS_PER_PAGE
    if shell._task_menu_page < total_pages - 1:
        shell._task_menu_page += 1
        event.app.invalidate()
```

Add digit key bindings (1-5, matching TASKS_PER_PAGE):

```python
for digit in "12345":
    @kb.add(digit, filter=task_menu_active)
    def cancel_by_digit(event, _d=digit):
        """Digit key: cancel task at that position on current page."""
        from bae.repl.toolbar import TASKS_PER_PAGE
        idx = int(_d) - 1
        active = shell.tm.active()
        offset = shell._task_menu_page * TASKS_PER_PAGE
        pos = offset + idx
        if pos < len(active):
            tt = active[pos]
            shell.tm.revoke(tt.task_id)
            shell.router.write("debug", f"cancelled {tt.name}", mode="DEBUG")
        # If no tasks left, close menu
        if not shell.tm.active():
            shell._task_menu = False
            shell._task_menu_page = 0
        event.app.invalidate()
```

Remove the old double-press timing logic (`_last_sigint`, `DOUBLE_PRESS_THRESHOLD`). The new model is simpler: first Ctrl-C opens menu, second Ctrl-C (menu already open) kills all. No timing needed.

**E. PY async tracking (bae/repl/exec.py + bae/repl/shell.py)**

In `async_exec`, when `asyncio.iscoroutine(result)`, do NOT await. Return the raw coroutine:

```python
result = fn()
if asyncio.iscoroutine(result):
    return result, captured   # caller tracks and awaits
```

In `_dispatch` PY mode, detect coroutines and track:

```python
if self.mode == Mode.PY:
    try:
        result, captured = await async_exec(text, self.namespace)
        if captured:
            self.router.write("py", captured.rstrip("\n"), mode="PY", metadata={"type": "stdout"})
        if asyncio.iscoroutine(result):
            async def _py_task(coro):
                try:
                    val = await coro
                    if val is not None:
                        self.router.write("py", repr(val), mode="PY", metadata={"type": "expr_result"})
                except asyncio.CancelledError:
                    self.router.write("debug", "cancelled py task", mode="DEBUG")
                except Exception:
                    tb = traceback.format_exc()
                    self.router.write("py", tb.rstrip("\n"), mode="PY", metadata={"type": "error"})
            self.tm.submit(_py_task(result), name=f"py:{text[:30]}", mode="py")
        elif result is not None:
            self.router.write("py", repr(result), mode="PY", metadata={"type": "expr_result"})
    except KeyboardInterrupt:
        pass
    except Exception:
        tb = traceback.format_exc()
        self.router.write("py", tb.rstrip("\n"), mode="PY", metadata={"type": "error"})
```

**F. Update _shutdown and run() exception handlers**

```python
async def _shutdown(self) -> None:
    self.store.close()
    await self.tm.shutdown()
```

In `run()`, update KeyboardInterrupt handler:
```python
except KeyboardInterrupt:
    self.tm.revoke_all(graceful=False)
    self.router.write("debug", "interrupted, revoked all tasks", mode="DEBUG")
```

**G. Cleanup**

- Remove `DOUBLE_PRESS_THRESHOLD` constant
- Remove `_last_sigint` from `_build_key_bindings`
- Remove `_show_kill_menu` function
- Remove `from prompt_toolkit.shortcuts import checkboxlist_dialog` (if present)
- Remove `_track_task` method
- Remove `import time` if no longer used

**H. Tests (tests/repl/test_task_lifecycle.py)**

Update tests for TaskManager + task menu:

1. **TestSubmit** (replaces TestTrackTask):
   - `test_submit_creates_tracked_task`: `shell.tm.submit(coro, name="test", mode="nl")` returns TrackedTask with RUNNING state.
   - `test_submit_removes_on_completion`: After task completes, `shell.tm.active()` is empty.
   - `test_submit_sets_name`: TrackedTask.name matches.

2. **TestInterruptHandler**:
   - `test_ctrl_c_no_tasks_exits`: No active tasks -> exit.
   - `test_ctrl_c_opens_task_menu`: Tasks running -> sets `shell._task_menu = True`.
   - `test_ctrl_c_in_menu_kills_all`: `shell._task_menu = True` + Ctrl-C -> `tm.revoke_all()` called, `_task_menu = False`.

3. **TestTaskMenu**:
   - `test_toolbar_renders_task_menu`: `_task_menu=True` -> `_toolbar()` returns `render_task_menu()` output.
   - `test_toolbar_renders_normal`: `_task_menu=False` -> `_toolbar()` returns normal toolbar.
   - `test_digit_cancels_task`: With task menu open, simulate digit "1" key -> `tm.revoke(task_id)` called.
   - `test_esc_dismisses_menu`: Simulate Esc -> `_task_menu = False`.
   - `test_pagination_left_right`: With >5 tasks, left/right change `_task_menu_page`.
   - `test_menu_closes_when_empty`: After cancelling last task, `_task_menu` auto-closes.

4. **TestBackgroundDispatch**: Update to use `shell.tm.active()`.
   - `test_dispatch_nl_returns_immediately`
   - `test_dispatch_bash_returns_immediately`
   - `test_dispatch_py_blocks` (sync PY unchanged)
   - **NEW** `test_dispatch_py_async_tracked`: `await asyncio.sleep(10)` -> `shell.tm.active()` has 1 task with mode="py".

5. **TestSubprocessCleanup**: Keep existing. CancelledError safety net tests.

6. Remove `test_kill_menu_cancelled_dialog_no_crash` (no dialog).
  </action>
  <verify>
Run `python -m pytest tests/repl/test_task_lifecycle.py tests/repl/test_task_manager.py tests/repl/test_toolbar.py -v` -- all pass.

Run `python -m pytest tests/repl/ -v` -- all repl tests pass, zero regressions.

Verify no checkboxlist_dialog: `! grep -q "checkboxlist_dialog" bae/repl/shell.py`

Verify no shell.tasks set: `! grep -q "self\.tasks" bae/repl/shell.py`

Verify start_new_session: `grep -q "start_new_session=True" bae/repl/ai.py && grep -q "start_new_session=True" bae/repl/bash.py`
  </verify>
  <done>
1. shell.tm replaces shell.tasks throughout.
2. Ctrl-C opens task menu in toolbar -- numbered list, digit keys cancel, Esc dismisses.
3. Ctrl-C while menu open kills all tasks.
4. Left/Right paginate at 5 tasks per page.
5. PY async expressions tracked via tm.submit(), visible in toolbar and task menu.
6. Subprocesses use start_new_session=True; tm.register_process() called after spawn.
7. Toolbar switches between normal widgets and task menu based on _task_menu flag.
8. All tests updated, zero regressions.
  </done>
</task>

</tasks>

<verification>
```bash
# All repl tests pass
python -m pytest tests/repl/ -v

# No checkboxlist_dialog in shell.py
! grep -q "checkboxlist_dialog" bae/repl/shell.py

# No shell.tasks bare set
! grep -q "self\.tasks" bae/repl/shell.py

# Process groups enabled
grep -q "start_new_session=True" bae/repl/ai.py
grep -q "start_new_session=True" bae/repl/bash.py

# Task menu state exists
python -c "
from unittest.mock import patch
with patch('bae.repl.shell.SessionStore'), \
     patch('bae.repl.shell.PromptSession'), \
     patch('bae.repl.shell.NamespaceCompleter'), \
     patch('bae.lm.ClaudeCLIBackend'):
    from bae.repl.shell import CortexShell
    from bae.repl.tasks import TaskManager
    s = CortexShell()
    assert isinstance(s.tm, TaskManager)
    assert hasattr(s, '_task_menu')
    assert hasattr(s, '_task_menu_page')
    print('OK')
"

# async_exec returns coroutine for async code
python -c "
import asyncio
from bae.repl.exec import async_exec

async def check():
    result, captured = await async_exec('await asyncio.sleep(0)', {'asyncio': asyncio})
    assert asyncio.iscoroutine(result), f'Expected coroutine, got {type(result)}'
    await result
    print('OK: async_exec returns coroutine')

asyncio.run(check())
"
```
</verification>

<success_criteria>
- shell.tm is a TaskManager instance; shell.tasks (bare set) is removed
- Ctrl-C with tasks opens task menu in toolbar (numbered list ordered by age)
- Digit key (1-5) cancels corresponding task on current page
- Ctrl-C while task menu open calls tm.revoke_all()
- Esc closes task menu, returns to normal toolbar
- Left/Right paginate at 5 tasks per page
- PY async expressions tracked as cancellable tasks in TaskManager
- Subprocesses spawned with start_new_session=True
- tm.register_process() called from ai.py and bash.py
- All repl tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/19-task-lifecycle/19-05-SUMMARY.md`
</output>
