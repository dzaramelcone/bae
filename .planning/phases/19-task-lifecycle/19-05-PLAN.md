---
phase: 19-task-lifecycle
plan: 05
type: execute
wave: 2
depends_on: [19-04]
files_modified:
  - bae/repl/shell.py
  - bae/repl/ai.py
  - bae/repl/bash.py
  - bae/repl/exec.py
  - bae/repl/toolbar.py
  - tests/repl/test_task_lifecycle.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Ctrl-C with running tasks prints an inline numbered task list; user enters a number at kill> prompt to cancel that task"
    - "Double Ctrl-C cancels all running tasks via TaskManager.revoke_all() and returns to bare prompt"
    - "PY mode async expressions (await asyncio.sleep(N)) appear in TaskManager and are cancellable via Ctrl-C"
    - "Subprocesses spawned with start_new_session=True so os.killpg() kills entire process tree"
    - "shell.tasks set replaced by shell.tm (TaskManager instance)"
    - "Toolbar tasks widget queries TaskManager.active() instead of len(shell.tasks)"
  artifacts:
    - path: "bae/repl/shell.py"
      provides: "Inline kill menu, _pending_kill state, TaskManager wiring, PY async tracking"
      contains: "_show_kill_menu"
    - path: "bae/repl/ai.py"
      provides: "start_new_session=True + tm.register_process()"
    - path: "bae/repl/bash.py"
      provides: "start_new_session=True + tm.register_process()"
    - path: "bae/repl/exec.py"
      provides: "Returns unawaited coroutine for async expressions"
    - path: "bae/repl/toolbar.py"
      provides: "make_tasks_widget queries TaskManager.active()"
    - path: "tests/repl/test_task_lifecycle.py"
      provides: "Updated tests for TaskManager integration, inline kill menu, PY async tracking"
  key_links:
    - from: "bae/repl/shell.py"
      to: "bae/repl/tasks.py"
      via: "shell.tm = TaskManager(), shell.tm.submit() replaces shell._track_task()"
      pattern: "self\\.tm\\.submit"
    - from: "bae/repl/ai.py"
      to: "bae/repl/tasks.py"
      via: "tm.register_process(process) after subprocess spawn"
      pattern: "register_process"
    - from: "bae/repl/bash.py"
      to: "bae/repl/tasks.py"
      via: "tm.register_process(process) after subprocess spawn"
      pattern: "register_process"
    - from: "bae/repl/shell.py _show_kill_menu"
      to: "print_formatted_text"
      via: "Inline rendering instead of checkboxlist_dialog"
      pattern: "print_formatted_text"
    - from: "bae/repl/shell.py _dispatch PY"
      to: "bae/repl/exec.py async_exec"
      via: "Returns coroutine for async code, tracked via tm.submit()"
      pattern: "iscoroutine.*submit"
---

<objective>
Wire TaskManager into CortexShell, replacing `shell.tasks` set. Implement inline kill menu, PY async task tracking, process groups, and update all consumers.

This plan addresses the 3 remaining UAT failures:
1. Kill menu is full-screen dialog -- replace with inline print + number selection at kill> prompt
2. PY async tasks not tracked -- async_exec returns coroutine, _dispatch wraps in tracked task
3. Double Ctrl-C broken by modal dialog -- inline menu is non-modal, second Ctrl-C fires normally

Purpose: Close all UAT issues and ship Phase 19.
Output: Working inline kill menu, PY async tracking, process group cleanup, all tests green.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-task-lifecycle/19-03-SUMMARY.md
@.planning/phases/19-task-lifecycle/19-04-SUMMARY.md

@bae/repl/tasks.py
@bae/repl/shell.py
@bae/repl/ai.py
@bae/repl/bash.py
@bae/repl/exec.py
@bae/repl/toolbar.py
@tests/repl/test_task_lifecycle.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Process groups + TaskManager registration in ai.py and bash.py</name>
  <files>
    bae/repl/ai.py
    bae/repl/bash.py
  </files>
  <action>
**A. Process groups in ai.py**

In `AI.__call__`, add `start_new_session=True` to `asyncio.create_subprocess_exec()`:

```python
process = await asyncio.create_subprocess_exec(
    *cmd,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE,
    env=env,
    start_new_session=True,
)
```

After creating the process, register it with TaskManager. The AI instance needs access to the TaskManager. Add a `tm` parameter to `AI.__init__`:

```python
def __init__(self, *, lm, router, namespace, tm=None, model=..., timeout=...):
    ...
    self._tm = tm
```

After `create_subprocess_exec`, call:
```python
if self._tm is not None:
    self._tm.register_process(process)
```

This is safe to call from inside a running task because `register_process` uses `asyncio.current_task()` to find the TrackedTask. If the AI is called outside a tracked task, register_process is a no-op.

**B. Process groups in bash.py**

In `dispatch_bash`, add `start_new_session=True` to `asyncio.create_subprocess_shell()`:

```python
proc = await asyncio.create_subprocess_shell(
    cmd,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE,
    cwd=os.getcwd(),
    start_new_session=True,
)
```

Add a `tm` parameter to `dispatch_bash`:

```python
async def dispatch_bash(cmd: str, *, tm=None) -> tuple[str, str]:
```

After `create_subprocess_shell`, call:
```python
if tm is not None:
    tm.register_process(proc)
```

Keep the existing CancelledError handler (proc.kill + wait + raise). The TaskManager kill via process group is the primary path; the CancelledError handler is a safety net.
  </action>
  <verify>
Run `python -m pytest tests/repl/test_task_lifecycle.py -v` -- existing subprocess cleanup tests still pass (they mock create_subprocess_exec/shell, so start_new_session doesn't affect them).

Run `python -c "import inspect; from bae.repl.bash import dispatch_bash; sig = inspect.signature(dispatch_bash); assert 'tm' in sig.parameters; print('OK')"` -- tm parameter exists.

Run `python -c "import inspect; from bae.repl.ai import AI; sig = inspect.signature(AI.__init__); assert 'tm' in sig.parameters; print('OK')"` -- tm parameter exists.
  </verify>
  <done>
1. ai.py spawns subprocess with `start_new_session=True` and calls `tm.register_process(process)`.
2. bash.py spawns subprocess with `start_new_session=True` and calls `tm.register_process(proc)`.
3. Both accept optional `tm` parameter (backward compatible -- None means no registration).
4. Existing CancelledError cleanup handlers preserved as safety net.
  </done>
</task>

<task type="auto">
  <name>Task 2: Shell integration -- TaskManager, inline kill menu, PY async tracking</name>
  <files>
    bae/repl/shell.py
    bae/repl/exec.py
    bae/repl/toolbar.py
    tests/repl/test_task_lifecycle.py
  </files>
  <action>
**A. Replace shell.tasks with TaskManager (bae/repl/shell.py)**

1. Import TaskManager: `from bae.repl.tasks import TaskManager`

2. In `__init__`, replace `self.tasks: set[asyncio.Task] = set()` with `self.tm = TaskManager()`.

3. Pass `tm=self.tm` to AI constructor:
```python
self.ai = AI(lm=ClaudeCLIBackend(), router=self.router, namespace=self.namespace, tm=self.tm)
```

4. Delete `_track_task` method entirely. All callers now use `self.tm.submit()`.

5. In `_run_bash`, pass `tm=self.tm` to `dispatch_bash`:
```python
stdout, stderr = await dispatch_bash(text, tm=self.tm)
```

6. Update `_dispatch` NL/GRAPH/BASH to use `self.tm.submit()`:
```python
elif self.mode == Mode.NL:
    self.tm.submit(self._run_nl(text), name=f"ai:{text[:30]}", mode="nl")
elif self.mode == Mode.GRAPH:
    self.tm.submit(self._run_graph(text), name=f"graph:{text[:30]}", mode="graph")
elif self.mode == Mode.BASH:
    self.tm.submit(self._run_bash(text), name=f"bash:{text[:30]}", mode="bash")
```

7. Add `self._pending_kill: list | None = None` to `__init__`.

**B. Inline kill menu (bae/repl/shell.py)**

Replace `_show_kill_menu` completely. Remove `checkboxlist_dialog` import. New implementation:

```python
def _show_kill_menu(shell: CortexShell) -> None:
    """Print inline task list; next prompt input selects task to cancel."""
    active = shell.tm.active()
    if not active:
        return
    from prompt_toolkit import print_formatted_text
    from prompt_toolkit.formatted_text import FormattedText

    print_formatted_text(FormattedText([("fg:ansiyellow bold", "running tasks:")]))
    for tt in active:
        print_formatted_text(FormattedText([
            ("bold", f"  {tt.task_id}"),
            ("", f"  {tt.name}"),
        ]))
    print_formatted_text(FormattedText([
        ("fg:#808080", "  enter number to cancel, "),
        ("fg:#808080 bold", "a"),
        ("fg:#808080", "=all, "),
        ("fg:#808080 bold", "enter"),
        ("fg:#808080", "=dismiss"),
    ]))
    shell._pending_kill = True
```

This is now a SYNCHRONOUS function (not async). It prints and returns. No dialog, no await.

**C. Update Ctrl-C handler**

In `_build_key_bindings`, update the `handle_interrupt` handler:

```python
@kb.add("c-c", eager=True)
def handle_interrupt(event):
    """Ctrl-C: exit if idle, kill-all on double-press, kill menu on single."""
    if not shell.tm.active():
        event.app.exit(exception=KeyboardInterrupt())
        return
    now = time.monotonic()
    elapsed = now - _last_sigint[0]
    _last_sigint[0] = now
    if elapsed < DOUBLE_PRESS_THRESHOLD:
        shell.tm.revoke_all(graceful=False)
        shell._pending_kill = None
        shell.router.write("debug", f"killed all tasks", mode="DEBUG")
    else:
        _show_kill_menu(shell)
```

Key changes:
- `shell.tm.active()` instead of `shell.tasks`
- `shell.tm.revoke_all()` instead of iterating and cancelling
- `_show_kill_menu(shell)` called directly (not via create_background_task -- it's synchronous now)
- Clear `_pending_kill` on double Ctrl-C

**D. Update prompt and run loop for kill selection**

In `_prompt()`, when `_pending_kill` is set, show kill prompt:
```python
def _prompt(self):
    if self._pending_kill:
        return [("fg:ansiyellow", "kill> ")]
    color = MODE_COLORS[self.mode]
    return [("fg:" + color, "> ")]
```

In `run()`, after `prompt_async()` returns text, check `_pending_kill` BEFORE dispatching:
```python
text = await self.session.prompt_async()
...
if self._pending_kill:
    text = text.strip()
    if text == "a":
        self.tm.revoke_all(graceful=True)
        self.router.write("debug", "killed all tasks", mode="DEBUG")
    elif text.isdigit():
        task_id = int(text)
        self.tm.revoke(task_id, graceful=True)
        self.router.write("debug", f"killed task {task_id}", mode="DEBUG")
    self._pending_kill = None
    continue
```

Any non-matching input (including empty Enter) dismisses. After handling, set `_pending_kill = None` and `continue`.

**E. PY async tracking (bae/repl/exec.py + bae/repl/shell.py)**

In `async_exec`, when `asyncio.iscoroutine(result)` is true, do NOT await it. Return the raw coroutine:

```python
result = fn()
if asyncio.iscoroutine(result):
    return result, captured   # caller tracks and awaits
```

Remove the `await result` line that currently awaits coroutines.

In `_dispatch` PY mode, after calling `async_exec`, check if result is a coroutine:

```python
if self.mode == Mode.PY:
    try:
        result, captured = await async_exec(text, self.namespace)
        if captured:
            self.router.write("py", captured.rstrip("\n"), mode="PY", metadata={"type": "stdout"})
        if asyncio.iscoroutine(result):
            async def _py_task(coro):
                try:
                    val = await coro
                    if val is not None:
                        self.router.write("py", repr(val), mode="PY", metadata={"type": "expr_result"})
                except asyncio.CancelledError:
                    self.router.write("debug", "cancelled py task", mode="DEBUG")
                except Exception:
                    tb = traceback.format_exc()
                    self.router.write("py", tb.rstrip("\n"), mode="PY", metadata={"type": "error"})
            self.tm.submit(_py_task(result), name=f"py:{text[:30]}", mode="py")
        elif result is not None:
            output = repr(result)
            self.router.write("py", output, mode="PY", metadata={"type": "expr_result"})
    except KeyboardInterrupt:
        pass
    except Exception:
        tb = traceback.format_exc()
        self.router.write("py", tb.rstrip("\n"), mode="PY", metadata={"type": "error"})
```

Synchronous PY expressions (`1+1`) still execute inline. Async PY expressions (`await asyncio.sleep(25)`) return coroutines that get tracked via TaskManager.

**F. Update toolbar (bae/repl/toolbar.py)**

Update `make_tasks_widget` to query TaskManager instead of shell.tasks:

```python
def make_tasks_widget(shell) -> ToolbarWidget:
    """Built-in widget: running task count (hidden when zero)."""
    def widget():
        n = len(shell.tm.active())
        if n == 0:
            return []
        return [("class:toolbar.tasks", f" {n} task{'s' if n != 1 else ''} ")]
    return widget
```

**G. Update _shutdown**

Replace `_shutdown` to use TaskManager:
```python
async def _shutdown(self) -> None:
    """Cancel tasks, close store, report summary."""
    self.store.close()
    await self.tm.shutdown()
```

**H. Update run() KeyboardInterrupt handler**

In `run()`, update the KeyboardInterrupt handler at the bottom:
```python
except KeyboardInterrupt:
    self.tm.revoke_all(graceful=False)
    self.router.write("debug", "interrupted, revoked all tasks", mode="DEBUG")
```

**I. Tests (tests/repl/test_task_lifecycle.py)**

Rewrite tests to work with TaskManager instead of shell.tasks:

1. Update `shell` fixture: no changes needed to fixture itself -- CortexShell now creates self.tm internally.

2. **TestTrackTask** -> rename to **TestSubmit**:
   - `test_submit_creates_tracked_task`: `shell.tm.submit(coro, name="test", mode="nl")` returns TrackedTask with state RUNNING.
   - `test_submit_removes_on_completion`: After task completes, `shell.tm.active()` is empty, state is SUCCESS.
   - `test_submit_sets_name`: TrackedTask.name matches what was passed.

3. **TestInterruptHandler**:
   - `test_ctrl_c_no_tasks_exits`: Use `shell.tm.active()` returning empty (already the case with fresh TaskManager).
   - `test_ctrl_c_with_tasks_shows_menu`: Submit a task via `shell.tm.submit()`, verify `_show_kill_menu` is called (it's synchronous now, not create_background_task). Check `shell._pending_kill is True`.
   - `test_double_ctrl_c_kills_all`: Submit tasks via `shell.tm.submit()`, verify `shell.tm.revoke_all` is called.

4. **TestKillMenu** -> **TestInlineKillMenu**:
   - `test_kill_menu_empty_no_output`: No active tasks -> `_show_kill_menu` returns without printing.
   - `test_kill_menu_prints_inline`: Active tasks -> prints via `print_formatted_text`, sets `_pending_kill`.
   - `test_pending_kill_number_cancels`: Simulate run loop: `_pending_kill=True`, text="1" -> `tm.revoke(1)` called.
   - `test_pending_kill_all`: text="a" -> `tm.revoke_all()` called.
   - `test_pending_kill_dismiss`: text="" -> `_pending_kill` cleared, no revoke.

5. **TestBackgroundDispatch**: Update to use `shell.tm.active()` and `shell.tm.submit()`.
   - `test_dispatch_nl_returns_immediately`: Check `len(shell.tm.active()) == 1` instead of `len(shell.tasks) == 1`.
   - `test_dispatch_bash_returns_immediately`: Same.
   - `test_dispatch_py_blocks`: Unchanged (PY sync still doesn't track).
   - **NEW** `test_dispatch_py_async_tracked`: Execute `await asyncio.sleep(10)` in PY mode -> `shell.tm.active()` has 1 task with mode="py".

6. **TestSubprocessCleanup**: Keep existing tests. They test the CancelledError safety net in ai.py/bash.py.

7. Remove old `test_kill_menu_cancelled_dialog_no_crash` (no more dialog to cancel).

Remove all references to `shell.tasks` (the bare set). All tests use `shell.tm`.
  </action>
  <verify>
Run `python -m pytest tests/repl/test_task_lifecycle.py tests/repl/test_task_manager.py tests/repl/test_toolbar.py -v` -- all tests pass.

Run `python -m pytest tests/repl/ -v` -- all repl tests pass, zero regressions.

Verify no checkboxlist_dialog in shell.py:
```bash
! grep -q "checkboxlist_dialog" bae/repl/shell.py
```

Verify shell.tasks set is gone:
```bash
! grep -q "self\.tasks" bae/repl/shell.py
```

Verify start_new_session in subprocess creation:
```bash
grep -q "start_new_session=True" bae/repl/ai.py
grep -q "start_new_session=True" bae/repl/bash.py
```
  </verify>
  <done>
1. `shell.tasks` set replaced by `shell.tm` (TaskManager instance) throughout shell.py.
2. `_show_kill_menu` prints task list inline via `print_formatted_text` -- no full-screen dialog.
3. Single Ctrl-C prints task list and sets `_pending_kill`; next prompt shows `kill>` and accepts number/a/enter.
4. Double Ctrl-C calls `tm.revoke_all(graceful=False)` -- works because inline menu is non-modal.
5. PY mode `await asyncio.sleep(N)` tracked via `tm.submit()`, visible in toolbar, cancellable via Ctrl-C.
6. Subprocesses created with `start_new_session=True`; `tm.register_process()` called after spawn.
7. Toolbar queries `shell.tm.active()` for task count.
8. All existing tests updated, new tests for inline menu and PY async tracking, zero regressions.
  </done>
</task>

</tasks>

<verification>
```bash
# All repl tests pass
python -m pytest tests/repl/ -v

# No checkboxlist_dialog in shell.py
! grep -q "checkboxlist_dialog" bae/repl/shell.py

# No shell.tasks bare set
! grep -q "self\.tasks" bae/repl/shell.py

# Process groups enabled
grep -q "start_new_session=True" bae/repl/ai.py
grep -q "start_new_session=True" bae/repl/bash.py

# TaskManager wired
python -c "
from unittest.mock import patch
with patch('bae.repl.shell.SessionStore'), \
     patch('bae.repl.shell.PromptSession'), \
     patch('bae.repl.shell.NamespaceCompleter'), \
     patch('bae.lm.ClaudeCLIBackend'):
    from bae.repl.shell import CortexShell
    from bae.repl.tasks import TaskManager
    s = CortexShell()
    assert isinstance(s.tm, TaskManager), 'shell.tm is not TaskManager'
    assert hasattr(s, '_pending_kill'), 'Missing _pending_kill'
    print('OK: TaskManager wired into shell')
"

# async_exec returns coroutine for async code
python -c "
import asyncio
from bae.repl.exec import async_exec

async def check():
    result, captured = await async_exec('await asyncio.sleep(0)', {'asyncio': asyncio})
    assert asyncio.iscoroutine(result), f'Expected coroutine, got {type(result)}'
    await result  # clean up
    print('OK: async_exec returns coroutine')

asyncio.run(check())
"
```
</verification>

<success_criteria>
- shell.tm is a TaskManager instance; shell.tasks (bare set) is removed
- _show_kill_menu uses inline print_formatted_text, not checkboxlist_dialog
- Single Ctrl-C prints task list and shows kill> prompt
- Double Ctrl-C calls tm.revoke_all() -- works because kill menu is non-modal
- PY async expressions tracked as cancellable tasks in TaskManager
- Subprocesses spawned with start_new_session=True for process group cleanup
- tm.register_process() called from ai.py and bash.py after subprocess spawn
- Toolbar queries tm.active() for task count
- All repl tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/19-task-lifecycle/19-05-SUMMARY.md`
</output>
