---
phase: 07-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/exceptions.py
  - bae/node.py
  - bae/lm.py
  - bae/__init__.py
  - tests/test_node_config.py
autonomous: true

must_haves:
  truths:
    - "DepError carries node_type, field_name attributes and formats as 'DepError: fn_name failed on NodeType.field_name'"
    - "FillError carries node_type, validation_errors, attempts attributes"
    - "Both DepError and FillError support exception chaining (raise from) and have a trace attribute"
    - "_wants_lm returns True when a __call__ parameter is type-hinted as LM, regardless of parameter name"
    - "_wants_lm returns False when no parameter has LM type hint, even if a parameter is named 'lm'"
  artifacts:
    - path: "bae/exceptions.py"
      provides: "DepError and FillError subclasses of BaeError"
      contains: "class DepError"
    - path: "bae/exceptions.py"
      provides: "FillError with structured attributes"
      contains: "class FillError"
    - path: "bae/node.py"
      provides: "Type-hint-based _wants_lm detection"
      contains: "get_type_hints"
    - path: "bae/lm.py"
      provides: "runtime_checkable LM Protocol"
      contains: "runtime_checkable"
    - path: "bae/__init__.py"
      provides: "DepError and FillError in package exports"
      contains: "DepError"
  key_links:
    - from: "bae/node.py"
      to: "bae/lm.py"
      via: "_wants_lm checks param type hint against LM Protocol"
      pattern: "hint is LM"
    - from: "bae/exceptions.py"
      to: "bae/exceptions.py"
      via: "DepError and FillError inherit from BaeError"
      pattern: "class DepError\\(BaeError\\)"
---

<objective>
Add DepError and FillError exception subclasses with structured attributes, and update _wants_lm from name-based to type-hint-based LM detection.

Purpose: Graph.run() v2 (Plan 02) needs structured error types for dep failures and fill validation failures. The v2 execution loop needs _wants_lm to detect LM protocol by type hint (not parameter name "lm") so any parameter name works.

Output: Updated exceptions.py, node.py, lm.py, __init__.py with new error types and type-hint-based _wants_lm.
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-integration/07-CONTEXT.md
@.planning/phases/07-integration/07-RESEARCH.md

@bae/exceptions.py
@bae/node.py
@bae/lm.py
@bae/__init__.py
@tests/test_node_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - DepError and FillError exception subclasses</name>
  <files>bae/exceptions.py, tests/test_node_config.py</files>
  <action>
RED phase: Write failing tests for DepError and FillError in a new test class in tests/test_node_config.py (or a dedicated test file if cleaner -- use judgment on whether exceptions deserve their own test file).

Test cases for DepError:
- `DepError("msg", node_type=SomeNode, field_name="user_data")` stores attributes
- `str(DepError(...))` formats as `"DepError: fn_name failed on NodeType.field_name (original_error)"`
- DepError is a subclass of BaeError
- `err.trace` attribute exists (defaults to None, settable)
- Exception chaining works: `raise DepError(...) from original` preserves __cause__

Test cases for FillError:
- `FillError("msg", node_type=SomeNode, validation_errors="field X required", attempts=3)` stores attributes
- `str(FillError(...))` includes node type name, attempt count, and last validation error
- FillError is a subclass of BaeError
- `err.trace` attribute exists (defaults to None, settable)

Run tests -- they MUST fail (classes don't exist yet).
Commit: `test(07-01): add failing tests for DepError and FillError`

GREEN phase: Implement DepError and FillError in bae/exceptions.py.

DepError:
```python
class DepError(BaeError):
    """Raised when a Dep function fails during field resolution."""
    def __init__(self, message: str, *, node_type: type | None = None,
                 field_name: str = "", cause: Exception | None = None):
        super().__init__(message, cause=cause)
        self.node_type = node_type
        self.field_name = field_name
        self.trace: list | None = None

    def __str__(self):
        # Format: "DepError: fn_name failed on NodeType.field_name (cause)"
        # Use self.args[0] as the message which already has the fn_name context
        return self.args[0]
```

FillError:
```python
class FillError(BaeError):
    """Raised when LM fill validation fails after retries."""
    def __init__(self, message: str, *, node_type: type | None = None,
                 validation_errors: str = "", attempts: int = 0,
                 cause: Exception | None = None):
        super().__init__(message, cause=cause)
        self.node_type = node_type
        self.validation_errors = validation_errors
        self.attempts = attempts
        self.trace: list | None = None
```

IMPORTANT: Keep the `__str__` terse + context per CONTEXT.md: `'DepError: fetch_user failed on AnalyzeIntent.user_data'` -- no suggestions, no verbose formatting.

Run tests -- they MUST pass.
Commit: `feat(07-01): implement DepError and FillError exception subclasses`
  </action>
  <verify>`cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -x -q` -- all tests pass, new exception tests pass</verify>
  <done>DepError and FillError exist in bae/exceptions.py with structured attributes (node_type, field_name/validation_errors, attempts, trace) and proper BaeError inheritance</done>
</task>

<task type="auto">
  <name>Task 2: TDD - _wants_lm type-hint detection + exports</name>
  <files>bae/node.py, bae/lm.py, bae/__init__.py, tests/test_node_config.py</files>
  <action>
RED phase: Rewrite the TestWantsLm test class in tests/test_node_config.py for type-hint-based detection. The existing 5 tests need to be replaced with v2 equivalents.

New test cases:
- `def __call__(self, lm: LM) -> None` -- returns True (LM type hint present)
- `def __call__(self, model: LM) -> None` -- returns True (different param name, LM type hint)
- `def __call__(self) -> None` -- returns False (no LM param)
- `def __call__(self, lm) -> None` -- returns False (untyped param, even named "lm")
- `def __call__(self, x: int) -> None` -- returns False (non-LM type hint)
- Base Node.__call__ -- returns True (has LM type hint)

IMPORTANT: The v2 behavior CHANGES from v1. In v1, `_wants_lm` checks param NAME "lm". In v2, it checks param TYPE HINT against LM protocol. An untyped param named "lm" now returns False. A typed param named "model" now returns True.

Run tests -- some MUST fail (old implementation checks name, not type).
Commit: `test(07-01): rewrite _wants_lm tests for type-hint detection`

GREEN phase:
1. Add `@runtime_checkable` decorator to LM Protocol in bae/lm.py:
   ```python
   from typing import Protocol, runtime_checkable

   @runtime_checkable
   class LM(Protocol):
   ```

2. Rewrite `_wants_lm` in bae/node.py to check type hints:
   ```python
   def _wants_lm(method) -> bool:
       """Check if __call__ has a parameter type-hinted as LM protocol."""
       hints = get_type_hints(method)
       for name, hint in hints.items():
           if name == "return" or name == "self":
               continue
           if hint is LM:
               return True
       return False
   ```

   Use identity check (`hint is LM`) rather than `issubclass` to avoid Protocol edge cases. Import LM at the top of node.py (move from TYPE_CHECKING to real import since it's needed at runtime for _wants_lm).

   IMPORTANT: The `from __future__ import annotations` at the top of node.py means ALL annotations are strings at runtime. `get_type_hints()` resolves them, but we need the LM class importable. Remove `from __future__ import annotations` from node.py OR ensure get_type_hints can resolve "LM" by importing it properly. Since node.py currently has `if TYPE_CHECKING: from bae.lm import LM`, change this to a real import for _wants_lm to work at runtime.

   Be careful about circular imports: node.py imports from lm.py, lm.py TYPE_CHECKING imports from node.py. This should be fine since lm.py's import of Node is TYPE_CHECKING only.

3. Update bae/__init__.py: Add DepError and FillError to imports and __all__.

Run tests -- they MUST pass.
Commit: `feat(07-01): type-hint-based _wants_lm and @runtime_checkable LM`
  </action>
  <verify>`cd /Users/dzaramelcone/lab/bae && python -m pytest tests/ -x -q` -- all tests pass including rewritten TestWantsLm</verify>
  <done>_wants_lm detects LM by type hint (not name), LM Protocol is @runtime_checkable, DepError+FillError exported from bae package</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/ -x -q` -- all 291+ tests pass
- `from bae import DepError, FillError` works
- `DepError("test", node_type=object, field_name="x").trace` is None (attribute exists)
- `FillError("test", node_type=object, validation_errors="err", attempts=3).attempts` == 3
- `_wants_lm` returns True for LM-typed param regardless of name
- `_wants_lm` returns False for untyped param even if named "lm"
</verification>

<success_criteria>
- DepError and FillError subclass BaeError with structured attributes
- Both error types support exception chaining and carry trace attribute
- _wants_lm is type-hint-based, not name-based
- LM Protocol has @runtime_checkable decorator
- All existing tests still pass (no regressions)
- New error types exported from bae package
</success_criteria>

<output>
After completion, create `.planning/phases/07-integration/07-01-SUMMARY.md`
</output>
