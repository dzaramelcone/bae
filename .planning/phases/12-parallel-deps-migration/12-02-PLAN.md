---
phase: 12-parallel-deps-migration
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - bae/graph.py
  - bae/compiler.py
  - bae/cli.py
  - bae/__init__.py
  - examples/ootd.py
  - examples/run_ootd_traced.py
autonomous: true

must_haves:
  truths:
    - "Graph.run() is sync def (calls asyncio.run internally)"
    - "Graph.arun() is async def (the native async implementation)"
    - "CompiledGraph.run() is sync def, CompiledGraph.arun() is async def"
    - "CLI calls graph.run() directly (no asyncio.run wrapper)"
    - "ootd.py __main__ calls graph.run() directly (no asyncio.run wrapper)"
    - "DepError wrapping happens in graph.arun() with field_name when available"
    - "resolve_fields() calls in graph.arun() use await"
  artifacts:
    - path: "bae/graph.py"
      provides: "Graph with sync run() and async arun()"
      contains: "async def arun"
      exports: ["Graph"]
    - path: "bae/compiler.py"
      provides: "CompiledGraph with sync run() and async arun()"
      contains: "async def arun"
    - path: "bae/cli.py"
      provides: "CLI calling graph.run() without asyncio.run wrapper"
    - path: "examples/ootd.py"
      provides: "Example calling graph.run() synchronously"
  key_links:
    - from: "Graph.run()"
      to: "Graph.arun()"
      via: "asyncio.run(self.arun(...))"
      pattern: "asyncio\\.run\\(self\\.arun"
    - from: "Graph.arun()"
      to: "resolve_fields()"
      via: "await resolve_fields(...)"
      pattern: "await resolve_fields"
    - from: "cli.py run_graph"
      to: "Graph.run()"
      via: "graph.run() direct call"
      pattern: "graph\\.run\\("
---

<objective>
Split Graph.run() into sync run() + async arun(), update all callers, and move DepError wrapping into arun().

Purpose: Restores a sync public API for users who don't care about async (the common case), while preserving async arun() for callers already in an event loop. This is a better public API than requiring asyncio.run() at every call site.

Output: Graph with run()/arun() split, CompiledGraph updated, CLI simplified, ootd.py simplified.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-parallel-deps-migration/12-RESEARCH.md
@.planning/phases/12-parallel-deps-migration/12-CONTEXT.md
@.planning/phases/12-parallel-deps-migration/12-01-SUMMARY.md
@bae/graph.py
@bae/compiler.py
@bae/cli.py
@bae/__init__.py
@examples/ootd.py
@examples/run_ootd_traced.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Split Graph.run() into sync run() and async arun()</name>
  <files>bae/graph.py</files>
  <action>
1. **Rename** the current `async def run(...)` method to `async def arun(...)`. Keep the entire body intact. Update the docstring to say "Async entry point. Use when already in an event loop."

2. **Add `await` to both resolve_fields() calls** inside arun():
   - Line ~239 (current node): `resolved = await resolve_fields(current.__class__, trace, dep_cache)`
   - Line ~290 (target node before fill): `target_resolved = await resolve_fields(target_type, trace, dep_cache)`
   Both calls are currently sync. After Plan 01, resolve_fields is async, so these MUST be awaited.

3. **Move DepError wrapping INTO arun()** -- keep the existing try/except around the `await resolve_fields()` call. The current wrapping is already correct (wraps in DepError with node_type and cause). No changes needed to the error handling structure, just ensure `await` is added.

4. **Add new sync `def run(...)`** method with identical signature but returning synchronously:
   ```python
   def run(self, start_node: Node, lm: LM | None = None, max_iters: int = 10) -> GraphResult:
       """Execute the graph synchronously.

       Convenience wrapper around arun(). Cannot be called from within
       a running event loop (raises RuntimeError).
       """
       return asyncio.run(self.arun(start_node, lm=lm, max_iters=max_iters))
   ```
   Add `import asyncio` at top of graph.py.

5. **Place `run()` before `arun()`** in the class body -- sync API is the primary public interface, async is the escape hatch.

6. **Update the class docstring** example to show `graph.run(...)` (sync, no await).
  </action>
  <verify>
Run `uv run python -c "import inspect; from bae.graph import Graph; print('run sync:', not inspect.iscoroutinefunction(Graph.run)); print('arun async:', inspect.iscoroutinefunction(Graph.arun))"` -- both True.

Run `uv run python -c "from bae.graph import Graph; print('import ok')"` -- no errors.
  </verify>
  <done>Graph.run() is sync def wrapping asyncio.run(self.arun(...)). Graph.arun() is async def with the full execution loop. Both resolve_fields() calls in arun() use await. DepError wrapping preserved around resolve_fields calls.</done>
</task>

<task type="auto">
  <name>Task 2: Update CompiledGraph, CLI, examples, and __init__.py</name>
  <files>bae/compiler.py, bae/cli.py, bae/__init__.py, examples/ootd.py, examples/run_ootd_traced.py</files>
  <action>
**bae/compiler.py:**
- Rename `async def run(...)` to `async def arun(...)` on CompiledGraph
- Update internal call: `return await self.graph.arun(start_node, lm=lm)` (was `self.graph.run`)
- Add sync `def run(...)` that calls `asyncio.run(self.arun(start_node))`
- Add `import asyncio` at top

**bae/cli.py:**
- In `run_graph()` function (line ~269): change `result = asyncio.run(graph.run(start_node, lm=lm))` to just `result = graph.run(start_node, lm=lm)`
- Remove `import asyncio` from the top-level imports since it's no longer needed in cli.py (check if asyncio is used elsewhere in the file first -- it's not, the only usage was in run_graph)

**examples/ootd.py:**
- In `if __name__ == "__main__":` block: change from `result = asyncio.run(graph.run(...))` to `result = graph.run(IsTheUserGettingDressed(user_message="ugh i just got up"))`
- Remove `import asyncio` from the `if __name__` block (it was only used there)

**examples/run_ootd_traced.py:**
- Line 63 currently calls `result = graph.run(...)` -- this was already sync-looking but graph.run was async. Now it's actually sync. This file may need no changes, but verify: if it uses `await`, remove the await. If it already calls graph.run() without await (broken since Phase 11), leave it -- it will now work correctly since run() is sync again.

**bae/__init__.py:**
- No changes needed. `Graph` is already exported. The run/arun methods are on the class, not standalone functions.
  </action>
  <verify>
Run `uv run python -c "from bae.compiler import CompiledGraph; import inspect; print('run sync:', not inspect.iscoroutinefunction(CompiledGraph.run)); print('arun async:', inspect.iscoroutinefunction(CompiledGraph.arun))"` -- both True.

Run `uv run python -c "from bae.cli import run_graph; print('cli import ok')"` -- no error.

Run `uv run python -c "import examples.ootd; print('ootd import ok')"` -- no error.

Grep for leftover `asyncio.run(graph.run` -- should find zero matches.
  </verify>
  <done>CompiledGraph has sync run() + async arun(). CLI calls graph.run() directly (no asyncio.run wrapper). ootd.py calls graph.run() directly (no asyncio.run wrapper). All callers updated.</done>
</task>

</tasks>

<verification>
- Graph.run() is not a coroutine function (sync)
- Graph.arun() is a coroutine function (async)
- CompiledGraph.run() is sync, CompiledGraph.arun() is async
- `await resolve_fields(...)` appears twice in graph.py arun() method
- cli.py has no `asyncio.run` calls
- ootd.py __main__ has no `asyncio.run` or `await`
- No `asyncio.run(graph.run` pattern anywhere in codebase
- `import bae` succeeds
</verification>

<success_criteria>
Graph has sync run() and async arun(). All non-test callers (CLI, examples, compiler) use the sync run() API. resolve_fields() calls properly awaited in arun(). DepError wrapping preserved. No broken imports.
</success_criteria>

<output>
After completion, create `.planning/phases/12-parallel-deps-migration/12-02-SUMMARY.md`
</output>
