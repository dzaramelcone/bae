---
phase: 12-parallel-deps-migration
plan: 04
type: tdd
wave: 3
depends_on: ["12-01"]
files_modified:
  - tests/test_parallel_deps.py
  - bae/resolver.py
autonomous: true

must_haves:
  truths:
    - "Independent deps on the same node fire concurrently (verified by timing or execution order)"
    - "Mixed sync and async dep callables on the same node both resolve correctly"
    - "Dep DAG topo ordering enforced: transitive deps resolve before dependents"
    - "Per-run dep cache correct under concurrent resolution"
    - "First dep failure cancels remaining, propagates as-is (not ExceptionGroup)"
    - "DepError wrapping preserves node_type, field_name, and cause chain"
    - "Graph.run() works from sync context, Graph.arun() works from async context"
  artifacts:
    - path: "tests/test_parallel_deps.py"
      provides: "Targeted tests for Phase 12 parallel dep behavior"
      contains: "async def test_"
      min_lines: 100
  key_links:
    - from: "tests/test_parallel_deps.py"
      to: "bae/resolver.py"
      via: "from bae.resolver import resolve_fields, resolve_dep"
      pattern: "from bae.resolver import"
    - from: "tests/test_parallel_deps.py"
      to: "bae/graph.py"
      via: "from bae import Graph"
      pattern: "from bae import Graph"
---

<objective>
TDD new tests for Phase 12 parallel dep behavior: concurrent gather, sync/async mixing, caching, fail-fast, DepError wrapping, run/arun API.

Purpose: The existing tests verify that the old behavior still works. These new tests verify the NEW behavior introduced in Phase 12 -- concurrency, async dep support, fail-fast cancellation, and the run/arun split.

Output: tests/test_parallel_deps.py with comprehensive coverage of Phase 12 features.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-parallel-deps-migration/12-RESEARCH.md
@.planning/phases/12-parallel-deps-migration/12-CONTEXT.md
@.planning/phases/12-parallel-deps-migration/12-01-SUMMARY.md
@bae/resolver.py
@bae/graph.py
@bae/exceptions.py
@bae/markers.py
@tests/test_resolver.py
</context>

<feature>
  <name>Parallel Dep Resolution</name>
  <files>tests/test_parallel_deps.py, bae/resolver.py</files>
  <behavior>
  Test areas with expected behavior:

  **1. Concurrent gather verification:**
  - Create a node with 2+ independent async deps that each sleep briefly (asyncio.sleep)
  - Measure total resolution time -- should be ~1x sleep, not Nx sleep
  - Alternative: use an execution order list. Two async deps append to a shared list with asyncio.sleep(0) between append and return. If concurrent, both start before either finishes.

  **2. Sync/async dep mixing:**
  - Node with one sync dep and one async dep. Both resolve correctly.
  - Sync dep returns its value. Async dep returns its value.
  - Resolved dict has both values.

  **3. Async dep callable detection:**
  - `async def my_dep() -> str` detected as coroutine function
  - `def my_sync_dep() -> str` detected as non-coroutine
  - Both work through resolve_fields and resolve_dep

  **4. Topo ordering under concurrency:**
  - Node with dep B that depends on dep A (transitive).
  - A resolves first (topo level 0), B resolves second (topo level 1).
  - B receives A's result correctly.

  **5. Per-run cache correctness:**
  - Shared dep_cache across two resolve_fields calls.
  - First call resolves dep X. Second call finds X in cache, doesn't re-call.
  - Verify via call counter.

  **6. Fail-fast cancellation:**
  - Node with 2 independent deps. One raises immediately, other would sleep.
  - First exception propagates raw (not wrapped in ExceptionGroup).
  - Use `asyncio.gather(return_exceptions=False)` behavior.

  **7. DepError wrapping (via graph.arun):**
  - Graph with a node whose dep fails.
  - graph.arun raises DepError with node_type set and cause chained.
  - field_name may be empty for transitive deps.

  **8. run() vs arun() API:**
  - graph.run() works from sync test (call without await)
  - graph.arun() works from async test (call with await)
  - graph.run() from inside running event loop raises RuntimeError
  </behavior>
  <implementation>
  Write RED tests first (assert expected behavior), then verify they pass against the already-implemented resolver from Plan 01 and graph from Plan 02. Since this is TDD but the implementation already exists, the tests should go GREEN immediately if the implementation is correct. Any failures indicate bugs in the implementation that need fixing.

  If any tests fail, fix the implementation in bae/resolver.py or bae/graph.py to make them pass. This is the REFACTOR step.

  Test fixtures:
  - Define async dep functions: `async def async_get_location() -> str`
  - Define sync dep functions: `def sync_get_temperature() -> int`
  - Define failing dep: `def failing_dep() -> str: raise ConnectionError("boom")`
  - Define slow async dep: `async def slow_dep() -> str: await asyncio.sleep(0.1); return "slow"`
  - Define node classes with various dep configurations using Annotated[T, Dep(fn)]
  </implementation>
</feature>

<verification>
- `uv run python -m pytest tests/test_parallel_deps.py -v --tb=short` -- all new tests pass
- `uv run python -m pytest tests/ -v --tb=short` -- full suite still passes (no regressions)
- New test file has tests for all 8 areas listed above
- At least 10 new test functions
</verification>

<success_criteria>
New test file tests/test_parallel_deps.py covers concurrent gather, sync/async mixing, topo ordering, caching, fail-fast, DepError wrapping, and run/arun API. All tests pass. Full suite passes with 323+ tests (existing + new).
</success_criteria>

<output>
After completion, create `.planning/phases/12-parallel-deps-migration/12-04-SUMMARY.md`
</output>
