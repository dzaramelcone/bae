---
phase: 12-parallel-deps-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bae/resolver.py
autonomous: true

must_haves:
  truths:
    - "resolve_fields() is async def and uses asyncio.gather() for concurrent dep resolution"
    - "resolve_dep() is async def and resolves a single callable (transitive deps from cache)"
    - "Sync dep callables work via thin coroutine wrapper (not asyncio.to_thread)"
    - "Async dep callables work via direct await"
    - "Topo-sort level-by-level iteration uses graphlib.TopologicalSorter.prepare()/get_ready()/done()"
    - "Per-run dep cache populated correctly under topo ordering (no races)"
    - "Resolved dict preserves field declaration order"
    - "Recall fields resolved synchronously after deps (pure computation)"
  artifacts:
    - path: "bae/resolver.py"
      provides: "Async resolve_fields with gather, async resolve_dep, _resolve_one helper"
      contains: "async def resolve_fields"
      exports: ["resolve_fields", "resolve_dep"]
  key_links:
    - from: "resolve_fields"
      to: "build_dep_dag"
      via: "dag = build_dep_dag(node_cls)"
      pattern: "build_dep_dag"
    - from: "resolve_fields"
      to: "asyncio.gather"
      via: "await asyncio.gather(*[_resolve_one...])"
      pattern: "asyncio\\.gather"
    - from: "_resolve_one"
      to: "inspect.iscoroutinefunction"
      via: "runtime sync/async detection"
      pattern: "inspect\\.iscoroutinefunction"
---

<objective>
Convert resolve_fields() and resolve_dep() to async with concurrent dep resolution via asyncio.gather().

Purpose: This is the core implementation of parallel dep resolution -- the primary feature of Phase 12. Independent deps on the same node will fire concurrently within each topological level.

Output: bae/resolver.py with async resolve_fields(), async resolve_dep(), and internal _resolve_one() helper.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-parallel-deps-migration/12-RESEARCH.md
@.planning/phases/12-parallel-deps-migration/12-CONTEXT.md
@bae/resolver.py
@bae/markers.py
@bae/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert resolve_dep() to async and add _resolve_one() helper</name>
  <files>bae/resolver.py</files>
  <action>
Convert `resolve_dep()` from sync recursive resolver to async. The new implementation:

1. **Add imports** at the top of resolver.py:
   - `import asyncio`
   - `import inspect`

2. **Create `_resolve_one(fn, cache)` as async internal helper:**
   - Inspect fn's type hints for Dep-annotated parameters
   - For each Dep param, look up the value in `cache` (guaranteed to exist by topo ordering)
   - Build kwargs dict from cache lookups
   - If `inspect.iscoroutinefunction(fn)`: `return await fn(**kwargs)`
   - Else (sync callable): `return fn(**kwargs)` -- this is the thin coroutine wrapper; calling a sync function from within an async def is sufficient for asyncio.gather() participation. Do NOT use asyncio.to_thread().

3. **Rewrite `resolve_dep(fn, cache)` as `async def resolve_dep(fn, cache)`:**
   - Keep the same public signature (fn: object, cache: dict) -> object
   - Keep the cache-hit fast path: `if fn in cache: return cache[fn]`
   - Instead of recursive resolution, build a mini-DAG using `build_dep_dag_for_callable(fn)` -- actually, reuse the topo-sort approach:
     - Create a TopologicalSorter for just this callable's transitive deps
     - Walk fn's type hints recursively to build the DAG (same walk as build_dep_dag but seeded from fn, not a node class)
     - Call `prepare()`, then for each level: gather uncached callables via `asyncio.gather(*[_resolve_one(f, cache) for f in to_resolve])`, cache results, mark done
   - After all levels resolved, return `cache[fn]`
   - This preserves the existing test API: `await resolve_dep(get_weather, cache)` works and resolves transitives

   **Alternative (simpler):** Since `build_dep_dag` is seeded from node class fields but the walk logic is the same, factor out a `_build_callable_dag(fn)` that builds a TopologicalSorter for a single callable and its transitive deps. Use this in both `resolve_dep` and `resolve_fields`.

   Actually, the simplest approach: `resolve_dep` can just use the same level-by-level gather pattern. Build a TopologicalSorter by walking `fn`'s dep hints recursively (reuse the `walk` closure pattern from `build_dep_dag`), then iterate levels with prepare/get_ready/done + gather. This keeps resolve_dep self-contained and testable.

Keep all existing sync functions (classify_fields, recall_from_trace, build_dep_dag, validate_node_deps, _callable_name) UNCHANGED -- they are pure computation with no I/O.
  </action>
  <verify>
Run `uv run python -c "import inspect; from bae.resolver import resolve_dep, resolve_fields; print('resolve_dep async:', inspect.iscoroutinefunction(resolve_dep)); print('resolve_fields async:', inspect.iscoroutinefunction(resolve_fields))"` -- both should print True.

Run `uv run python -c "from bae.resolver import classify_fields, recall_from_trace, build_dep_dag, validate_node_deps; print('sync functions intact')"` -- should succeed without error.
  </verify>
  <done>resolve_dep and _resolve_one are async def. Sync dep callables detected via inspect.iscoroutinefunction and called directly (not to_thread). Async dep callables awaited directly. Cache lookup on hit returns immediately.</done>
</task>

<task type="auto">
  <name>Task 2: Convert resolve_fields() to async with topo-sort gather</name>
  <files>bae/resolver.py</files>
  <action>
Rewrite `resolve_fields()` as `async def resolve_fields(node_cls, trace, dep_cache)`:

1. **Field classification** (same as current): iterate get_type_hints, classify each field as dep (has Dep marker with fn), recall (has Recall marker), or skip (plain). Build:
   - `dep_fields: dict[str, object]` mapping field_name -> callable
   - `recall_fields: dict[str, type]` mapping field_name -> base_type

2. **Dep resolution via topo-sort levels:**
   - If dep_fields is non-empty:
     - `dag = build_dep_dag(node_cls)` -- reuse existing function
     - `dag.prepare()`
     - While `dag.is_active()`:
       - `ready = dag.get_ready()` -- returns set of callables ready for this level
       - `to_resolve = [fn for fn in ready if fn not in dep_cache]` -- skip already-cached
       - If to_resolve: `results = await asyncio.gather(*[_resolve_one(fn, dep_cache) for fn in to_resolve])`
       - Cache results: `for fn, result in zip(to_resolve, results): dep_cache[fn] = result`
       - Mark all ready as done: `for fn in ready: dag.done(fn)`
     - Map cached results to field names: `for field_name, fn in dep_fields.items(): resolved[field_name] = dep_cache[fn]`

3. **Recall resolution** (after deps, synchronous):
   - For each recall field: `resolved[field_name] = recall_from_trace(trace, base_type)`
   - Recall is pure computation (walks a list). No async benefit.

4. **Preserve declaration order:**
   - Build the final resolved dict by iterating `hints` in declaration order (same as get_type_hints returns), NOT by iterating dep_fields then recall_fields separately.
   - Specifically: iterate all fields in hints order, and for each one that's in dep_fields or recall_fields, add it to resolved. This matches the current behavior and passes the declaration_order test.

5. **Do NOT wrap exceptions in DepError here** -- that will be moved from graph.py in Plan 02. For now, let exceptions from _resolve_one / asyncio.gather propagate raw, same as current resolve_dep behavior.

The key difference from the research code example: build the resolved dict in declaration order (step 4), not dep-first then recall-second.
  </action>
  <verify>
Run `uv run python -c "import asyncio; from bae.resolver import resolve_fields; print(type(resolve_fields))"` -- should show it's a function (coroutine function).

The existing tests in test_resolver.py will NOT pass yet (they call resolve_fields/resolve_dep synchronously). That's expected -- test migration is Plan 03.
  </verify>
  <done>resolve_fields is async def. Uses build_dep_dag + prepare/get_ready/done for level-by-level resolution. Each level gathered via asyncio.gather. Recall resolved synchronously after deps. Result dict in declaration order. dep_cache correctly populated for cross-call sharing.</done>
</task>

</tasks>

<verification>
- `inspect.iscoroutinefunction(resolve_fields)` returns True
- `inspect.iscoroutinefunction(resolve_dep)` returns True
- `classify_fields`, `recall_from_trace`, `build_dep_dag`, `validate_node_deps` remain sync
- `import bae.resolver` succeeds without error
- `_resolve_one` uses `inspect.iscoroutinefunction` for sync/async detection
- No `asyncio.to_thread` anywhere in resolver.py
</verification>

<success_criteria>
resolve_fields() and resolve_dep() are async def. Independent deps gathered concurrently per topo level. Sync/async dep callables both supported via runtime detection. Declaration order preserved. Recall resolution is synchronous. No new dependencies added (all stdlib).
</success_criteria>

<output>
After completion, create `.planning/phases/12-parallel-deps-migration/12-01-SUMMARY.md`
</output>
