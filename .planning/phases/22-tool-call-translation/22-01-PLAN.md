---
phase: 22-tool-call-translation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bae/repl/ai.py
  - tests/repl/test_ai.py
autonomous: true

must_haves:
  truths:
    - "translate_tool_calls('<R:src/main.py>') returns Python code that reads src/main.py"
    - "translate_tool_calls('<W:out.txt>hello</W>') returns Python code that writes 'hello' to out.txt"
    - "translate_tool_calls('<E:f.py:10-15>') returns Python code that reads lines 10-15"
    - "translate_tool_calls('<E:f.py:10-15>new content</E>') returns Python code that replaces lines 10-15"
    - "translate_tool_calls('<G:src/**/*.py>') returns Python code that globs for .py files"
    - "translate_tool_calls('<Grep:def main>') returns Python code that greps for 'def main'"
    - "translate_tool_calls returns empty list when no tool tags are present"
    - "Tool tags inside <run> blocks or markdown fences are ignored"
    - "All tool tags in a response are translated and returned as a list"
  artifacts:
    - path: "bae/repl/ai.py"
      provides: "translate_tool_calls() function, _TOOL_TAG_RE, _WRITE_TAG_RE, _EDIT_REPLACE_RE constants"
      contains: "def translate_tool_calls"
    - path: "tests/repl/test_ai.py"
      provides: "TestTranslateToolCalls test class"
      contains: "class TestTranslateToolCalls"
  key_links:
    - from: "bae/repl/ai.py"
      to: "bae/repl/ai.py"
      via: "translate_tool_calls uses _EXEC_BLOCK_RE to strip <run> blocks before scanning"
      pattern: "_EXEC_BLOCK_RE\\.sub"
---

<objective>
Implement `translate_tool_calls()` pure function that detects ALL terse tool call tags in AI response prose and returns a list of equivalent Python code strings.

Purpose: Core detection + translation logic for all 5 tool types (R, W, E, G, Grep). Must be testable in isolation before eval loop integration. TDD ensures each tool type has verified input -> output behavior. Unlike `<run>` blocks (first-only), tool calls are discrete independent operations so ALL tags in a response are translated.

Output: `translate_tool_calls()` function and supporting regexes/translators in `bae/repl/ai.py`, with comprehensive tests in `tests/repl/test_ai.py`.
</objective>

<execution_context>
@/Users/dzaramelcone/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzaramelcone/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-tool-call-translation/22-RESEARCH.md
@bae/repl/ai.py
@tests/repl/test_ai.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD translate_tool_calls — all 5 tool types with fence exclusion</name>
  <files>bae/repl/ai.py, tests/repl/test_ai.py</files>
  <action>
**RED phase:** Write `TestTranslateToolCalls` in `tests/repl/test_ai.py`. Import `translate_tool_calls` from `bae.repl.ai` (will fail until GREEN). Test cases:

1. `test_read_tag` — `"<R:src/main.py>"` on its own line returns Python code containing `open('src/main.py')` and truncation to `_MAX_TOOL_OUTPUT`
2. `test_write_tag` — `"<W:out.txt>\nhello world\n</W>"` returns Python code containing `open('out.txt', 'w').write(...)`
3. `test_edit_read_tag` — `"<E:f.py:10-15>"` returns Python code that reads lines 10-15 (1-based inclusive, so `readlines()[9:15]`)
4. `test_edit_replace_tag` — `"<E:f.py:10-15>\nnew stuff\n</E>"` returns Python code that replaces lines 10-15 with "new stuff"
5. `test_glob_tag` — `"<G:src/**/*.py>"` returns Python code with `glob.glob(...)` and truncation
6. `test_grep_tag` — `"<Grep:def main>"` returns Python code with subprocess grep, `--include=*.py`, exclusion dirs, and timeout
7. `test_no_tags_returns_empty` — plain prose returns empty list
8. `test_illustrative_fence_ignored` — `"<R:foo.py>"` inside a markdown fence (``` ... ```) returns empty list
9. `test_run_block_ignored` — `"<R:foo.py>"` inside a `<run>...</run>` block returns empty list
10. `test_multiple_tags_all_translated` — response with `<R:a.py>` and `<G:src/*.py>` on separate lines returns list with both translations in order
11. `test_tag_must_be_on_own_line` — `"some text <R:foo.py> more text"` embedded in prose returns empty list (tag must be the primary content on its line, starting at optional whitespace)
12. `test_write_without_closing_tag` — `"<W:foo.txt>"` with no `</W>` returns empty list (strict closing tag required)

**GREEN phase:** Implement in `bae/repl/ai.py`:

Constants (module level, after `_EXEC_BLOCK_RE`):
```python
_MAX_TOOL_OUTPUT = 4000

_TOOL_TAG_RE = re.compile(
    r"^[ \t]*<(R|E|G|Grep):([^>]+)>\s*$",
    re.MULTILINE,
)

_WRITE_TAG_RE = re.compile(
    r"^[ \t]*<W:([^>]+)>\s*\n(.*?)\n[ \t]*</W>",
    re.DOTALL | re.MULTILINE,
)

_EDIT_REPLACE_RE = re.compile(
    r"^[ \t]*<E:([^:>]+):(\d+)-(\d+)>\s*\n(.*?)\n[ \t]*</E>",
    re.DOTALL | re.MULTILINE,
)
```

Individual translator functions (module-level, private):
- `_translate_read(filepath)` — `open(fp).read()[:4000]` with truncation notice
- `_translate_write(filepath, content)` — `open(fp, 'w').write(content)` with char count print
- `_translate_edit_read(arg)` — parse `filepath:start-end`, readlines slice `[start-1:end]` with line numbers
- `_translate_edit_replace(filepath, start, end, content)` — readlines, splice, writelines
- `_translate_glob(pattern)` — `glob.glob(pattern, recursive=True)` with truncation
- `_translate_grep(pattern)` — `subprocess.run(['grep', '-rn', '--include=*.py', ...])`  with `--exclude-dir` for `.venv`, `.git`, `__pycache__`, `node_modules`, timeout=10

Main function:
```python
def translate_tool_calls(text: str) -> list[str]:
```
1. Strip `<run>...</run>` blocks using `_EXEC_BLOCK_RE.sub("", text)`
2. Strip markdown fences using `re.sub(r"```.*?```", "", prose, flags=re.DOTALL)`
3. Collect ALL Write tags via `_WRITE_TAG_RE.finditer(prose)` — translate each
4. Collect ALL Edit-with-replacement tags via `_EDIT_REPLACE_RE.finditer(prose)` — translate each
5. Collect ALL single-line tags via `_TOOL_TAG_RE.finditer(prose)` — route R/E/G/Grep, translate each
6. Deduplicate (a Write/Edit-replace match region shouldn't also match as a single-line tag)
7. Return list of translated Python code strings (empty list if no matches)

Key details:
- `_TOOL_TAG_RE` uses `^` anchor and `$` end to require tags on their own line (prevents false positives on embedded tags in prose)
- Line numbers are 1-based inclusive in the tag, translated to 0-based Python slicing: `lines[start-1:end]`
- All output truncated to `_MAX_TOOL_OUTPUT` (4000 chars)
- Grep excludes `.venv`, `.git`, `__pycache__`, `node_modules` and limits to `*.py` files
- ALL tool tags in the response are translated, not just the first (tool calls are independent operations)

**REFACTOR:** Clean up if needed. Ensure all tests pass with `pytest tests/repl/test_ai.py -x`.
  </action>
  <verify>
`pytest tests/repl/test_ai.py::TestTranslateToolCalls -v` — all 12 tests pass.
`pytest tests/repl/test_ai.py -v` — full existing test suite still green (no regressions).
  </verify>
  <done>
`translate_tool_calls()` detects all 5 tool tag types in prose, ignores tags inside fences/<run> blocks, returns list of Python code strings (empty if none). All tool tags in a response are translated. All 12+ tests pass. Existing tests unaffected.
  </done>
</task>

</tasks>

<verification>
```bash
pytest tests/repl/test_ai.py -v
```
All tests pass including new TestTranslateToolCalls class and existing TestExtractExecutable, TestEvalLoop, etc.
</verification>

<success_criteria>
- `translate_tool_calls()` is a pure function: string in, list of strings out
- All 5 tool types (R, W, E, G, Grep) translate to correct Python code
- Tags inside `<run>` blocks and markdown fences are ignored
- ALL tool tags in a response are translated (not first-only)
- Output truncation built into every translation
- Tags must appear on their own line (no false positives on embedded angle brackets)
- Write requires closing `</W>` tag
</success_criteria>

<output>
After completion, create `.planning/phases/22-tool-call-translation/22-01-SUMMARY.md`
</output>
