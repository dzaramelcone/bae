# Codebase Structure

**Analysis Date:** 2026-02-04

## Directory Layout

```
bae/
├── __init__.py           # Public API exports: Node, NodeConfig, Graph, LM, backends
├── node.py               # Node base class, type hint extraction, NodeConfig
├── graph.py              # Graph discovery, validation, execution loop, Mermaid export
├── lm.py                 # LM protocol, PydanticAIBackend, ClaudeCLIBackend
└── compiler.py           # DSPy compilation stubs (not wired)

tests/
├── __init__.py           # Empty
├── test_node.py          # Node topology and __call__ behavior (passing)
├── test_graph.py         # Graph discovery, execution, validation, max_steps (passing)
└── test_integration.py   # Real LLM tests (needs Claude CLI flag fix)

.planning/codebase/       # Generated documentation directory
```

## Directory Purposes

**bae/:**
- Purpose: Core framework - node base class, graph orchestration, LM protocol, backends
- Contains: Pure Python, no external dependencies beyond Pydantic and pydantic-ai
- Key files: All 5 files are critical to functioning framework

**tests/:**
- Purpose: Unit and integration tests
- Contains: Test fixtures, mock LM implementations, test node classes
- Key files: `test_node.py`, `test_graph.py` are passing; `test_integration.py` needs fix

**.planning/codebase/:**
- Purpose: Documentation generated by GSD tools
- Contains: ARCHITECTURE.md, STRUCTURE.md, etc.
- Generated: Yes
- Committed: Yes

## Key File Locations

**Entry Points:**
- `bae/__init__.py`: Public API for users; import `Node`, `Graph`, `LM`, backends here

**Configuration:**
- `pyproject.toml`: Project metadata, dependencies (pydantic, pydantic-ai, dspy, incant), ruff config
- None of the main source files have per-file configuration

**Core Logic:**
- `bae/node.py`: Type hint extraction (`_extract_types_from_hint`, `_hint_includes_none`), Node class, terminal detection
- `bae/graph.py`: Topology discovery via BFS (`_discover`), execution loop (`run`), validation (`validate`), visualization (`to_mermaid`)
- `bae/lm.py`: LM protocol, two concrete backends with different strategies (pydantic-ai vs subprocess)

**Testing:**
- `tests/test_node.py`: Tests for successor extraction, terminal node detection, node call behavior
- `tests/test_graph.py`: Tests for graph discovery, execution, validation, max steps protection
- `tests/test_integration.py`: Real LLM tests (requires API key or Claude CLI)

## Naming Conventions

**Files:**
- Lowercase with underscores: `node.py`, `lm.py`, `test_node.py`, `test_integration.py`
- No file-specific configs; settings in `pyproject.toml`

**Directories:**
- `bae/`: Package directory (main source)
- `tests/`: Test directory (pytest discovers here)

**Classes:**
- PascalCase: `Node`, `Graph`, `LM`, `NodeConfig`, `PydanticAIBackend`, `ClaudeCLIBackend`, `CompiledGraph`
- User-defined node subclasses in PascalCase: `Start`, `Process`, `Review`, `Clarify` (from tests)

**Functions:**
- snake_case: `successors()`, `is_terminal()`, `validate()`, `run()`, `make()`, `decide()`
- Private helpers prefixed with `_`: `_discover()`, `_extract_types_from_hint()`, `_hint_includes_none()`, `_node_to_prompt()`, `_build_schema()`, `_run_cli()`, `_get_agent()`

**Methods:**
- `__call__()`: Node's routing method (must implement)
- `__init__()`: Pydantic handles via BaseModel
- Model methods from Pydantic: `model_dump()`, `model_validate()`, `model_json_schema()`, `model_fields`

**Type Variables:**
- `T`: Generic type variable for `make(node, target: type[T]) -> T`

## Where to Add New Code

**New Node Type (User Code):**
- Location: Anywhere the user imports from bae
- Pattern: Subclass `Node`, define fields, implement `__call__(self, lm: LM) -> NextNodeType | OtherType | None`
- Example:
  ```python
  from bae import Node, Graph, PydanticAIBackend

  class RequestAnalysis(Node):
      request: str

      def __call__(self, lm):
          return lm.decide(self)

  class CodeGeneration(Node):
      task: str
      code: str = ""

      def __call__(self, lm):
          return lm.make(self, CodeReview)
  ```

**New LM Backend:**
- Location: `bae/lm.py`
- Pattern: Create new class, implement `LM` protocol (`make`, `decide` methods), handle prompt construction and response parsing
- Responsibilities: Convert node state to prompt, call external service/subprocess, parse response as JSON, validate against target schema
- Examples: `PydanticAIBackend` uses pydantic-ai library; `ClaudeCLIBackend` uses subprocess

**New Node Feature:**
- Location: `bae/node.py`
- Pattern: Add to `Node` class or create utility in file; use Pydantic mechanisms where possible
- Current: `model_config` (per-node LLM settings), `successors()`, `is_terminal()` for topology

**Graph Feature:**
- Location: `bae/graph.py`
- Pattern: Add method to `Graph` class; leverage existing `_nodes` adjacency dict and BFS pattern
- Current: `validate()` checks for infinite loops, `to_mermaid()` exports diagram, `run()` executes

**Tests:**
- Location: `tests/test_*.py` files
- Pattern: Use `MockLM` that returns from sequence; define test node classes inline; use pytest
- Files:
  - `test_node.py`: Node topology and __call__ behavior
  - `test_graph.py`: Graph discovery, execution, max_steps
  - `test_integration.py`: Real LLM backends (needs env setup)

## Special Directories

**.venv/:**
- Purpose: Python virtual environment with installed dependencies
- Generated: Yes (uv handles)
- Committed: No (.gitignored)

**.git/:**
- Purpose: Version control
- Generated: Yes
- Committed: N/A

**.pytest_cache/:**
- Purpose: pytest caching for faster test runs
- Generated: Yes
- Committed: No

## File Patterns

**Public API Surface:**
- Export from `bae/__init__.py`: Users import from `bae` not `bae.node` or `bae.lm`
- Classes: `Node`, `NodeConfig`, `Graph`, `LM`, `PydanticAIBackend`, `ClaudeCLIBackend`

**Protocol vs Implementation:**
- `LM` is a Protocol (structural typing) in `bae/lm.py`
- Backends (`PydanticAIBackend`, `ClaudeCLIBackend`) implement the protocol
- No base class required - any object with `make()` and `decide()` methods works

**Node Introspection:**
- Uses `get_type_hints()` from `typing` module to extract `__call__` return type
- Uses `get_args()` to unpack union types (`A | B`)
- Uses `types.UnionType` (Python 3.10+) to detect union syntax

---

*Structure analysis: 2026-02-04*
